[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggplot2: Gráficos elegantes para análisis de datos (3e)",
    "section": "",
    "text": "¡Bienvenidos!\nEsta es la versión en línea del trabajo en progreso 3.ª edición de “ggplot2: gráficos elegantes para análisis de datos” publicado por Springer. Puede conocer los cambios con respecto a la segunda edición en el Prefacio.\nSi bien este libro brinda algunos detalles sobre los conceptos básicos de ggplot2, su enfoque principal es explicar la gramática de los gráficos que utiliza ggplot2 y describir todos los detalles. No es un libro de cocina y no necesariamente le ayudará a crear ningún gráfico específico que necesite. Pero le ayudará a comprender los detalles de la teoría subyacente y le permitirá adaptar cualquier gráfica específicamente a sus necesidades.\nEste libro fue escrtito por Hadley Wickham, Danielle Navarro, y Thomas Lin Pedersen.",
    "crumbs": [
      "¡Bienvenidos!"
    ]
  },
  {
    "objectID": "index.html#sobre-la-traducción",
    "href": "index.html#sobre-la-traducción",
    "title": "ggplot2: Gráficos elegantes para análisis de datos (3e)",
    "section": "Sobre La Traducción",
    "text": "Sobre La Traducción\n Esta traducción de “ggplot2: Gráficos elegantes para análisis de datos” es un proyecto personal de David Díaz Rodríguez con el objetivo de facilitar el estudio de construcción de gráficas mediante el uso de ggplot2, tanto al propio traductor como a todas aquellas personas de habla hispana que deseen aprender sobre este tema.\nSeñalar que esta es una traducción textual del libro por lo que cuando los autores se refieren así mismo en primera persona, serán Hadley Wickham, Danielle Navarro, y Thomas Lin Pedersen no el traductor.\nLa traducción fue realizada usando Google Translate y fueron corregidos algunos errores gramaticales y de coherencia. Si detecta algún error relacionado con el contenido de la traducción, siéntase libre de abrir un issue o un pull request en este repositorio.",
    "crumbs": [
      "¡Bienvenidos!"
    ]
  },
  {
    "objectID": "preface-3e.html",
    "href": "preface-3e.html",
    "title": "Prefacio a la tercera edición",
    "section": "",
    "text": "Cambios principales\nBienvenidos a la tercera edición de “ggplot2: gráficos elegantes para análisis de datos”. Estoy muy emocionado de tener una nueva edición del libro actualizada con todos los cambios que le han ocurrido a ggplot2 en los últimos cinco años. También estoy emocionado de tener finalmente una versión en línea del libro, &lt;https://ggplot2-book.org/&gt;, gracias a un contrato renegociado con Springer.\nDesde la última versión del libro, el cambio más importante en ggplot2 es el crecimiento de la comunidad de contribuyentes. Si bien sigo liderando el proyecto y sigo preocupándome profundamente por la visualización, ya no estoy involucrado en el desarrollo diario del paquete. Al momento de escribir este artículo, los desarrolladores principales de ggplot2 son:\nPuede ver una lista actualizada y cómo convertirse en desarrollador principal en el documento de gobernanza de ggplot2.",
    "crumbs": [
      "Prefacio a la tercera edición"
    ]
  },
  {
    "objectID": "preface-3e.html#cambios-principales",
    "href": "preface-3e.html#cambios-principales",
    "title": "Prefacio a la tercera edición",
    "section": "",
    "text": "Los capítulos Análisis de datos, Transformación de datos y Modelado para visualización se han eliminado para que el libro pueda centrarse en la visualización. Si busca consejos generales sobre cómo hacer ciencia de datos en R, le recomendamos R para ciencia de datos (2e).\nEl capítulo Caja de herramientas se ha ampliado en seis capítulos que cubren aplicaciones prácticas de capas. Esto incluye más material sobre mapas y anotaciones, y un nuevo capítulo que analiza cómo organizar varios gráficos en una página.\nDe manera similar, el antiguo capítulo Escalas, ejes y leyendas se ha dividido en cuatro capítulos. Los tres primeros cubren la combinación práctica de escalas y guías para los tipos de escalas más comunes, y el último capítulo se centra en la teoría subyacente.\nEl antiguo capítulo de Posicionamiento se ha dividido en nuevos capítulos de Sistemas de coordenadas y Facetado, lo que brinda más espacio para detalles sobre estos importantes temas.\nLos nuevos capítulos describen más sobre los aspectos internos de ggplot2 y cómo puede ampliarlo en su propio paquete.",
    "crumbs": [
      "Prefacio a la tercera edición"
    ]
  },
  {
    "objectID": "preface-3e.html#agradecimientos",
    "href": "preface-3e.html#agradecimientos",
    "title": "Prefacio a la tercera edición",
    "section": "Agradecimientos",
    "text": "Agradecimientos\nEsta edición del libro fue posible gracias a dos nuevos coautores: Danielle Navarro y Thomas Lin Pedersen. Danielle contribuyó con la mayor parte del material nuevo en los capítulos de capas y escalas, y Thomas contribuyó con nuevos capítulos sobre cómo organizar las gráficas (usando su paquete patchwork) y sobre cómo extender ggplot2.\nEste libro fue escrito abiertamente y los capítulos se anunciaron en Twitter cuando se completaron. Es verdaderamente un esfuerzo comunitario: muchas personas leyeron borradores, corrigieron errores tipográficos, sugirieron mejoras y contribuyeron con contenido. Sin esos colaboradores, el libro no sería tan bueno como es y estoy profundamente agradecido por su ayuda.\nMuchas gracias a todos 34 personas que contribuyeron con mejoras específicas a través de pull request de GitHub (en orden alfabético por nombre de usuario): Alexej Gossmann (@agisga), @chriselrod, Carson Sievert (@cpsievert), Dave Childers (@davechilders), @dicorynia, Dennis Murphy (@djmurphy420), Danielle Navarro (@djnavarro), @dmurdoch, Zhuoer Dong (@dongzhuoer), Dan Yavorsky (@dyavorsky), Francisco Júnior (@fjuniorr), Gökçen Eraslan (@gokceneraslan), jashapiro (@jashapiro), Jim Hester (@jimhester), Jeffrey Girard (@jmgirard), Joel Gombin (@joelgombin), @jonas-hag, @lindbrook, @MarHer90, Mine Cetinkaya-Rundel (@mine-cetinkaya-rundel), Neil McGuigan (@neilmcguigan), Clemens Schmid (@nevrome), Pietro Monticone (@pitmonticone), Patrick Kennedy (@pkq), Robin (@Robinlovelace), Sean Hughes (@seaaan), Thomas Lin Pedersen (@thomasp85), Thomas Klebel (@tklebel), Tom Jemmett (@tomjemmett), Alex Trueman (@truemoid), Will Beasley (@wibeasley), Jake Thompson (@wjakethompson), Yang Cao (@yiluheihei), Hiroaki Yutani (@yutannihilation).",
    "crumbs": [
      "Prefacio a la tercera edición"
    ]
  },
  {
    "objectID": "preface-2e.html",
    "href": "preface-2e.html",
    "title": "Prefacio a la segunda edición.",
    "section": "",
    "text": "Cambios principales\nBienvenidos a la segunda edición de “ggplot2: gráficos elegantes para análisis de datos”. Estoy muy emocionado de tener un libro actualizado que muestra las últimas y mejores características de ggplot2, así como las grandes cosas que han estado sucediendo en R y en la comunidad de ggplot2 durante los últimos cinco años. La comunidad ggplot2 es vibrante: la lista de correo de ggplot2 tiene más de 7000 miembros y hay una comunidad Stack Overflow muy activa, con casi 10,000 preguntas etiquetadas con ggplot2. Si bien la mayor parte de mi esfuerzo de desarrollo ya no se centra en ggplot2 (más sobre esto a continuación), nunca ha habido un mejor momento para aprenderlo y usarlo.\nEstoy tremendamente agradecido por el éxito de ggplot2. Es uno de los paquetes R más descargados (¡más de un millón de descargas en el último año!) y ha influido en el diseño de paquetes gráficos para otros lenguajes. Personalmente, ggplot2 me ha brindado muchas oportunidades interesantes para viajar por el mundo y conocer gente interesante. Me encanta escuchar cómo la gente usa R y ggplot2 para comprender los datos que les interesan.\nUn gran agradecimiento por esta edición a Carson Sievert, quien me ayudó a modernizar el código, incluida la conversión de las fuentes a R Markdown. También actualizó muchos de los ejemplos y me ayudó a corregir el libro.\nMe he esforzado mucho en garantizar que esta edición sea una verdadera actualización con respecto a la primera. Además de actualizar el código en todas partes para asegurarme de que sea totalmente compatible con la última versión de ggplot2, tengo:\nEl libro va acompañado de una nueva versión de ggplot2: versión 2.0.0. Esto incluye una serie de ajustes y mejoras menores, y mejoras considerables en la documentación. Volver al desarrollo de ggplot2 después de una pausa considerable me ha ayudado a ver muchos problemas que antes pasaban desapercibidos. ggplot2 2.0.0 (¡por fin!) contiene un mecanismo de extensión oficial para que otros puedan contribuir con nuevos componentes de ggplot2 en sus propios paquetes. Esto está documentado en una nueva viñeta, vignette(\"extending-ggplot2\").",
    "crumbs": [
      "Prefacio a la segunda edición."
    ]
  },
  {
    "objectID": "preface-2e.html#cambios-principales",
    "href": "preface-2e.html#cambios-principales",
    "title": "Prefacio a la segunda edición.",
    "section": "",
    "text": "Se muestra mucho más código en el libro, por lo que es más fácil de usar como referencia. En general, el libro tiene una sensibilidad más “knitr”: hay menos figuras y tablas flotantes, y más código en línea. Esto hace que el diseño sea un poco menos bonito pero mantiene los elementos relacionados más juntos.\nSe publicó la fuente completa en línea en https://github.com/hadley/ggplot2-book.\nSe cambió de qplot() a ggplot() en la introducción. Los comentarios indicaron que qplot() era una muleta: facilita un poco las gráficas simples, pero no ayuda a dominar la gramática.\nSe agregaron ejercicios de práctica a lo largo del libro para que puedas practicar nuevas técnicas inmediatamente después de aprender sobre ellas.\nSe agregaron sugerencias al rico ecosistema de paquetes que se han creado alrededor de ggplot2. Ahora verá una serie de otros paquetes resaltados en el libro y obtendrá sugerencias sobre otros paquetes que creo que son particularmente útiles.\nSe revisó el capítulo de la caja de herramientas para cubrir todas las nuevas geoms. Agregué una sección completamente nueva sobre etiquetas de texto, ya que es importante y no se trata en detalle en ningún otro lugar. La sección de mapas se ha ampliado considerablemente para hablar más sobre los diferentes tipos de datos de mapas y dónde puede encontrarlos.\nSe reescribió completamente el capítulo de escalas para centrarse en las tareas más importantes. También analiza las nuevas características que brindan un control más preciso sobre la apariencia de la leyenda y muestra algunas de las nuevas escalas agregadas a ggplot2.\nDivida el capítulo de análisis de datos en tres partes: ordenamiento de datos (con tidyr), manipulación de datos (con dplyr) y visualización de modelos (con escoba). Hablo de la última versión de mis herramientas de manipulación de datos y presento el fantástico paquete escoba de David Robinson.",
    "crumbs": [
      "Prefacio a la segunda edición."
    ]
  },
  {
    "objectID": "preface-2e.html#the-future",
    "href": "preface-2e.html#the-future",
    "title": "Prefacio a la segunda edición.",
    "section": "The future",
    "text": "The future\nggplot2 ahora es estable y es poco probable que cambie mucho en el futuro. Habrá correcciones de errores y es posible que haya nuevas geoms, pero no habrá grandes cambios en el funcionamiento de ggplot2. La siguiente iteración de ggplot2 es ggvis. ggvis es significativamente más ambicioso porque pretende proporcionar una gramática de gráficos interactivos. ggvis es todavía joven y carece de muchas de las características de ggplot2 (en particular, actualmente carece de facetado y no tiene forma de crear gráficos estáticos), pero en los próximos años el objetivo es hacer que ggvis sea mejor que ggplot2.\nLa sintaxis de ggvis es un poco diferente a la de ggplot2. No podrá convertir trivialmente sus gráficos de ggplot2 a ggvis, pero creemos que el costo vale la pena: la nueva sintaxis es considerablemente más consistente y será más fácil de aprender para los recién llegados. Si domina ggplot2, descubrirá que sus habilidades se transfieren muy bien a ggvis y, después de luchar con la sintaxis por un tiempo, comenzará a sentirse bastante natural. Las habilidades importantes que se aprenden al dominar ggplot2 no son los detalles programáticos de describir una gráfica en código, sino el desafío mucho más difícil de pensar en cómo convertir datos en visualizaciones efectivas.",
    "crumbs": [
      "Prefacio a la segunda edición."
    ]
  },
  {
    "objectID": "preface-2e.html#agradecimientos",
    "href": "preface-2e.html#agradecimientos",
    "title": "Prefacio a la segunda edición.",
    "section": "Agradecimientos",
    "text": "Agradecimientos\nMucha gente ha contribuido a este libro con conocimientos estructurales de alto nivel, correcciones ortográficas y gramaticales e informes de errores. Me gustaría agradecer especialmente a William E. J. Doane, Alexander Forrence, Devin Pastoor, David Robinson y Guangchuang Yu por sus detalladas revisiones técnicas del libro.\nMuchos otros han contribuido durante la (¡ahora bastante larga!) vida útil de ggplot2. Me gustaría agradecer a: Leland Wilkinson, por las discusiones y comentarios que consolidaron mi comprensión de la gramática; Gabor Grothendieck, por sus útiles comentarios iniciales; Heike Hofmann y Di Cook, por ser excelentes asesores y apoyar el desarrollo de ggplot2 durante mi doctorado; Charlotte Wickham; a los estudiantes de stat480 y stat503 en ISU, por probarlo cuando era muy pequeño; Debby Swayne, por su gran cantidad de comentarios y consejos útiles; Bob Muenchen, Reinhold Kliegl, Philipp Pagel, Richard Stahlhut, Baptiste Auguie, Jean-Olivier Irisson, Thierry Onkelinx y muchos otros que leyeron versiones preliminares del libro y me dieron su opinión; y por último, pero no menos importante, a los miembros de R-help y la lista de correo ggplot2, por proporcionar los muchos problemas gráficos interesantes y desafiantes que han ayudado a motivar este libro.\n\n\n\nHadley Wickham\nSeptember 2015",
    "crumbs": [
      "Prefacio a la segunda edición."
    ]
  },
  {
    "objectID": "start.html",
    "href": "start.html",
    "title": "Empezando",
    "section": "",
    "text": "You are reading the work-in-progress third edition of the ggplot2 book. This chapter is currently a dumping ground for ideas, and we don’t recommend reading it.\n\n\n\nPara ser coherente con las otras partes del libro, aquí debería haber algún texto inicial.",
    "crumbs": [
      "Empezando"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introducción",
    "section": "",
    "text": "1.1 Bienvenido a ggplot2\nggplot2 es un paquete R para producir gráficos estadísticos o de datos. A diferencia de la mayoría de los otros paquetes de gráficos, ggplot2 tiene una gramática subyacente, basada en la Gramática de Gráficos (Wilkinson 2005), que le permite componer gráficos combinando componentes independientes. Esto hace que ggplot2 sea poderoso. En lugar de limitarse a conjuntos de gráficos predefinidos, puede crear gráficos novedosos que se adapten a su problema específico. Si bien la idea de tener que aprender una gramática puede parecer abrumadora, ggplot2 es realmente fácil de aprender: existe un conjunto simple de principios básicos y muy pocos casos especiales. La parte difícil es que puede tomar un poco de tiempo olvidar todas las ideas preconcebidas que trae consigo al usar otras herramientas gráficas.\nggplot2 proporciona gráficas hermosas y sin complicaciones que se ocupan de detalles complicados como dibujar leyendas. De hecho, sus valores predeterminados cuidadosamente elegidos significan que puede producir gráficos con calidad de publicación en segundos. Sin embargo, si tiene requisitos de formato especiales, el completo sistema de temas de ggplot2 le facilita hacer lo que quiera. En última instancia, esto significa que, en lugar de dedicar su tiempo a hacer que su gráfico se vea bonito, puede concentrarse en crear el gráfico que mejor revele el mensaje de sus datos.\nggplot2 está diseñado para funcionar de forma iterativa. Comienzas con una capa que muestra los datos sin procesar. Luego agrega capas de anotaciones y resúmenes estadísticos. Esto le permite producir gráficos utilizando el mismo pensamiento estructurado que usaría para diseñar un análisis. Esto reduce la distancia entre la trama en tu cabeza y la de la página. Esto es especialmente útil para estudiantes que aún no han desarrollado el enfoque estructurado de análisis utilizado por los expertos.\nAprender la gramática no sólo te ayudará a crear gráficos con los que estás familiarizado, sino que también te ayudará a crear gráficos mejores y más nuevos. Sin una gramática, no hay una teoría subyacente, por lo que la mayoría de los paquetes de gráficos son sólo una gran colección de casos especiales. Por ejemplo, en base R, si diseña un gráfico nuevo, se compone de elementos gráficos sin formato, como líneas y puntos, por lo que es difícil diseñar nuevos componentes que se combinen con los gráficos existentes. En ggplot2, las expresiones utilizadas para crear un nuevo gráfico se componen de elementos de nivel superior, como representaciones de los datos sin procesar y transformaciones estadísticas, que se pueden combinar fácilmente con nuevos conjuntos de datos y otros gráficos.\nEste libro proporciona una introducción práctica a ggplot2 con muchos códigos y gráficos de ejemplo. También explica la gramática en la que se basa ggplot2. Al igual que otros sistemas formales, ggplot2 es útil incluso cuando no se comprende el modelo subyacente. Sin embargo, cuanto más aprenda al respecto, más eficazmente podrá utilizar ggplot2.\nEste libro le presentará ggplot2 suponiendo que sea un novato y no esté familiarizado con la gramática; enseñarle los conceptos básicos para que pueda recrear gráficas con las que ya está familiarizado; mostrarle cómo utilizar la gramática para crear nuevos tipos de gráficos; y, finalmente, convertirte en un experto que pueda crear nuevos componentes para ampliar la gramática.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "introduction.html#cuál-es-la-gramática-de-los-gráficos",
    "href": "introduction.html#cuál-es-la-gramática-de-los-gráficos",
    "title": "1  Introducción",
    "section": "\n1.2 ¿Cuál es la gramática de los gráficos?",
    "text": "1.2 ¿Cuál es la gramática de los gráficos?\nWilkinson (2005) creó la gramática de los gráficos para describir las características fundamentales que subyacen a todos los gráficos estadísticos. La gramática de los gráficos es una respuesta a la pregunta de ¿qué es un gráfico estadístico? ggplot2 (Wickham 2009) se basa en la gramática de Wilkinson centrándose en la primacía de las capas y adaptándola para su uso en R. En resumen, la gramática nos dice que un gráfico asigna los datos a los atributos estéticos (color, forma, tamaño). de objetos geométricos (puntos, líneas, barras). El gráfico también puede incluir transformaciones estadísticas de los datos e información sobre el sistema de coordenadas del gráfico. El facetado se puede utilizar para trazar diferentes subconjuntos de datos. La combinación de estos componentes independientes son los que forman un gráfico.\nA medida que avance el libro, la gramática formal se explicará con mayor detalle. La primera descripción de los componentes sigue a continuación. Introduce parte de la terminología que se utilizará a lo largo del libro y describe la función básica de cada componente. No se preocupe si no tiene sentido de inmediato: tendrá muchas más oportunidades de aprender sobre los componentes y cómo funcionan juntos.\nTodos los gráficos se componen de datos, la información que desea visualizar, y un mapeo, la descripción de cómo las variables de los datos se asignan a los atributos estéticos. Hay cinco componentes de mapeo:\n\nUna capa es una colección de elementos geométricos y transformaciones estadísticas. Los elementos geométricos, geoms para abreviar, representan lo que realmente se ve en el gráfico: puntos, líneas, polígonos, etc. Las transformaciones estadísticas, stats para abreviar, resumen los datos: por ejemplo, agrupar y contar observaciones para crear un histograma o ajustar un modelo lineal.\nLa escala asigna valores en el espacio de datos a valores en el espacio estético. Esto incluye el uso de color, forma o tamaño. Las escalas también dibujan la leyenda y los ejes, lo que permite leer los valores de datos originales del gráfico (un mapeo inverso).\nUna coord, o sistema de coordenadas, describe cómo se asignan las coordenadas de los datos al plano del gráfico. También proporciona ejes y líneas de cuadrícula para ayudar a leer el gráfico. Normalmente utilizamos el sistema de coordenadas cartesiano, pero hay otros disponibles, incluidas coordenadas polares y proyecciones cartográficas.\nUna faceta especifica cómo dividir y mostrar subconjuntos de datos como pequeños múltiplos. Esto también se conoce como acondicionamiento o enrejado/enrejado.\nUn tema controla los puntos más finos de la visualización, como el tamaño de fuente y el color de fondo. Si bien los valores predeterminados en ggplot2 se han elegido con cuidado, es posible que necesites consultar otras referencias para crear una trama atractiva. Un buen punto de partida son los primeros trabajos de Tufte (Tufte 1990, 1997, 2001).\n\nTambién es importante tener en cuenta lo que la gramática no hace:\n\nNo sugiere qué gráficos usar. Si bien este libro se esfuerza por promover un proceso sensato para producir gráficas, la atención se centra en cómo producir las gráficas que desea, no en qué trama producir. Para obtener más consejos sobre cómo elegir o crear argumentos para responder la pregunta que le interesa, puede consultar a Robbins (2013), Cleveland (1993), Chambers et al. (1983) y Tukey (1977).\nNo describe gráficos interactivos, sólo estáticos. Básicamente, no hay diferencia entre mostrar gráficos de ggplot2 en la pantalla de una computadora e imprimirlos en una hoja de papel.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "introduction.html#cómo-encaja-ggplot2-con-otros-gráficos-r",
    "href": "introduction.html#cómo-encaja-ggplot2-con-otros-gráficos-r",
    "title": "1  Introducción",
    "section": "\n1.3 ¿Cómo encaja ggplot2 con otros gráficos R?",
    "text": "1.3 ¿Cómo encaja ggplot2 con otros gráficos R?\nHay varios otros sistemas de gráficos disponibles en R: gráficos base, gráficos de cuadrícula y gráficos de lattice/enrejado. ¿En qué se diferencia ggplot2 de ellos?\n\nLos gráficos base fueron escritos por Ross Ihaka basándose en la experiencia en la implementación del controlador de gráficos S y en parte en Chambers et al. (1983). Los gráficos base tienen un modelo de lápiz sobre papel: solo puede dibujar sobre el gráfico, no puede modificar ni eliminar el contenido existente. No existe ninguna representación (accesible para el usuario) de los gráficos, aparte de su aparición en la pantalla. Los gráficos básicos incluyen herramientas para dibujar primitivos y gráficos completos. Las funciones gráficas básicas son generalmente rápidas, pero tienen un alcance limitado. Si ha creado un único diagrama de dispersión, un histograma o un conjunto de diagramas de caja en el pasado, probablemente haya utilizado gráficos básicos.\nEl desarrollo de gráficos de “cuadrícula”, un sistema mucho más rico de primitivas gráficas, comenzó en el año 2000. Grid fue desarrollado por Paul Murrell, como resultado de su trabajo de doctorado (Murrell 1998). Los grobs de cuadrícula (objetos gráficos) se pueden representar independientemente del gráfico y modificarse más tarde. Un sistema de ventanas gráficas (cada una con su propio sistema de coordenadas) facilita el diseño de gráficos complejos. Grid proporciona primitivas de dibujo, pero no herramientas para producir gráficos estadísticos.\nEl paquete lattice, desarrollado por Deepayan Sarkar, utiliza gráficos de cuadrícula para implementar el sistema de gráficos enrejado de Cleveland (1993) y supone una mejora considerable con respecto a los gráficos básicos. Puede producir fácilmente gráficos condicionados y algunos detalles del trazado (por ejemplo, leyendas) se cuidan automáticamente. Sin embargo, los gráficos reticulares carecen de un modelo formal, lo que puede dificultar su ampliación. Los gráficos de lattice se explican en profundidad en Sarkar (2008).\nggplot2, iniciado en 2005, es un intento de tomar las cosas buenas de los gráficos base y reticulares y mejorarlas con un modelo subyacente sólido que admita la producción de cualquier tipo de gráfico estadístico, basado en los principios descritos anteriormente. El sólido modelo subyacente de ggplot2 facilita la descripción de una amplia gama de gráficos con una sintaxis compacta, y los componentes independientes facilitan la extensión. Al igual que lattice, ggplot2 usa una cuadrícula para dibujar los gráficos, lo que significa que puedes ejercer mucho control de bajo nivel sobre la apariencia de la trama.\nhtmlwidgets, http://www.htmlwidgets.org, proporciona un marco común para acceder a herramientas de visualización web desde R. Los paquetes creados sobre htmlwidgets incluyen leaflet (https://rstudio.github.io/leaflet/, mapas), dygraph (http://rstudio.github.io/dygraphs/, series temporales) y networkD3 (http://christophergandrud.github.io/networkD3/, redes).\nplotly, https://plotly-r.com, es un popular kit de herramientas de visualización de JavaScript con una interfaz R. Es una gran herramienta si desea crear gráficos interactivos para documentos HTML, e incluso viene con una función ggplotly() que puede convertir muchos gráficos ggplot2 en sus equivalentes interactivos.\n\nMuchos otros paquetes de R, como vcd (Meyer, Zeileis, y Hornik 2006), plotrix (Lemon et al. 2008) y gplots (Warnes 2007), implementan gráficos especializados, pero ningún otro proporciona un marco para producir gráficos estadísticos. Puede encontrar una lista completa de todas las herramientas gráficas disponibles en otros paquetes en la vista de tareas de gráficos en http://cran.r-project.org/web/views/Graphics.html.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "introduction.html#sobre-este-libro",
    "href": "introduction.html#sobre-este-libro",
    "title": "1  Introducción",
    "section": "\n1.4 Sobre este libro",
    "text": "1.4 Sobre este libro\nEl primer capítulo, Capítulo 2, describe cómo comenzar rápidamente a usar ggplot2 para crear gráficos útiles. Este capítulo presenta varios conceptos importantes de ggplot2: geoms, mapeos estéticos y facetas.\nCapítulo 3 a Capítulo 9 exploran cómo utilizar la caja de herramientas básica para resolver una amplia gama de problemas de visualización que probablemente encontrará en la práctica.\nLuego, Capítulo 10 a Capítulo 12 le muestran cómo controlar las escalas más importantes, lo que le permite modificar los detalles de los ejes y las leyendas.\nEn “La gramática” describimos la gramática en capas de los gráficos que subyace a ggplot2. La teoría se ilustra en Capítulo 13, que demuestra cómo agregar capas adicionales a su trama, ejerciendo control total sobre las geoms y las estadísticas utilizadas dentro de ellas.\nComprender cómo funcionan las escalas es crucial para afinar las propiedades perceptuales de su trama. La personalización de escalas brinda un control preciso sobre la apariencia exacta de la trama y ayuda a respaldar la historia que estás contando. Capítulo 10, ?sec-scale-color y Capítulo 12 le mostrarán qué escalas están disponibles, cómo ajustar sus parámetros y cómo controlar la apariencia de los ejes y las leyendas.\nLos sistemas de coordenadas y facetados controlan la posición de los elementos de la trama. Estos se describen en Sección 13.7. El facetado es una herramienta gráfica muy poderosa, ya que le permite comparar rápidamente diferentes subconjuntos de sus datos. Con menos frecuencia se necesitan diferentes sistemas de coordenadas, pero son muy importantes para ciertos tipos de datos.\nPara pulir sus gráficos para su publicación, necesitará conocer las herramientas descritas en ?sec-polish. Allí aprenderá cómo controlar el sistema de temas de ggplot2 y cómo guardar gráficos en el disco.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "introduction.html#sec-prerequisites",
    "href": "introduction.html#sec-prerequisites",
    "title": "1  Introducción",
    "section": "\n1.5 Requisitos previos",
    "text": "1.5 Requisitos previos\nAntes de continuar, asegúrese de tener todo el software que necesita para este libro:\n\nR: Si aún no tienes R instalado, es posible que estés leyendo el libro equivocado; Asumimos una familiaridad básica con R a lo largo de este libro. Si desea aprender a utilizar R, le recomendamos R para ciencia de datos, que está diseñado para que pueda empezar a utilizar R con un mínimo de alboroto.\nRStudio: RStudio es un entorno de desarrollo integrado (IDE) gratuito y de código abierto para R. Si bien puede escribir y usar código R con cualquier entorno R (incluida la GUI de R y [ESS] (http://ess.r-project.org)) , RStudio tiene algunas características interesantes específicamente para crear y depurar su código. Recomendamos intentarlo, pero no es necesario para tener éxito con ggplot2 o con este libro. Puede descargar RStudio Desktop desde https://posit.co/download/rstudio-desktop\n\nR packages: Este libro utiliza varios paquetes R. Puedes instalarlos todos a la vez ejecutando:\n\ninstall.packages(c(\n  \"babynames\", \"bookdown\", \"bslib\", \"colorBlindness\", \"conflicted\", \n  \"desc\", \"directlabels\", \"downlit\", \"dplyr\", \"ggforce\", \"gghighlight\", \n  \"ggnewscale\", \"ggplot2\", \"ggraph\", \"ggrepel\", \"ggtext\", \"ggthemes\", \n  \"hexbin\", \"Hmisc\", \"jsonlite\", \"mapproj\", \"maps\", \"munsell\", \n  \"ozmaps\", \"paletteer\", \"patchwork\", \"rmapshaper\", \"scico\", \n  \"seriation\", \"sessioninfo\", \"sf\", \"stars\", \"tidygraph\", \"tidyr\", \n  \"wesanderson\" \n))",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "introduction.html#sec-other-resources",
    "href": "introduction.html#sec-other-resources",
    "title": "1  Introducción",
    "section": "\n1.6 Otros recursos",
    "text": "1.6 Otros recursos\nEste libro le enseña los elementos de la gramática de ggplot2 y cómo encajan entre sí, pero no documenta cada función con todo detalle. Necesitará documentación adicional a medida que su uso de ggplot2 se vuelva más complejo y variado.\nEl mejor recurso para obtener detalles específicos de las funciones de ggplot2 y sus argumentos siempre será la documentación incorporada. Se puede acceder a él en línea, https://ggplot2.tidyverse.org/reference/index.html y desde R utilizando la sintaxis de ayuda habitual. La ventaja de la documentación en línea es que puede ver todos los gráficos de ejemplo y navegar entre temas más fácilmente.\nSi utiliza ggplot2 con regularidad, es una buena idea registrarse en la lista de correo de ggplot2, http://groups.google.com/group/ggplot2. La lista tiene un tráfico relativamente bajo y es muy amigable para los nuevos usuarios. Otro recurso útil es stackoverflow, https://stackoverflow.com. Hay una comunidad ggplot2 activa en stackoverflow y ya se han formulado y respondido muchas preguntas comunes. En cualquier lugar, es mucho más probable que obtenga ayuda si crea un ejemplo mínimo reproducible. El paquete reprex de Jenny Bryan proporciona una manera conveniente de hacer esto y también incluye consejos sobre cómo crear un buen ejemplo. Cuanta más información proporciones, más fácil será para la comunidad ayudarte.\nLa cantidad de funciones en ggplot2 puede ser abrumadora, pero RStudio proporciona algunas excelentes hojas de referencia para refrescar su memoria en https://posit.co/resources/cheatsheets/.\nFinalmente, el código fuente completo del libro está disponible en línea en https://github.com/hadley/ggplot2-book. Contiene el texto completo del libro, así como todo el código y los datos necesarios para recrear todas las gráficas.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "introduction.html#colofón",
    "href": "introduction.html#colofón",
    "title": "1  Introducción",
    "section": "\n1.7 Colofón",
    "text": "1.7 Colofón\nEste libro fue escrito en RStudio usando bookdown. El sitio web está alojado en netlify y se actualiza automáticamente después de cada confirmación mediante Github Actions. La fuente completa está disponible en GitHub.\nEsta versión del libro se creó con R version 4.5.0 (2025-04-11) y los siguientes paquetes:\n\n\npackage\nversion\nsource\n\n\n\nbabynames\n1.0.1\nCRAN (R 4.5.0)\n\n\nbookdown\n0.43\nCRAN (R 4.5.0)\n\n\nbslib\n0.9.0\nCRAN (R 4.5.0)\n\n\ncolorBlindness\n0.1.9\nCRAN (R 4.5.0)\n\n\nconflicted\n1.2.0\nCRAN (R 4.5.0)\n\n\ndesc\n1.4.3\nCRAN (R 4.5.0)\n\n\ndirectlabels\n2024.1.21\nCRAN (R 4.5.0)\n\n\ndownlit\n0.4.4\nCRAN (R 4.5.0)\n\n\ndplyr\n1.1.4\nCRAN (R 4.5.0)\n\n\nggforce\n0.4.2\nCRAN (R 4.5.0)\n\n\ngghighlight\n0.4.1\nCRAN (R 4.5.0)\n\n\nggnewscale\n0.5.1\nCRAN (R 4.5.0)\n\n\nggplot2\n3.5.2\nCRAN (R 4.5.0)\n\n\nggraph\n2.2.1\nCRAN (R 4.5.0)\n\n\nggrepel\n0.9.6\nCRAN (R 4.5.0)\n\n\nggtext\n0.1.2\nCRAN (R 4.5.0)\n\n\nggthemes\n5.1.0\nCRAN (R 4.5.0)\n\n\nhexbin\n1.28.5\nCRAN (R 4.5.0)\n\n\nHmisc\n5.2-3\nCRAN (R 4.5.0)\n\n\njsonlite\n2.0.0\nCRAN (R 4.5.0)\n\n\nmapproj\n1.2.11\nCRAN (R 4.5.0)\n\n\nmaps\n3.4.2.1\nCRAN (R 4.5.0)\n\n\nmunsell\n0.5.1\nCRAN (R 4.5.0)\n\n\nozmaps\n0.4.5\nCRAN (R 4.5.0)\n\n\npaletteer\n1.6.0\nCRAN (R 4.5.0)\n\n\npatchwork\n1.3.0\nCRAN (R 4.5.0)\n\n\nrmapshaper\n0.5.0\nCRAN (R 4.5.0)\n\n\nscico\n1.5.0\nCRAN (R 4.5.0)\n\n\nseriation\n1.5.7\nCRAN (R 4.5.0)\n\n\nsessioninfo\n1.2.3\nCRAN (R 4.5.0)\n\n\nsf\n1.0-20\nCRAN (R 4.5.0)\n\n\nstars\n0.6-8\nCRAN (R 4.5.0)\n\n\ntidygraph\n1.3.1\nCRAN (R 4.5.0)\n\n\ntidyr\n1.3.1\nCRAN (R 4.5.0)\n\n\nwesanderson\n0.3.7\nCRAN (R 4.5.0)\n\n\n\n\n\n\n\nChambers, John, William Cleveland, Beat Kleiner, y Paul Tukey. 1983. Graphical methods for Data Analysis. Wadsworth.\n\n\nCleveland, William. 1993. Visualizing Data. Hobart Press.\n\n\nLemon, Jim, Ben Bolker, Sander Oom, Eduardo Klein, Barry Rowlingson, Hadley Wickham, Anupam Tyagi, et al. 2008. plotrix: Various plotting functions.\n\n\nMeyer, David, Achim Zeileis, y Kurt Hornik. 2006. «The Strucplot Framework: Visualizing Multi-Way Contingency Tables with vcd». Journal of Statistical Software 17 (3): 1-48. http://www.jstatsoft.org/v17/i03/.\n\n\nMurrell, Paul. 1998. «Investigations in Graphical Statistics». Tesis doctoral, The University of Auckland.\n\n\nRobbins, Naomi. 2013. Creating More Effective Graphs. Chart House.\n\n\nSarkar, Deepayan. 2008. Lattice: Multivariate Data Visualization with R. Springer.\n\n\nTufte, Edward R. 1990. Envisioning Information. Graphics Press.\n\n\n———. 1997. Visual Explanations. Graphics Press.\n\n\n———. 2001. The Visual Display of Quantitative Information. Second. Graphics Press.\n\n\nTukey, John W. 1977. Exploratory Data Analysis. Addison–Wesley.\n\n\nWarnes, Gregory. 2007. gplots: Various R programming tools for plotting data.\n\n\nWickham, Hadley. 2009. «A layered grammar of graphics». Journal of Computational and Graphical Statistics.\n\n\nWilkinson, Leland. 2005. The Grammar of Graphics. 2nd ed. Statistics y Computing. Springer.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "2  Primeros pasos",
    "section": "",
    "text": "2.1 Introducción\nEl objetivo de este capítulo es enseñarle cómo producir gráficos útiles con ggplot2 lo más rápido posible. Aprenderá los conceptos básicos de ggplot() junto con algunas “recetas” útiles para crear los gráficos más importantes. ggplot() te permite crear gráficos complejos con sólo unas pocas líneas de código porque se basa en una rica teoría subyacente, la gramática de los gráficos. Aquí nos saltaremos la teoría y nos centraremos en la práctica, y en capítulos posteriores aprenderá a utilizar todo el poder expresivo de la gramática.\nEn este capítulo aprenderás:",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos</span>"
    ]
  },
  {
    "objectID": "getting-started.html#introducción",
    "href": "getting-started.html#introducción",
    "title": "2  Primeros pasos",
    "section": "",
    "text": "Acerca del conjunto de datos mpg incluido con ggplot2, Sección 2.2.\nLos tres componentes clave de cada gráfica: datos, estética y geoms, Sección 2.3.\nCómo agregar variables adicionales a una gráfica con estética, Sección 2.4.\nCómo mostrar variables categóricas adicionales en un gráfico utilizando pequeños múltiplos creados mediante facetado, Sección 2.5.\nUna variedad de geoms diferentes que puedes usar para crear diferentes tipos de gráficos, Sección 2.6.\nCómo modificar los ejes, Sección 2.7.\nCosas que puedes hacer con un objeto de trazado además de mostrarlo, como guardarlo en el disco, Sección 2.8.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos</span>"
    ]
  },
  {
    "objectID": "getting-started.html#sec-fuel-economy-data",
    "href": "getting-started.html#sec-fuel-economy-data",
    "title": "2  Primeros pasos",
    "section": "\n2.2 Datos de economía de combustible",
    "text": "2.2 Datos de economía de combustible\nEn este capítulo, usaremos principalmente un conjunto de datos incluido con ggplot2: mpg. Incluye información sobre la economía de combustible de modelos de automóviles populares en 1999 y 2008, recopilada por la Agencia de Protección Ambiental de EE. UU., http://fueleconomy.gov. Puede acceder a los datos cargando ggplot2: \n\nlibrary(ggplot2)\nmpg\n#&gt; # A tibble: 234 × 11\n#&gt;   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class \n#&gt;   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; \n#&gt; 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…\n#&gt; 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…\n#&gt; 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…\n#&gt; 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…\n#&gt; 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa…\n#&gt; 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa…\n#&gt; # ℹ 228 more rows\n\nLa mayoría de las variables se explican por sí solas:\n\ncty y hwy registran millas por galón (mpg) para conducción en ciudad y carretera.\ndispl es la cilindrada del motor en litros.\ndrv es la transmisión: rueda delantera (f), rueda trasera (r) o cuatro ruedas (4).\nmodel es el modelo de coche. Son 38 modelos, seleccionados porque tuvieron una nueva edición cada año entre 1999 y 2008.\nclass es una variable categórica que describe el “tipo” de coche: biplaza, SUV, compacto, etc.\n\nEste conjunto de datos sugiere muchas preguntas interesantes. ¿Cómo se relacionan el tamaño del motor y la economía de combustible? ¿Algunos fabricantes se preocupan más por el ahorro de combustible que otros? ¿Ha mejorado la economía de combustible en los últimos diez años? Intentaremos responder algunas de estas preguntas y, en el proceso, aprenderemos cómo crear algunos gráficos básicos con ggplot2.\n\n2.2.1 Ejercicios\n\nEnumere cinco funciones que podría utilizar para obtener más información sobre el conjunto de datos mpg.\n¿Cómo puede saber qué otros conjuntos de datos se incluyen con ggplot2?\nAparte de EE. UU., la mayoría de los países utilizan el consumo de combustible (combustible consumido en una distancia fija) en lugar de la economía de combustible (distancia recorrida con una cantidad fija de combustible). ¿Cómo se podrían convertir cty y hwy al estándar europeo de l/100 km?\n¿Qué fabricante tiene más modelos en este conjunto de datos? ¿Qué modelo tiene más variaciones? ¿Cambia su respuesta si elimina la especificación redundante del tren motriz (por ejemplo, “pathfinder 4wd”, “a4 quattro”) del nombre del modelo?",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos</span>"
    ]
  },
  {
    "objectID": "getting-started.html#sec-basic-use",
    "href": "getting-started.html#sec-basic-use",
    "title": "2  Primeros pasos",
    "section": "\n2.3 Componentes clave",
    "text": "2.3 Componentes clave\nCada gráfico de ggplot2 tiene tres componentes clave:\n\ndatos,\nUn conjunto de mapeos estéticos entre variables en los datos y propiedades visuales, y\nAl menos una capa que describa cómo representar cada observación. Las capas generalmente se crean con una función geom.\n\nHe aquí un ejemplo sencillo: \n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point()\n\n\n\n\n\n\n\nEsto produce un diagrama de dispersión definido por:\n\nDatos: mpg.\nMapeo estético: tamaño del motor asignado a la posición x, economía de combustible a la posición y.\nCapa: puntos.\n\nPreste atención a la estructura de esta llamada a función: los datos y las asignaciones estéticas se proporcionan en ggplot(), luego las capas se agregan con +. Este es un patrón importante y, a medida que aprenda más sobre ggplot2, construirá gráficos cada vez más sofisticados agregando más tipos de componentes.\nCasi todos los gráficos asignan una variable a x e y, por lo que nombrar estas estéticas es tedioso, por lo que los dos primeros argumentos sin nombre de aes() se asignarán a x e y. Esto significa que el siguiente código es idéntico al ejemplo anterior:\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point()\n\nNos apegaremos a ese estilo a lo largo del libro, así que no olvide que los dos primeros argumentos de aes() son x e y. Tenga en cuenta que hemos puesto cada comando en una nueva línea. Recomendamos hacer esto en su propio código, para que sea fácil escanear una especificación de trazado y ver exactamente lo que hay allí. En este capítulo, a veces usaremos solo una línea por gráfico, porque hace que sea más fácil ver las diferencias entre las variaciones del argumento.\nEl gráfico muestra una fuerte correlación: a medida que aumenta el tamaño del motor, empeora la economía de combustible. También hay algunos valores atípicos interesantes: algunos automóviles con motores grandes obtienen una economía de combustible mayor que el promedio. ¿Qué tipo de coches crees que son?\n\n2.3.1 Ejercicios\n\n¿Cómo describirías la relación entre cty y hwy? ¿Tiene alguna inquietud acerca de sacar conclusiones de esa gráfica?\n¿Qué muestra ggplot(mpg, aes(modelo, fabricante)) + geom_point()? ¿Es útil? ¿Cómo podrías modificar los datos para hacerlos más informativos?\n\nDescribe los datos, los mapeos estéticos y las capas utilizadas para cada uno de los siguientes gráficos. Tendrás que adivinar un poco porque aún no has visto todos los conjuntos de datos y funciones, ¡pero usa tu sentido común! Vea si puede predecir cómo se verá la gráfica antes de ejecutar el código.\n\nggplot(mpg, aes(cty, hwy)) + geom_point()\nggplot(diamonds, aes(carat, price)) + geom_point()\nggplot(economics, aes(date, unemploy)) + geom_line()\nggplot(mpg, aes(cty)) + geom_histogram()",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos</span>"
    ]
  },
  {
    "objectID": "getting-started.html#sec-aesthetics",
    "href": "getting-started.html#sec-aesthetics",
    "title": "2  Primeros pasos",
    "section": "\n2.4 Color, tamaño, forma y otros atributos estéticos",
    "text": "2.4 Color, tamaño, forma y otros atributos estéticos\nPara agregar variables adicionales a una gráfica, podemos usar otras estéticas como color, forma y tamaño (NB: si bien usamos la ortografía británica en este libro, ggplot2 también acepta la ortografía estadounidense). Estos funcionan de la misma manera que la estética x e y, y se agregan a la llamada a aes(): \n\naes(displ, hwy, colour = class)\naes(displ, hwy, shape = drv)\naes(displ, hwy, size = cyl)\n\nggplot2 se encarga de los detalles de convertir datos (p. ej., ‘f’, ‘r’, ‘4’) en estética (p. ej., ‘rojo’, ‘amarillo’, ‘verde’) con una escala. Hay una escala para cada mapeo estético en una gráfica. La escala también se encarga de crear una guía, un eje o leyenda, que permite leer el trazado, convirtiendo nuevamente los valores estéticos en valores de datos. Por ahora, nos quedaremos con las escalas predeterminadas proporcionadas por ggplot2. Aprenderá cómo anularlos en ?sec-scale-color.\nPara aprender más sobre esas variables atípicas en el diagrama de dispersión anterior, podríamos asignar la variable de clase al color:\n\nggplot(mpg, aes(displ, hwy, colour = class)) + \n  geom_point()\n\n\n\n\n\n\n\nEsto le da a cada punto un color único correspondiente a su clase. La leyenda nos permite leer los valores de los datos del color, mostrándonos que el grupo de coches con un consumo de combustible inusualmente alto para su tamaño de motor son los biplaza: coches con motores grandes, pero carrocerías ligeras.\nSi desea establecer una estética en un valor fijo, sin escalarla, hágalo en la capa individual fuera de aes(). Compare los dos gráficos siguientes: \nggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = \"blue\"))\nggplot(mpg, aes(displ, hwy)) + geom_point(colour = \"blue\")\n\n\n\n\n\n\n\n\n\n\nEn el primer gráfico, el valor “azul” se escala a un color rosado y se agrega una leyenda. En el segundo gráfico, a los puntos se les da el color R azul. Esta es una técnica importante y aprenderá más sobre ella en Sección 13.4.2. Consulte vignette(\"ggplot2-specs\") para conocer los valores necesarios para el color y otras estéticas.\nDiferentes tipos de atributos estéticos funcionan mejor con diferentes tipos de variables. Por ejemplo, el color y la forma funcionan bien con variables categóricas, mientras que el tamaño funciona bien con variables continuas. La cantidad de datos también marca la diferencia: si hay muchos datos, puede resultar difícil distinguir diferentes grupos. Una solución alternativa es utilizar facetado, como se describe a continuación.\nCuando se utiliza la estética en una gráfica, menos suele ser más. Es difícil ver las relaciones simultáneas entre el color, la forma y el tamaño, por lo que hay que ser moderado al utilizar la estética. En lugar de intentar crear una gráfica muy compleja que muestre todo a la vez, intenta crear una serie de gráficas simples que cuenten una historia y lleven al lector de la ignorancia al conocimiento.\n\n2.4.1 Ejercicios\n\nExperimente con la estética del color, la forma y el tamaño. ¿Qué sucede cuando los asignas a valores continuos? ¿Qué pasa con los valores categóricos? ¿Qué sucede cuando usas más de una estética en una gráfica?\n¿Qué sucede si asignas una variable continua a una forma? ¿Por qué? ¿Qué sucede si asignas trans a la forma? ¿Por qué?\n¿Cómo se relaciona el tren motriz con la economía de combustible? ¿Cómo se relaciona el tren motriz con el tamaño y la clase del motor?",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos</span>"
    ]
  },
  {
    "objectID": "getting-started.html#sec-qplot-faceting",
    "href": "getting-started.html#sec-qplot-faceting",
    "title": "2  Primeros pasos",
    "section": "\n2.5 Facetado",
    "text": "2.5 Facetado\nOtra técnica para mostrar variables categóricas adicionales en un gráfico es el facetado. Facetado crea tablas de gráficos dividiendo los datos en subconjuntos y mostrando el mismo gráfico para cada subconjunto. Aprenderá más sobre facetado en Capítulo 16, pero es una técnica tan útil que necesita conocerla de inmediato. \nHay dos tipos de facetado: rejilla y envuelto. Envuelto es el más útil, por lo que lo discutiremos aquí y podrá aprender sobre el facetado de cuadrícula más adelante. Para facetar un gráfico simplemente agrega una especificación de facetado con facet_wrap(), que toma el nombre de una variable precedida por ~. \n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  facet_wrap(~class)\n\n\n\n\n\n\n\nQuizás se pregunte cuándo utilizar facetado y cuándo utilizar estética. Aprenderá más sobre las ventajas y desventajas relativas de cada uno en Sección 16.5.\n\n2.5.1 Ejercicios\n\n¿Qué sucede si intentas facetar con una variable continua como hwy? ¿Qué pasa con cyl? ¿Cuál es la diferencia clave?\nUtilice facetado para explorar la relación triple entre economía de combustible, tamaño del motor y cantidad de cilindros. ¿Cómo cambia el facetado por número de cilindros su evaluación de la relación entre el tamaño del motor y la economía de combustible?\nLea la documentación de facet_wrap(). ¿Qué argumentos puedes usar para controlar cuántas filas y columnas aparecen en el resultado?\n¿Qué hace el argumento scales de facet_wrap()? ¿Cuándo podrías usarlo?",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos</span>"
    ]
  },
  {
    "objectID": "getting-started.html#sec-plot-geoms",
    "href": "getting-started.html#sec-plot-geoms",
    "title": "2  Primeros pasos",
    "section": "\n2.6 Trazar geomas",
    "text": "2.6 Trazar geomas\nPodrías adivinar que al sustituir geom_point() por una función geom diferente, obtendrías un tipo diferente de gráfico. ¡Es una gran suposición! En las siguientes secciones, aprenderá sobre algunas de las otras geoms importantes proporcionadas en ggplot2. Esta no es una lista exhaustiva, pero debería cubrir los tipos de gráfica más utilizados. Aprenderá más en Capítulo 3 y Capítulo 4.\n\ngeom_smooth() ajusta un suavizador a los datos y muestra el suavizado y su error estándar.\ngeom_boxplot() produce un diagrama de caja y bigotes para resumir la distribución de un conjunto de puntos.\ngeom_histogram() y geom_freqpoly() mostrar la distribución de variables continuas.\ngeom_bar() muestra la distribución de variables categóricas.\ngeom_path() y geom_line() dibujan líneas entre los puntos de datos. Un gráfico de líneas está obligado a producir líneas que viajan de izquierda a derecha, mientras que los caminos pueden ir en cualquier dirección. Las líneas se suelen utilizar para explorar cómo cambian las cosas con el tiempo.\n\n\n2.6.1 Agregar un suavizado a una gráfica\nSi tiene un diagrama de dispersión con mucho ruido, puede resultar difícil ver el patrón dominante. En este caso es útil agregar una línea suavizada al gráfico con geom_smooth(): \n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  geom_smooth()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\nEsto superpone el diagrama de dispersión con una curva suave, que incluye una evaluación de la incertidumbre en forma de intervalos de confianza puntuales que se muestran en gris. Si no está interesado en el intervalo de confianza, desactívelo con geom_smooth(se = FALSE).\nUn argumento importante para geom_smooth() es el método, que le permite elegir qué tipo de modelo se utiliza para ajustarse a la curva suave:\n\n\nmethod = \"loess\", el valor predeterminado para n pequeña, utiliza una regresión local suave (como se describe en ?loess). El movimiento de la línea está controlado por el parámetro span, que varía de 0 (extremadamente ondulado) a 1 (no tan ondulado).\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  geom_smooth(span = 0.2)\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  geom_smooth(span = 1)\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\nLoess no funciona bien para conjuntos de datos grandes (es \\(O(n^2)\\) en la memoria), por lo que se utiliza un algoritmo de suavizado alternativo cuando \\(n\\) es mayor que 1000.\n\n\nmethod = \"gam\" Se ajusta a un modelo aditivo generalizado proporcionado por el paquete mgcv. Primero debe cargar mgcv, luego usar una fórmula como fórmula = y ~ s(x) o y ~ s(x, bs = \"cs\") (para datos grandes). Esto es lo que usa ggplot2 cuando hay más de 1000 puntos. \n\nlibrary(mgcv)\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  geom_smooth(method = \"gam\", formula = y ~ s(x))\n\n\n\n\n\n\n\n\n\nmethod = \"lm\" Se ajusta a un modelo lineal, dando la línea de mejor ajuste.\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  geom_smooth(method = \"lm\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nmethod = \"rlm\" funciona como lm(), pero utiliza un algoritmo de ajuste robusto para que los valores atípicos no afecten tanto el ajuste. Es parte del paquete MASS, así que recuerda cargarlo primero. \n\n2.6.2 Diagramas de caja y puntos nerviosos\nCuando un conjunto de datos incluye una variable categórica y una o más variables continuas, probablemente le interesará saber cómo varían los valores de las variables continuas con los niveles de la variable categórica. Digamos que estamos interesados en ver cómo varía la economía de combustible dentro de los automóviles que tienen el mismo tipo de transmisión. Podríamos comenzar con un diagrama de dispersión como este:\n\nggplot(mpg, aes(drv, hwy)) + \n  geom_point()\n\n\n\n\n\n\n\nDebido a que hay pocos valores únicos tanto para drv como para hwy, hay mucho trazado excesivo. Muchos puntos están trazados en la misma ubicación y es difícil ver la distribución. Hay tres técnicas útiles que ayudan a aliviar el problema:\n\nEl jittering, geom_jitter(), añade un poco de ruido aleatorio a los datos, lo que puede ayudar a evitar el trazado excesivo. \nLos diagramas de caja, geom_boxplot(), resumen la forma de la distribución con un puñado de estadísticas resumidas. \nLos gráficos de violín, geom_violin(), muestran una representación compacta de la “densidad” de la distribución, resaltando las áreas donde se encuentran más puntos. \n\nEstos se ilustran a continuación:\nggplot(mpg, aes(drv, hwy)) + geom_jitter()\nggplot(mpg, aes(drv, hwy)) + geom_boxplot()\nggplot(mpg, aes(drv, hwy)) + geom_violin()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCada método tiene sus fortalezas y debilidades. Los diagramas de caja resumen la mayor parte de la distribución con solo cinco números, mientras que los diagramas con fluctuaciones muestran cada punto pero solo funcionan con conjuntos de datos relativamente pequeños. Los gráficos de violín ofrecen la visualización más rica, pero se basan en el cálculo de una estimación de densidad, que puede ser difícil de interpretar.\nPara puntos nerviosos, geom_jitter() ofrece el mismo control sobre la estética que geom_point(): size, colour y shape. Para geom_boxplot() y geom_violin(), puedes controlar el color del contorno colour o el color interno del fill.\n\n2.6.3 Histogramas y polígonos de frecuencia.\nLos histogramas y los polígonos de frecuencia muestran la distribución de una única variable numérica. Proporcionan más información sobre la distribución de un solo grupo que los diagramas de caja, a costa de necesitar más espacio. \nggplot(mpg, aes(hwy)) + geom_histogram()\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nggplot(mpg, aes(hwy)) + geom_freqpoly()\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\nTanto los histogramas como los polígonos de frecuencia funcionan de la misma manera: agrupan los datos y luego cuentan el número de observaciones en cada contenedor. La única diferencia es la visualización: los histogramas usan barras y los polígonos de frecuencia usan líneas.\nPuede controlar el ancho de los contenedores con el argumento binwidth (si no desea contenedores espaciados uniformemente, puede usar el argumento breaks). Es muy importante experimentar con el ancho del contenedor. El valor predeterminado simplemente divide sus datos en 30 contenedores, lo que probablemente no sea la mejor opción. Siempre debe probar con muchos anchos de bin y es posible que necesite varios anchos de bin para contar la historia completa de sus datos.\nggplot(mpg, aes(hwy)) + \n  geom_freqpoly(binwidth = 2.5)\nggplot(mpg, aes(hwy)) + \n  geom_freqpoly(binwidth = 1)\n\n\n\n\n\n\n\n\n\n\nUna alternativa al polígono de frecuencia es el gráfico de densidad, geom_density(). Se requiere un poco de cuidado si se utilizan gráficos de densidad: en comparación con los polígonos de frecuencia, son más difíciles de interpretar ya que los cálculos subyacentes son más complejos. También hacen suposiciones que no son ciertas para todos los datos, a saber, que la distribución subyacente es continua, ilimitada y suave.\nPara comparar las distribuciones de diferentes subgrupos, puede asignar una variable categórica a relleno (para geom_histogram()) o color (para geom_freqpoly()). Es más fácil comparar distribuciones usando el polígono de frecuencia porque la tarea de percepción subyacente es más sencilla. También puedes usar facetas: esto dificulta un poco las comparaciones, pero es más fácil ver la distribución de cada grupo.\nggplot(mpg, aes(displ, colour = drv)) + \n  geom_freqpoly(binwidth = 0.5)\nggplot(mpg, aes(displ, fill = drv)) + \n  geom_histogram(binwidth = 0.5) + \n  facet_wrap(~drv, ncol = 1)\n\n\n\n\n\n\n\n\n\n\n\n2.6.4 Gráfica de barras\nEl análogo discreto del histograma es el gráfico de barras, geom_bar(). Es fácil de usar: \n\nggplot(mpg, aes(manufacturer)) + \n  geom_bar()\n\n\n\n\n\n\n\n(Aprenderás cómo arreglar las etiquetas en Sección 17.4.2).\nLos gráficos de barras pueden resultar confusos porque hay dos gráficos bastante diferentes que comúnmente se denominan gráficos de barras. El formulario anterior espera que tenga datos no resumidos y cada observación contribuye con una unidad a la altura de cada barra. La otra forma de gráfico de barras se utiliza para datos presumidos. Por ejemplo, es posible que tenga tres medicamentos con su efecto promedio:\n\ndrugs &lt;- data.frame(\n  drug = c(\"a\", \"b\", \"c\"),\n  effect = c(4.2, 9.7, 6.1)\n)\n\nPara mostrar este tipo de datos, debe decirle a geom_bar() que no ejecute la estadística predeterminada que agrupa y cuenta los datos. Sin embargo, creemos que es incluso mejor usar geom_point() porque los puntos ocupan menos espacio que las barras y no requieren que el eje y incluya 0.\nggplot(drugs, aes(drug, effect)) + geom_bar(stat = \"identity\")\nggplot(drugs, aes(drug, effect)) + geom_point()\n\n\n\n\n\n\n\n\n\n\n\n2.6.5 Series de tiempo con gráficos de líneas y rutas\nLos gráficos de líneas y rutas se utilizan normalmente para datos de series temporales. Los diagramas de líneas unen los puntos de izquierda a derecha, mientras que los diagramas de ruta los unen en el orden en que aparecen en el conjunto de datos (en otras palabras, un diagrama de líneas es un diagrama de ruta de los datos ordenados por valor de x). Los gráficos de líneas generalmente tienen el tiempo en el eje x, lo que muestra cómo una sola variable ha cambiado con el tiempo. Los gráficos de ruta muestran cómo dos variables han cambiado simultáneamente a lo largo del tiempo, con el tiempo codificado en la forma en que se conectan las observaciones.\nDebido a que la variable año en el conjunto de datos mpg solo tiene dos valores, mostraremos algunos gráficos de series temporales utilizando el conjunto de datos economics, que contiene datos económicos sobre los EE. UU. medidos durante los últimos 40 años. La siguiente figura muestra dos gráficos de desempleo a lo largo del tiempo, ambos producidos usando geom_line(). El primero muestra la tasa de desempleo mientras que el segundo muestra la mediana del número de semanas desempleadas. Ya podemos ver algunas diferencias en estas dos variables, particularmente en el último pico, donde el porcentaje de desempleo es menor que en los picos anteriores, pero la duración del desempleo es alta. \nggplot(economics, aes(date, unemploy / pop)) +\n  geom_line()\nggplot(economics, aes(date, uempmed)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\n\nPara examinar esta relación con mayor detalle, nos gustaría dibujar ambas series de tiempo en la misma gráfica. Podríamos dibujar un diagrama de dispersión de la tasa de desempleo versus la duración del desempleo, pero entonces ya no podríamos ver la evolución en el tiempo. La solución es unir puntos adyacentes en el tiempo con segmentos de línea, formando un trazado de ruta.\nA continuación graficamos la tasa de desempleo versus la duración del desempleo y unimos las observaciones individuales con una trayectoria. Debido a los muchos cruces de líneas, la dirección en la que fluye el tiempo no es fácil de ver en la primera gráfica. En el segundo gráfico, coloreamos los puntos para que sea más fácil ver la dirección del tiempo.\nggplot(economics, aes(unemploy / pop, uempmed)) + \n  geom_path() +\n  geom_point()\n\nyear &lt;- function(x) as.POSIXlt(x)$year + 1900\nggplot(economics, aes(unemploy / pop, uempmed)) + \n  geom_path(colour = \"grey50\") +\n  geom_point(aes(colour = year(date)))\n\n\n\n\n\n\n\n\n\n\nPodemos ver que la tasa de desempleo y la duración del desempleo están altamente correlacionadas, pero en los últimos años la duración del desempleo ha aumentado en relación con la tasa de desempleo.\nCon datos longitudinales, a menudo desea mostrar varias series temporales en cada gráfico, donde cada serie representa a un individuo. Para hacer esto, necesita asignar la estética del group a una variable que codifique la membresía del grupo de cada observación. Esto se explica con más profundidad en Capítulo 4. \n\n2.6.6 Ejercicios\n\n¿Cuál es el problema con la gráfica creada por ggplot(mpg, aes(cty, hwy)) + geom_point()? ¿Cuál de las geoms descritas anteriormente es más eficaz para solucionar el problema?\n\nUn desafío con ggplot(mpg, aes(class, hwy)) + geom_boxplot() es que el orden de class es alfabético, lo cual no es muy útil. ¿Cómo podrías cambiar los niveles de los factores para que sean más informativos?\nEn lugar de reordenar el factor manualmente, puede hacerlo automáticamente según los datos: ggplot(mpg, aes(reorder(class, hwy), hwy)) + geom_boxplot(). ¿Qué hace reordenar()? Lea la documentación.\n\nExplore la distribución de la variable quilates en el conjunto de datos diamonds . ¿Qué ancho de contenedor revela los patrones más interesantes?\nExplore la distribución de la variable precio en los datos de diamonds . ¿Cómo varía la distribución según el corte?\nAhora conoces (al menos) tres formas de comparar las distribuciones de subgrupos: geom_violin(), geom_freqpoly() y la estética del color, o geom_histogram() y facetado. ¿Cuáles son las fortalezas y debilidades de cada enfoque? ¿Qué otros enfoques podrías probar?\nLea la documentación de geom_bar(). ¿Qué hace la estética del weight ?\nUtilizando las técnicas ya analizadas en este capítulo, piense en tres formas de visualizar una distribución categórica 2D. Pruébelos visualizando la distribución de model y manufacturer, trans y class, y cyl y trans.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos</span>"
    ]
  },
  {
    "objectID": "getting-started.html#sec-axes",
    "href": "getting-started.html#sec-axes",
    "title": "2  Primeros pasos",
    "section": "\n2.7 Modificando los ejes",
    "text": "2.7 Modificando los ejes\nAprenderá toda la gama de opciones disponibles en capítulos posteriores, pero dos familias de útiles ayudas le permitirán realizar las modificaciones más comunes. xlab() y ylab() modifican las etiquetas de los ejes x e y: \nggplot(mpg, aes(cty, hwy)) +\n  geom_point(alpha = 1 / 3)\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point(alpha = 1 / 3) + \n  xlab(\"city driving (mpg)\") + \n  ylab(\"highway driving (mpg)\")\n\n# Remove the axis labels with NULL\nggplot(mpg, aes(cty, hwy)) +\n  geom_point(alpha = 1 / 3) + \n  xlab(NULL) + \n  ylab(NULL)\n\n\n\n\n\n\n\n\n\n\n\n\n\nxlim() y ylim() modificar los límites de los ejes: \nggplot(mpg, aes(drv, hwy)) +\n  geom_jitter(width = 0.25)\n\nggplot(mpg, aes(drv, hwy)) +\n  geom_jitter(width = 0.25) + \n  xlim(\"f\", \"r\") + \n  ylim(20, 30)\n#&gt; Warning: Removed 138 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n  \n# For continuous scales, use NA to set only one limit\nggplot(mpg, aes(drv, hwy)) +\n  geom_jitter(width = 0.25, na.rm = TRUE) + \n  ylim(NA, 30)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCambiar los límites de los ejes establece los valores fuera del rango en NA. Puede suprimir la advertencia asociada con na.rm = TRUE, pero tenga cuidado. Si su gráfico calcula estadísticas resumidas (por ejemplo, media muestral), esta conversión a NA ocurre antes de que se calculen las estadísticas resumidas y puede generar resultados no deseados en algunas situaciones.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos</span>"
    ]
  },
  {
    "objectID": "getting-started.html#sec-output",
    "href": "getting-started.html#sec-output",
    "title": "2  Primeros pasos",
    "section": "\n2.8 Salida",
    "text": "2.8 Salida\nLa mayoría de las veces crea un objeto de trazado y lo traza inmediatamente, pero también puede guardar un trazado en una variable y manipularlo:\n\np &lt;- ggplot(mpg, aes(displ, hwy, colour = factor(cyl))) +\n  geom_point()\n\nUna vez que tengas un objeto de gráfica, hay algunas cosas que puedes hacer con él:\n\n\nRenderizarlo en pantalla con print(). Esto sucede automáticamente cuando se ejecuta de forma interactiva, pero dentro de un bucle o función, necesitarás imprimirlo tú mismo. \n::: {.cell}\nprint(p)\n::: {.cell-output-display}  ::: :::\n\n\nGuárdelo en el disco con ggsave(), descrito en Sección 17.5.\n\n# Save png to disk\nggsave(\"plot.png\", p, width = 5, height = 5)\n\n\n\nDescribe brevemente su estructura con summary(). \n\nsummary(p)\n#&gt; data: manufacturer, model, displ, year, cyl, trans, drv, cty, hwy, fl,\n#&gt;   class [234x11]\n#&gt; mapping:  x = ~displ, y = ~hwy, colour = ~factor(cyl)\n#&gt; faceting: &lt;ggproto object: Class FacetNull, Facet, gg&gt;\n#&gt;     compute_layout: function\n#&gt;     draw_back: function\n#&gt;     draw_front: function\n#&gt;     draw_labels: function\n#&gt;     draw_panels: function\n#&gt;     finish_data: function\n#&gt;     init_scales: function\n#&gt;     map_data: function\n#&gt;     params: list\n#&gt;     setup_data: function\n#&gt;     setup_params: function\n#&gt;     shrink: TRUE\n#&gt;     train_scales: function\n#&gt;     vars: function\n#&gt;     super:  &lt;ggproto object: Class FacetNull, Facet, gg&gt;\n#&gt; -----------------------------------\n#&gt; geom_point: na.rm = FALSE\n#&gt; stat_identity: na.rm = FALSE\n#&gt; position_identity\n\n\n\nAprenderá más sobre cómo manipular estos objetos en Capítulo 18.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeros pasos</span>"
    ]
  },
  {
    "objectID": "toolbox.html",
    "href": "toolbox.html",
    "title": "Layers",
    "section": "",
    "text": "You are reading the work-in-progress third edition of the ggplot2 book. This chapter is currently a dumping ground for ideas, and we don’t recommend reading it.\n\n\n\nThe layered structure of ggplot2 encourages you to design and construct graphics in a structured manner., You’ve learned the basics in the previous chapter, and in this chapter you’ll get a more comprehensive task-based introduction. The goal here is not to exhaustively explore every option of every geom, but instead to show the most important tools for a given task. For more information about individual geoms, along with many more examples illustrating their use, see the documentation.\nIt is useful to think about the purpose of each layer before it is added. In general, there are three purposes for a layer: \n\nTo display the data. We plot the raw data for many reasons, relying on our skills at pattern detection to spot gross structure, local structure, and outliers. This layer appears on virtually every graphic. In the earliest stages of data exploration, it is often the only layer.\nTo display a statistical summary of the data. As we develop and explore models of the data, it is useful to display model predictions in the context of the data. Showing the data helps us improve the model, and showing the model helps reveal subtleties of the data that we might otherwise miss. Summaries are usually drawn on top of the data.\n\nTo add additional metadata: context, annotations, and references. A metadata layer displays background context, annotations that help to give meaning to the raw data, or fixed references that aid comparisons across panels. Metadata can be useful in the background and foreground.\nA map is often used as a background layer with spatial data. Background metadata should be rendered so that it doesn’t interfere with your perception of the data, so is usually displayed underneath the data and formatted so that it is minimally perceptible. That is, if you concentrate on it, you can see it with ease, but it doesn’t jump out at you when you are casually browsing the plot.\nOther metadata is used to highlight important features of the data. If you have added explanatory labels to a couple of inflection points or outliers, then you want to render them so that they pop out at the viewer. In that case, you want this to be the very last layer drawn.\n\n\nThis chapter is broken up into the following sections, each of which deals with a particular graphical challenge. This is not an exhaustive or exclusive categorisation, and there are many other possible ways to break up graphics into different categories. Each geom can be used for many different purposes, especially if you are creative. However, this breakdown should cover many common tasks and help you learn about some of the possibilities.\n\nBasic plot types that produce common, ‘named’ graphics like scatterplots and line charts, Tipos de gráficos básicos.\nDisplaying text, Etiquetas de texto.\nAdding arbitrary additional anotations, 8  Anotaciones.\nSurface plots to display 3d surfaces in 2d, Superficies.\nDrawing maps, 6  Mapas.\nRevealing uncertainty and error, with various 1d and 2d intervals, Revelando incertidumbre.\nWeighted data, Datos ponderados.\nIn Datos de diamantes, you’ll learn about the diamonds dataset.\n\nThe final three sections use this data to discuss techniques for visualising larger datasets:\n\nDisplaying distributions, continuous and discrete, 1d and 2d, joint and conditional, Mostrando distribuciones.\n\nDealing with overplotting in scatterplots, a challenge with large datasets,\n\n\n\n\nDisplaying statistical summaries instead of the raw data, Resúmenes estadísticos.",
    "crumbs": [
      "Layers"
    ]
  },
  {
    "objectID": "individual-geoms.html",
    "href": "individual-geoms.html",
    "title": "3  Geomas individuales",
    "section": "",
    "text": "3.1 Tipos de gráficos básicos\nEstas geoms son los componentes fundamentales de ggplot2. Son útiles por sí solos, pero también se utilizan para construir geomas más complejas. La mayoría de estas geoms están asociadas con una gráfica con nombre: cuando esa geom se usa sola en una gráfica, esa gráfica tiene un nombre especial.\nCada una de estas geomas es bidimensional y requiere estética tanto x como y. Todos ellos entienden la estética de color (o color) y size, y las geomas rellenas (barra, mosaico y polígono) también entienden de fill.\nCada geom se muestra en el siguiente código. Observe los diferentes rangos de ejes para los gráficos de barras, áreas y mosaicos: estas geomas ocupan espacio fuera del rango de los datos y, por lo tanto, empujan los ejes hacia afuera.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geomas individuales</span>"
    ]
  },
  {
    "objectID": "individual-geoms.html#sec-basics",
    "href": "individual-geoms.html#sec-basics",
    "title": "3  Geomas individuales",
    "section": "",
    "text": "geom_area() dibuja un gráfico de área, que es un gráfico de líneas relleno hasta el eje y (líneas rellenas). Se apilarán varios grupos uno encima del otro. \ngeom_bar(stat = \"identity\") hace un gráfico de barras. Nosotros necesitamos stat = \"identity\" porque la estadística predeterminada cuenta automáticamente los valores (por lo que es esencialmente una geom 1d, consulte Sección 5.4). La estadística de identidad deja los datos sin cambios. Se apilarán varias barras en la misma ubicación una encima de la otra. \ngeom_line() hace un gráfico lineal. La estética del “grupo” determina qué observaciones están conectadas; consulte Capítulo 4 para obtener más detalles. geom_line() conecta puntos de izquierda a derecha; geom_path() es similar pero conecta puntos en el orden en que aparecen en los datos. Tanto geom_line() como geom_path() también entienden el estético linetype, que asigna una variable categórica a líneas sólidas, punteadas y discontinuas. \ngeom_point() produce un diagrama de dispersión. geom_point() También entiende la estética de la shape, forma. \ngeom_polygon() dibuja polígonos, que son caminos rellenos. Cada vértice del polígono requiere una fila separada en los datos. A menudo resulta útil fusionar un marco de datos de coordenadas poligonales con los datos justo antes de trazar. Capítulo 6 ilustra este concepto con más detalle para datos de mapas. \ngeom_rect(), geom_tile() y geom_raster() dibujan rectángulos. geom_rect() está parametrizado por las cuatro esquinas del rectángulo, xmin, ymin, xmax y ymax. geom_tile() es exactamente igual, pero parametrizado por el centro del rectángulo y su tamaño, x, y, width y height. geom_raster() es un caso especial rápido de geom_tile() se utiliza cuando todos los mosaicos son del mismo tamaño.. . \ngeom_text() agrega texto a una gráfica. Requiere una estética de label que proporcione el texto que se mostrará y que tenga varios parámetros. (angle, family, fontface, hjust y vjust) que controlan la apariencia del texto.\n\n\ndf &lt;- data.frame(\n  x = c(3, 1, 5), \n  y = c(2, 4, 6), \n  label = c(\"a\",\"b\",\"c\")\n)\np &lt;- ggplot(df, aes(x, y, label = label)) + \n  labs(x = NULL, y = NULL) + # Hide axis label\n  theme(plot.title = element_text(size = 12)) # Shrink plot title\np + geom_point() + ggtitle(\"point\")\np + geom_text() + ggtitle(\"text\")\np + geom_bar(stat = \"identity\") + ggtitle(\"bar\")\np + geom_tile() + ggtitle(\"raster\")\n\np + geom_line() + ggtitle(\"line\")\np + geom_area() + ggtitle(\"area\")\np + geom_path() + ggtitle(\"path\")\np + geom_polygon() + ggtitle(\"polygon\")\n\n\n3.1.1 Exercises\n\n\n¿Qué geomas usarías para dibujar cada una de las siguientes gráficas nombradas?\n\nGráfico de dispersión\nGráfico de líneas\nHistograma\nGráfico de barras\nGráfico circular\n\n\n¿Cuál es la diferencia entre geom_path() y geom_polygon()? ¿Cuál es la diferencia entre geom_path() y geom_line()?\n¿Qué geoms de bajo nivel se utilizan para dibujar geom_smooth()? ¿Qué pasa con geom_boxplot() y geom_violin()?",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geomas individuales</span>"
    ]
  },
  {
    "objectID": "collective-geoms.html",
    "href": "collective-geoms.html",
    "title": "4  Geomas colectivas",
    "section": "",
    "text": "4.1 Múltiples grupos, una estética\nLas geoms se pueden dividir a grandes rasgos en geoms individuales y colectivas. Una geom individual dibuja un objeto gráfico distinto para cada observación (fila). Por ejemplo, el punto geom dibuja un punto por fila. Una geom colectiva muestra múltiples observaciones con un objeto geométrico. Esto puede ser el resultado de un resumen estadístico, como un diagrama de caja, o puede ser fundamental para la visualización de la geom, como un polígono. Las líneas y los caminos se encuentran en algún punto intermedio: cada línea se compone de un conjunto de segmentos rectos, pero cada segmento representa dos puntos. ¿Cómo controlamos la asignación de observaciones a elementos gráficos? Éste es el trabajo de la estética group.\nDe forma predeterminada, la estética del group se asigna a la interacción de todas las variables discretas en la gráfica. Esto a menudo divide los datos correctamente, pero cuando no lo hace, o cuando no se utiliza ninguna variable discreta en un gráfico, deberá definir explícitamente la estructura de agrupación asignando grupo a una variable que tenga un valor diferente para cada grupo.\nHay tres casos comunes en los que el valor predeterminado no es suficiente y los consideraremos a continuación. En los siguientes ejemplos, utilizaremos un conjunto de datos longitudinal simple, Oxboys, del paquete nlme. Registra las alturas (height) y edades centradas (age) de 26 niños (Subject), medidas en nueve ocasiones (Occasion). Subject y Occasion` se almacenan como factores ordenados.\nEn muchas situaciones, querrás separar tus datos en grupos, pero renderizarlos de la misma manera. En otras palabras, se desea poder distinguir sujetos individuales, pero no identificarlos. Esto es común en estudios longitudinales con muchos sujetos, donde las gráficas a menudo se denominan descriptivamente gráficas de espagueti. Por ejemplo, el siguiente gráfico muestra la trayectoria de crecimiento de cada niño (cada Subject):\nggplot(Oxboys, aes(age, height, group = Subject)) + \n  geom_point() + \n  geom_line()\nSi especifica incorrectamente la variable de agrupación, obtendrá una apariencia característica de diente de sierra:\nggplot(Oxboys, aes(age, height)) + \n  geom_point() + \n  geom_line()\nSi un grupo no está definido por una sola variable, sino por una combinación de múltiples variables, use interaction() para combinarlas, p.e. aes(group = interaction(school_id, student_id)).",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Geomas colectivas</span>"
    ]
  },
  {
    "objectID": "collective-geoms.html#diferentes-grupos-en-diferentes-capas.",
    "href": "collective-geoms.html#diferentes-grupos-en-diferentes-capas.",
    "title": "4  Geomas colectivas",
    "section": "\n4.2 Diferentes grupos en diferentes capas.",
    "text": "4.2 Diferentes grupos en diferentes capas.\nA veces queremos trazar resúmenes que utilicen diferentes niveles de agregación: una capa puede mostrar individuos, mientras que otra muestra un resumen general. Basándonos en el ejemplo anterior, supongamos que queremos agregar una única línea suave que muestre la tendencia general para todos los niños. Si utilizamos la misma agrupación en ambas capas, obtenemos un liso por niño: \n\nggplot(Oxboys, aes(age, height, group = Subject)) + \n  geom_line() + \n  geom_smooth(method = \"lm\", se = FALSE)\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nEsto no es lo que queríamos; Sin darnos cuenta, hemos agregado una línea suavizada para cada niño. La agrupación controla tanto la visualización de las geoms como el funcionamiento de las estadísticas: se ejecuta una transformación estadística para cada grupo.\nEn lugar de configurar la estética de agrupación en ggplot(), donde se aplicará a todas las capas, la configuramos en geom_line() para que se aplique solo a las líneas. No hay variables discretas en el gráfico, por lo que la variable de agrupación predeterminada será una constante y obtenemos una suave:\n\nggplot(Oxboys, aes(age, height)) + \n  geom_line(aes(group = Subject)) + \n  geom_smooth(method = \"lm\", linewidth = 2, se = FALSE)\n#&gt; `geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Geomas colectivas</span>"
    ]
  },
  {
    "objectID": "collective-geoms.html#anulación-de-la-agrupación-predeterminada",
    "href": "collective-geoms.html#anulación-de-la-agrupación-predeterminada",
    "title": "4  Geomas colectivas",
    "section": "\n4.3 Anulación de la agrupación predeterminada",
    "text": "4.3 Anulación de la agrupación predeterminada\nAlgunos gráficos tienen una escala x discreta, pero aún desea dibujar líneas que conecten entre grupos. Esta es la estrategia utilizada en gráficos de interacción, gráficos de perfil y gráficos de coordenadas paralelas, entre otros. Por ejemplo, imagina que hemos dibujado diagramas de caja de la altura en cada ocasión de medición: \n\nggplot(Oxboys, aes(Occasion, height)) + \n  geom_boxplot()\n\n\n\n\n\n\n\nHay una variable discreta en este gráfico, Occasion, por lo que obtenemos un diagrama de caja para cada valor x único. Ahora queremos superponer líneas que conecten a cada niño individualmente. Simplemente agregar geom_line() no funciona: las líneas se dibujan dentro de cada ocasión, no en cada tema:\n\nggplot(Oxboys, aes(Occasion, height)) + \n  geom_boxplot() +\n  geom_line(colour = \"#3366FF\", alpha = 0.5)\n\n\n\n\n\n\n\nPara obtener la gráfica que queremos, debemos anular la agrupación para decir que queremos una línea por niño:\n\nggplot(Oxboys, aes(Occasion, height)) + \n  geom_boxplot() +\n  geom_line(aes(group = Subject), colour = \"#3366FF\", alpha = 0.5)",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Geomas colectivas</span>"
    ]
  },
  {
    "objectID": "collective-geoms.html#sec-matching",
    "href": "collective-geoms.html#sec-matching",
    "title": "4  Geomas colectivas",
    "section": "\n4.4 Combinar la estética con los objetos gráficos",
    "text": "4.4 Combinar la estética con los objetos gráficos\nUna última cuestión importante con las geomas colectivas es cómo la estética de las observaciones individuales se relaciona con la estética de la entidad completa. ¿Qué sucede cuando se asignan diferentes estéticas a un solo elemento geométrico? \nEn ggplot2, esto se maneja de manera diferente para diferentes geoms colectivas. Las líneas y caminos operan según el principio de “primer valor”: cada segmento está definido por dos observaciones, y ggplot2 aplica el valor estético (por ejemplo, color) asociado con la primera observación al dibujar el segmento. Es decir, la estética de la primera observación se utiliza al dibujar el primer segmento, la segunda observación se utiliza al dibujar el segundo segmento y así sucesivamente. No se utiliza el valor estético de la última observación:\ndf &lt;- data.frame(x = 1:3, y = 1:3, colour = c(1, 3, 5))\n\nggplot(df, aes(x, y, colour = factor(colour))) + \n  geom_line(aes(group = 1), linewidth = 2) +\n  geom_point(size = 5)\n\nggplot(df, aes(x, y, colour = colour)) + \n  geom_line(aes(group = 1), linewidth = 2) +\n  geom_point(size = 5)\n\n\n\n\n\n\n\n\n\n\nA la izquierda, donde el color es discreto, el primer punto y el primer segmento de línea son rojos, el segundo punto y el segundo segmento de línea son verdes y el punto final (sin segmento correspondiente) es azul. A la derecha, donde el color es continuo, se aplica el mismo principio a los tres tonos diferentes de azul. Tenga en cuenta que, aunque la variable de color es continua, ggplot2 no combina suavemente de un valor estético a otro. Si este es el comportamiento que deseas, puedes realizar la interpolación lineal tú mismo:\n\nxgrid &lt;- with(df, seq(min(x), max(x), length = 50))\ninterp &lt;- data.frame(\n  x = xgrid,\n  y = approx(df$x, df$y, xout = xgrid)$y,\n  colour = approx(df$x, df$colour, xout = xgrid)$y  \n)\nggplot(interp, aes(x, y, colour = colour)) + \n  geom_line(linewidth = 2) +\n  geom_point(data = df, size = 5)\n\n\n\n\n\n\n\nVale la pena señalar una limitación adicional para rutas y líneas: el tipo de línea debe ser constante en cada línea individual. En R no hay forma de dibujar una línea que tenga diferentes tipos de línea. \n¿Qué pasa con otras geomas colectivas, como los polígonos? La mayoría de las geomas colectivas son más complicadas que las líneas y los caminos, y un solo objeto geométrico puede corresponder a muchas observaciones. En tales casos no resulta obvio cómo combinar la estética de las observaciones individuales. Por ejemplo, ¿cómo colorearías un polígono que tuviera un color de relleno diferente para cada punto de su borde? Debido a esta ambigüedad, ggplot2 adopta una regla simple: la estética de los componentes individuales se usa solo si todos son iguales. Si la estética difiere para cada componente, ggplot2 usa un valor predeterminado. \nEstas cuestiones son más relevantes cuando se asigna la estética a variables continuas. Para variables discretas, el comportamiento predeterminado de ggplot2 es tratar la variable como parte de la estética del grupo, como se describió anteriormente. Esto tiene el efecto de dividir la geom colectiva en pedazos más pequeños. Esto funciona particularmente bien para gráficos de barras y áreas, porque al apilar las piezas individuales se produce la misma forma que los datos originales desagrupados:\nggplot(mpg, aes(class)) + \n  geom_bar()\nggplot(mpg, aes(class, fill = drv)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\nSi intenta asignar la estética del relleno a una variable continua (por ejemplo, hwy) de la misma manera, no funciona. La agrupación predeterminada solo se basará en class, por lo que cada barra ahora está asociada con varios colores (dependiendo del valor de hwy para las observaciones en cada clase). Debido a que una barra solo puede mostrar un color, ggplot2 vuelve al gris predeterminado en este caso. Para mostrar varios colores, necesitamos varias barras para cada class, que podemos obtener anulando la agrupación:\nggplot(mpg, aes(class, fill = hwy)) + \n  geom_bar()\n#&gt; Warning: The following aesthetics were dropped during statistical transformation: fill.\n#&gt; ℹ This can happen when ggplot fails to infer the correct grouping structure in\n#&gt;   the data.\n#&gt; ℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n#&gt;   variable into a factor?\nggplot(mpg, aes(class, fill = hwy, group = hwy)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\nEn el gráfico de la derecha, las “barras sombreadas” para cada class se construyeron apilando muchas barras distintas una encima de la otra, cada una rellena con un tono diferente según el valor de hwy. Tenga en cuenta que cuando hace esto, las barras se apilan en el orden definido por la variable de agrupación (en este ejemplo, hwy). Si necesita un control preciso sobre este comportamiento, deberá crear un factor con niveles ordenados según sea necesario.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Geomas colectivas</span>"
    ]
  },
  {
    "objectID": "collective-geoms.html#ejercicios",
    "href": "collective-geoms.html#ejercicios",
    "title": "4  Geomas colectivas",
    "section": "\n4.5 Ejercicios",
    "text": "4.5 Ejercicios\n\nDibuja un diagrama de caja de hwy para cada valor de cyl, sin convertir cyl en un factor. ¿Qué estética extra necesitas configurar?\n\nModifique el siguiente gráfico para obtener un diagrama de caja por valor entero de displ.\n\nggplot(mpg, aes(displ, cty)) + \n  geom_boxplot()\n\n\nAl ilustrar la diferencia entre asignar colores continuos y discretos a una línea, el ejemplo discreto necesitaba aes (grupo = 1). ¿Por qué? ¿Qué pasa si eso se omite? ¿Cuál es la diferencia entre aes(grupo = 1) y aes(grupo = 2)? ¿Por qué?\n\n¿Cuántas barras hay en cada una de las siguientes gráficas?\n\nggplot(mpg, aes(drv)) + \n  geom_bar()\n\nggplot(mpg, aes(drv, fill = hwy, group = hwy)) + \n  geom_bar()\n\nlibrary(dplyr)  \nmpg2 &lt;- mpg %&gt;% arrange(hwy) %&gt;% mutate(id = seq_along(hwy)) \nggplot(mpg2, aes(drv, fill = hwy, group = id)) + \n  geom_bar()\n\n(Sugerencia: intente agregar un contorno alrededor de cada barra con colour = \"white\")\n\n\nInstale el paquete babynames. Contiene datos sobre la popularidad de los nombres de bebés en Estados Unidos. Ejecute el siguiente código y corrija el gráfico resultante. ¿Por qué este gráfico nos hace infelices?\n\nlibrary(babynames)\nhadley &lt;- dplyr::filter(babynames, name == \"Hadley\")\nggplot(hadley, aes(year, n)) + \n  geom_line()",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Geomas colectivas</span>"
    ]
  },
  {
    "objectID": "statistical-summaries.html",
    "href": "statistical-summaries.html",
    "title": "5  Resúmenes estadísticos",
    "section": "",
    "text": "5.1 Revelando incertidumbre\nSi tiene información sobre la incertidumbre presente en sus datos, ya sea de un modelo o de supuestos distributivos, es una buena idea mostrarla. Hay cuatro familias básicas de geoms que se pueden usar para este trabajo, dependiendo de si los valores de x son discretos o continuos, y si desea o no mostrar la mitad del intervalo, o solo la extensión:\nEstas geoms suponen que está interesado en la distribución de y condicional a x y utilizan la estética ymin e ymax para determinar el rango de los valores de y. Si quieres lo contrario, mira Sección 15.1.2.\nDebido a que hay tantas formas diferentes de calcular los errores estándar, el cálculo depende de usted. Para casos muy simples, ggplot2 proporciona algunas herramientas en forma de funciones de resumen que se describen a continuación; de lo contrario, tendrá que hacerlo usted mismo.R para la Ciencia de Datos (https://r4ds.had.co.nz) contiene más consejos sobre cómo trabajar con modelos más sofisticados.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resúmenes estadísticos</span>"
    ]
  },
  {
    "objectID": "statistical-summaries.html#sec-uncertainty",
    "href": "statistical-summaries.html#sec-uncertainty",
    "title": "5  Resúmenes estadísticos",
    "section": "",
    "text": "Discreto x, rango: geom_errorbar(), geom_linerange()\n\nDiscreto x, rango & centro: geom_crossbar(), geom_pointrange()\n\nContinuo x, rango: geom_ribbon()\n\nContinuo x, rango & centro: geom_smooth(stat = \"identity\")\n\n\n\ny &lt;- c(18, 11, 16)\ndf &lt;- data.frame(x = 1:3, y = y, se = c(1.2, 0.5, 1.0))\n\nbase &lt;- ggplot(df, aes(x, y, ymin = y - se, ymax = y + se))\nbase + geom_crossbar()\nbase + geom_pointrange()\nbase + geom_smooth(stat = \"identity\")\n\nbase + geom_errorbar()\nbase + geom_linerange()\nbase + geom_ribbon()",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resúmenes estadísticos</span>"
    ]
  },
  {
    "objectID": "statistical-summaries.html#sec-weighting",
    "href": "statistical-summaries.html#sec-weighting",
    "title": "5  Resúmenes estadísticos",
    "section": "\n5.2 Datos ponderados",
    "text": "5.2 Datos ponderados\nCuando tiene datos agregados donde cada fila del conjunto de datos representa múltiples observaciones, necesita alguna forma de tener en cuenta la variable de ponderación. Usaremos algunos datos recopilados sobre los estados del Medio Oeste en el censo estadounidense de 2000 en el marco de datos incorporado del midwest. Los datos consisten principalmente en porcentajes (por ejemplo, porcentaje de blancos, porcentaje por debajo del umbral de pobreza, porcentaje con título universitario) y cierta información para cada condado (área, población total, densidad de población). \nHay algunas cosas diferentes que quizás queramos considerar:\n\nNada, para mirar el número de condados.\nPoblación total, para trabajar con números absolutos.\nÁrea, para investigar efectos geográficos. (Esto no es útil para el midwest, pero lo sería si tuviéramos variables como el porcentaje de tierras de cultivo).\n\nLa elección de una variable de ponderación afecta profundamente lo que estamos viendo en la gráfica y las conclusiones que sacaremos. Hay dos atributos estéticos que se pueden utilizar para ajustar los pesos. En primer lugar, para geoms simples como líneas y puntos, use la estética de tamaño:\n# no ponderado\nggplot(midwest, aes(percwhite, percbelowpoverty)) + \n  geom_point()\n\n# Peso por población\nggplot(midwest, aes(percwhite, percbelowpoverty)) + \n  geom_point(aes(size = poptotal / 1e6)) + \n  scale_size_area(\"Población\\n(millones)\", breaks = c(0.5, 1, 2, 4))\n\n\n\n\n\n\n\n\n\n\nPara geomas más complicadas que implican alguna transformación estadística, especificamos pesos con la estética weight. Estos pesos se pasarán a la función de resumen estadístico. Se admiten ponderaciones para todos los casos en los que tenga sentido: suavizadores, regresiones cuantiles, diagramas de caja, histogramas y diagramas de densidad. No puede ver esta variable de ponderación directamente y no produce una leyenda, pero cambiará los resultados del resumen estadístico. El siguiente código muestra cómo la ponderación por densidad de población afecta la relación entre el porcentaje de blancos y el porcentaje por debajo del umbral de pobreza.\n# no ponderado\nggplot(midwest, aes(percwhite, percbelowpoverty)) + \n  geom_point() + \n  geom_smooth(method = lm, linewidth = 1)\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n# Ponderado por población\nggplot(midwest, aes(percwhite, percbelowpoverty)) + \n  geom_point(aes(size = poptotal / 1e6)) + \n  geom_smooth(aes(weight = poptotal), method = lm, linewidth = 1) +\n  scale_size_area(guide = \"none\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\nCuando ponderamos un histograma o un gráfico de densidad por la población total, pasamos de observar la distribución del número de condados a la distribución del número de personas. El siguiente código muestra la diferencia que esto supone para un histograma del porcentaje por debajo del umbral de pobreza: \nggplot(midwest, aes(percbelowpoverty)) +\n  geom_histogram(binwidth = 1) + \n  ylab(\"Condados\")\n\nggplot(midwest, aes(percbelowpoverty)) +\n  geom_histogram(aes(weight = poptotal), binwidth = 1) +\n  ylab(\"Población (1000s)\")",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resúmenes estadísticos</span>"
    ]
  },
  {
    "objectID": "statistical-summaries.html#sec-diamonds",
    "href": "statistical-summaries.html#sec-diamonds",
    "title": "5  Resúmenes estadísticos",
    "section": "\n5.3 Datos de diamantes",
    "text": "5.3 Datos de diamantes\nPara demostrar herramientas para grandes conjuntos de datos, usaremos el conjunto de datos integrado diamonds, que consta de información de precio y calidad para ~54,000 diamantes:\n\ndiamonds \n#&gt; # A tibble: 53,940 × 10\n#&gt;   carat cut       color clarity depth table price     x     y     z\n#&gt;   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt; 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt; 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt; 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt; 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt; 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt; # ℹ 53,934 more rows\n\nLos datos contienen las cuatro C de la calidad del diamante: quilates, talla, color y claridad; y cinco medidas físicas: profundidad, tabla, x, y y z, como se describe en la siguiente figura. \n\n\n\n\nHow the variables x, y, z, table and depth are measured.\n\n\n\nEl conjunto de datos no se ha limpiado bien, por lo que, además de demostrar datos interesantes sobre los diamantes, también muestra algunos problemas de calidad de los datos.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resúmenes estadísticos</span>"
    ]
  },
  {
    "objectID": "statistical-summaries.html#sec-distributions",
    "href": "statistical-summaries.html#sec-distributions",
    "title": "5  Resúmenes estadísticos",
    "section": "\n5.4 Mostrando distribuciones",
    "text": "5.4 Mostrando distribuciones\nHay una serie de geoms que se pueden usar para mostrar distribuciones, dependiendo de la dimensionalidad de la distribución, si es continua o discreta, y si está interesado en la distribución condicional o conjunta. \nPara distribuciones continuas 1d, la geom más importante es el histograma, geom_histogram(): \nggplot(diamonds, aes(depth)) + \n  geom_histogram()\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\nggplot(diamonds, aes(depth)) + \n  geom_histogram(binwidth = 0.1) + \n  xlim(55, 70)\n#&gt; Warning: Removed 45 rows containing non-finite outside the scale range\n#&gt; (`stat_bin()`).\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range\n#&gt; (`geom_bar()`).\n\n\n\n\n\n\n\n\n\n\nEs importante experimentar con la agrupación para encontrar una vista reveladora. Puede cambiar el binwidth, especificar el número de bins o especificar la ubicación exacta de los breaks. Nunca confíe en los parámetros predeterminados para obtener una vista reveladora de la distribución. Hacer zoom en el eje x, xlim(55, 70), y seleccionar un ancho de contenedor más pequeño, binwidth = 0.1, revela muchos más detalles. \nAl publicar cifras, no olvide incluir información sobre parámetros importantes (como el ancho del contenedor) en el título.\nSi desea comparar la distribución entre grupos, tiene algunas opciones:\n\nMostrar pequeños múltiplos del histograma, facet_wrap(~ var).\nUsa color y un polígono de frecuencia, geom_freqpoly(). \nUtilice un “gráfico de densidad condicional”, geom_histogram(position = \"fill\"). \n\nLos gráficos de polígono de frecuencia y densidad condicional se muestran a continuación. El gráfico de densidad condicional utiliza position_fill() para apilar cada contenedor y escalarlo a la misma altura. Este gráfico es un desafío desde el punto de vista perceptivo porque es necesario comparar las alturas de las barras, no las posiciones, pero se pueden ver los patrones más fuertes. \nggplot(diamonds, aes(depth)) + \n  geom_freqpoly(aes(colour = cut), binwidth = 0.1, na.rm = TRUE) +\n  xlim(58, 68) + \n  theme(legend.position = \"none\")\n\nggplot(diamonds, aes(depth)) + \n  geom_histogram(aes(fill = cut), binwidth = 0.1, position = \"fill\",\n    na.rm = TRUE) +\n  xlim(58, 68) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n(Hemos suprimido las leyendas para centrarnos en la visualización de los datos).\nTanto el histograma como el polígono de frecuencia utilizan la misma transformación estadística subyacente: stat = \"bin\". Esta estadística produce dos variables de salida: count y density. De forma predeterminada, el recuento se asigna a la posición y, porque es más interpretable. La densidad es el recuento dividido por el recuento total multiplicado por el ancho del contenedor y es útil cuando desea comparar la forma de las distribuciones, no el tamaño general. \nUna alternativa a una visualización basada en contenedores es una estimación de densidad. geom_density() coloca una pequeña distribución normal en cada punto de datos y resume todas las curvas. Tiene propiedades teóricas deseables, pero es más difícil relacionarlo con los datos. Utilice un gráfico de densidad cuando sepa que la densidad subyacente es suave, continua e ilimitada. Puede utilizar el parámetro adjust para hacer que la densidad sea más o menos suave. \nggplot(diamonds, aes(depth)) +\n  geom_density(na.rm = TRUE) + \n  xlim(58, 68) + \n  theme(legend.position = \"none\")\n\nggplot(diamonds, aes(depth, fill = cut, colour = cut)) +\n  geom_density(alpha = 0.2, na.rm = TRUE) + \n  xlim(58, 68) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta que el área de cada estimación de densidad está estandarizada a uno, por lo que se pierde información sobre el tamaño relativo de cada grupo.\nEl histograma, el polígono de frecuencia y la densidad muestran una vista detallada de la distribución. Sin embargo, a veces quieres comparar muchas distribuciones y es útil tener opciones alternativas que sacrifiquen calidad por cantidad. Aquí hay tres opciones:\n\n\ngeom_boxplot(): el diagrama de caja y bigotes muestra cinco estadísticas resumidas junto con “valores atípicos” individuales. Muestra mucha menos información que un histograma, pero también ocupa mucho menos espacio. \nPuede utilizar un diagrama de caja con x tanto categórica como continua. Para x continuo, también deberá configurar la estética del grupo para definir cómo se divide la variable x en contenedores. Una función auxiliar útil es cut_width(): \nggplot(diamonds, aes(clarity, depth)) + \n  geom_boxplot()\n\nggplot(diamonds, aes(carat, depth)) + \n  geom_boxplot(aes(group = cut_width(carat, 0.1))) + \n  xlim(NA, 2.05)\n#&gt; Warning: Removed 997 rows containing missing values or values outside the scale range\n#&gt; (`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_violin(): el diagrama del violín es una versión compacta del diagrama de densidad. El cálculo subyacente es el mismo, pero los resultados se muestran de forma similar al diagrama de caja: \nggplot(diamonds, aes(clarity, depth)) + \n  geom_violin()\n\nggplot(diamonds, aes(carat, depth)) + \n  geom_violin(aes(group = cut_width(carat, 0.1))) + \n  xlim(NA, 2.05)\n#&gt; Warning: Removed 997 rows containing non-finite outside the scale range\n#&gt; (`stat_ydensity()`).\n\n\n\n\n\n\n\n\n\n\n\ngeom_dotplot(): Dibuja un punto para cada observación, cuidadosamente ajustado en el espacio para evitar superposiciones y mostrar la distribución. Es útil para conjuntos de datos más pequeños. \n\n\n5.4.1 Ejercicios\n\n¿Qué binwidth te cuenta la historia más interesante sobre la distribución de carat?\nDibuja un histograma de price. ¿Qué patrones interesantes ves?\n¿Cómo varía la distribución del price conclarity?\nSuperponga un polígono de frecuencia y un gráfico de densidad de depth. ¿Qué variable calculada necesita asignar a y para que los dos gráficos sean comparables? (Puedes modificar geom_freqpoly() o geom_density().)",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resúmenes estadísticos</span>"
    ]
  },
  {
    "objectID": "statistical-summaries.html#sec-overplotting",
    "href": "statistical-summaries.html#sec-overplotting",
    "title": "5  Resúmenes estadísticos",
    "section": "\n5.5 Lidiar con el trazado excesivo",
    "text": "5.5 Lidiar con el trazado excesivo\nEl diagrama de dispersión es una herramienta muy importante para evaluar la relación entre dos variables continuas. Sin embargo, cuando los datos son grandes, los puntos a menudo se trazan uno encima del otro, oscureciendo la verdadera relación. En casos extremos, sólo podrá ver la extensión de los datos y cualquier conclusión que se extraiga del gráfico será sospechosa. Este problema se llama overplotting. \nHay varias formas de abordarlo según el tamaño de los datos y la gravedad del trazado excesivo. El primer conjunto de técnicas implica modificar las propiedades estéticas. Suelen ser más eficaces para conjuntos de datos más pequeños:\n\n\nA veces, se pueden aliviar cantidades muy pequeñas de trazado excesivo haciendo los puntos más pequeños o usando glifos huecos. El siguiente código muestra algunas opciones para 2000 puntos muestreados de una distribución normal bivariada. \ndf &lt;- data.frame(x = rnorm(2000), y = rnorm(2000))\nnorm &lt;- ggplot(df, aes(x, y)) + xlab(NULL) + ylab(NULL)\nnorm + geom_point()\nnorm + geom_point(shape = 1) # círculos huecos\nnorm + geom_point(shape = \".\") # Tamaño de píxel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara conjuntos de datos más grandes con más trazados superpuestos, puede utilizar la combinación alfa (transparencia) para hacer que los puntos sean transparentes. Si especifica alpha como proporción, el denominador proporciona el número de puntos que se deben superponer para obtener un color sólido. Valores menores que ~\\(1/500\\) se redondean a cero, dando puntos completamente transparentes. \nnorm + geom_point(alpha = 1 / 3)\nnorm + geom_point(alpha = 1 / 5)\nnorm + geom_point(alpha = 1 / 10)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSi hay cierta discreción en los datos, puede alterar aleatoriamente los puntos para aliviar algunas superposiciones con geom_jitter(). Esto puede resultar especialmente útil junto con la transparencia. De forma predeterminada, la cantidad de fluctuación agregada es el 40 % de la resolución de los datos, lo que deja un pequeño espacio entre las regiones adyacentes. Puede anular el valor predeterminado con los argumentos width y height.\n\nAlternativamente, podemos pensar en el sobregráfico como un problema de estimación de densidad 2D, lo que da lugar a dos enfoques más:\n\n\nAgrupe los puntos y cuente el número en cada contenedor, luego visualice ese recuento (la segunda generalización del histograma), geom_bin2d(). Dividir la gráfica en muchos cuadrados pequeños puede producir artefactos visuales que distraigan. (D. B. Carr et al. 1987) sugiere usar hexágonos en su lugar, y esto se implementa en geom_hex(), usando el paquete hexbin (D. Carr, Lewin-Koh, y Mächler 2014). \nEl siguiente código compara contenedores cuadrados y hexagonales, utilizando los parámetros bins y binwidth para controlar el número y el tamaño de los contenedores. \nnorm + geom_bin2d()\nnorm + geom_bin2d(bins = 10)\n\n\n\n\n\n\n\n\n\n\nnorm + geom_hex()\nnorm + geom_hex(bins = 10)\n\n\n\n\n\n\n\n\n\n\n\nEstime la densidad 2d con stat_density2d() y luego muéstrela usando una de las técnicas para mostrar superficies 3d en Sección 5.7.\nSi está interesado en la distribución condicional de y dado x, entonces las técnicas de Sección 2.6.3 también serán útil.\n\nOtro enfoque para lidiar con el trazado excesivo es agregar resúmenes de datos para ayudar a guiar la vista hacia la verdadera forma del patrón dentro de los datos. Por ejemplo, podrías agregar una línea suave que muestre el centro de los datos con geom_smooth() o usar uno de los resúmenes siguientes.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resúmenes estadísticos</span>"
    ]
  },
  {
    "objectID": "statistical-summaries.html#sec-summary",
    "href": "statistical-summaries.html#sec-summary",
    "title": "5  Resúmenes estadísticos",
    "section": "\n5.6 Resúmenes estadísticos",
    "text": "5.6 Resúmenes estadísticos\n \ngeom_histogram() y geom_bin2d() usa una geom familiar, geom_bar() y geom_raster(), combinado con una nueva transformación estadística, stat_bin() y stat_bin2d(). stat_bin() y stat_bin2d() combine los datos en contenedores y cuente el número de observaciones en cada contenedor. Pero ¿y si queremos un resumen distinto al de contar? Hasta ahora, sólo hemos utilizado la transformación estadística predeterminada asociada con cada geom. Ahora vamos a explorar cómo usar stat_summary_bin() y stat_summary_2d() para calcular diferentes resúmenes.\nComencemos con un par de ejemplos con los datos de diamantes. El primer ejemplo de cada par muestra cómo podemos contar la cantidad de diamantes en cada contenedor; el segundo muestra cómo podemos calcular el precio promedio.\nggplot(diamonds, aes(color)) + \n  geom_bar()\n\nggplot(diamonds, aes(color, price)) + \n  geom_bar(stat = \"summary_bin\", fun = mean)\n\n\n\n\n\n\n\n\n\n\nggplot(diamonds, aes(table, depth)) + \n  geom_bin2d(binwidth = 1, na.rm = TRUE) + \n  xlim(50, 70) + \n  ylim(50, 70)\n\nggplot(diamonds, aes(table, depth, z = price)) + \n  geom_raster(binwidth = 1, stat = \"summary_2d\", fun = mean, \n    na.rm = TRUE) + \n  xlim(50, 70) + \n  ylim(50, 70)\n#&gt; Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted\n#&gt; ℹ Consider using `geom_tile()` instead.\n#&gt; Raster pixels are placed at uneven horizontal intervals and will be shifted\n#&gt; ℹ Consider using `geom_tile()` instead.\n\n\n\n\n\n\n\n\n\n\nPara obtener más ayuda sobre los argumentos asociados con las dos transformaciones, consulte la ayuda para stat_summary_bin() y stat_summary_2d(). Puede controlar el tamaño de los contenedores y las funciones de resumen. stat_summary_bin() puede producir y, ymin y ymax estética, lo que también lo hace útil para mostrar medidas de propagación. Consulte los documentos para obtener más detalles. Aprenderás más sobre cómo interactúan las geoms y las estadísticas en Sección 13.6.\nEstas funciones de resumen son bastante limitadas, pero suelen ser útiles para dar un primer vistazo rápido a un problema. Si los encuentra restrictivos, deberá hacer los resúmenes usted mismo (consulte R para la Ciencia de Datos https://r4ds.had.co.nz para más detalles)",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resúmenes estadísticos</span>"
    ]
  },
  {
    "objectID": "statistical-summaries.html#sec-surface",
    "href": "statistical-summaries.html#sec-surface",
    "title": "5  Resúmenes estadísticos",
    "section": "\n5.7 Superficies",
    "text": "5.7 Superficies\n \nHasta ahora hemos considerado dos clases de geoms:\n\nGeomas simples donde hay una correspondencia uno a uno entre las filas en el marco de datos y los elementos físicos de la geom.\nGeomas estadísticas donde se introduce una capa de resúmenes estadísticos entre los datos sin procesar y el resultado.\n\nAhora consideraremos casos en los que se requiere una visualización de una superficie tridimensional. El paquete ggplot2 no admite superficies 3D reales, pero sí admite muchas herramientas comunes para resumir superficies 3D en 2D: contornos, mosaicos de colores y diagramas de burbujas. Todos funcionan de manera similar, diferenciándose sólo en la estética utilizada para la tercera dimensión. A continuación se muestra un ejemplo de un gráfico de contorno:\n\nggplot(faithfuld, aes(eruptions, waiting)) + \n  geom_contour(aes(z = density, colour = ..level..))\n#&gt; Warning: The dot-dot notation (`..level..`) was deprecated in ggplot2 3.4.0.\n#&gt; ℹ Please use `after_stat(level)` instead.\n\n\n\n\n\n\n\nLa referencia a la variable ..level... en este código puede parecer confusa, porque no hay ninguna variable llamada ...level... en los datos de faithfuld. En este contexto, la notación .. se refiere a una variable calculada internamente (consulte Sección 13.6.1). Para mostrar la misma densidad que un mapa de calor, puede utilizar geom_raster():\n\nggplot(faithfuld, aes(eruptions, waiting)) + \n  geom_raster(aes(fill = density))\n\n\n\n\n\n\n\n\n# Los gráficos de burbujas funcionan mejor con menos observaciones\nsmall &lt;- faithfuld[seq(1, nrow(faithfuld), by = 10), ]\nggplot(small, aes(eruptions, waiting)) + \n  geom_point(aes(size = density), alpha = 1/3) + \n  scale_size_area()\n\n\n\n\n\n\n\nPara gráficos 3D interactivos, incluidas superficies 3D reales, consulte RGL, http://rgl.neoscientists.org/about.shtml.\n\n\n\n\nCarr, D. B., R. J. Littlefield, W. L. Nicholson, y J. S. Littlefield. 1987. «Scatterplot Matrix Techniques for Large N». Journal of the American Statistical Association 82 (398): 424-36.\n\n\nCarr, Dan, Nicholas Lewin-Koh, y Martin Mächler. 2014. hexbin: Hexagonal Binning Routines.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Resúmenes estadísticos</span>"
    ]
  },
  {
    "objectID": "maps.html",
    "href": "maps.html",
    "title": "6  Mapas",
    "section": "",
    "text": "6.1 Mapas de polígonos\nTrazar datos geoespaciales es una tarea de visualización común y que requiere herramientas especializadas. Normalmente, el problema se puede descomponer en dos problemas: utilizar una fuente de datos para dibujar un mapa y agregar metadatos de otra fuente de información al mapa. Este capítulo le ayudará a abordar ambos problemas. Hemos estructurado el capítulo de la siguiente manera: Sección 6.1 describe una forma sencilla de dibujar mapas usando geom_polygon(), seguida en Sección 6.2 por un enfoque moderno de “características simples” (sf) usando geom_sf(). A continuación, Sección 6.3 y Sección 6.4 analizan cómo trabajar con proyecciones de mapas y la estructura de datos sf subyacente. Finalmente, Sección 6.5 analiza cómo dibujar mapas basados en datos ráster.\nQuizás el método más sencillo para dibujar mapas sea utilizar geom_polygon() para dibujar límites para diferentes regiones. Para este ejemplo tomamos datos del paquete de mapas usando ggplot2::map_data(). El paquete de mapas no es particularmente preciso ni está actualizado, pero está integrado en R, por lo que es un lugar fácil para comenzar. Aquí hay un conjunto de datos que especifica los límites del condado de Michigan:\nmi_counties &lt;- map_data(\"county\", \"michigan\") %&gt;% \n  select(lon = long, lat, group, id = subregion)\nhead(mi_counties)\n#&gt;     lon  lat group     id\n#&gt; 1 -83.9 44.9     1 alcona\n#&gt; 2 -83.4 44.9     1 alcona\n#&gt; 3 -83.4 44.9     1 alcona\n#&gt; 4 -83.3 44.8     1 alcona\n#&gt; 5 -83.3 44.8     1 alcona\n#&gt; 6 -83.3 44.8     1 alcona\nEn este conjunto de datos tenemos cuatro variables: lat y long especifican la latitud y longitud de un vértice (es decir, una esquina del polígono), id especifica el nombre de una región y group proporciona un valor único. identificador de áreas contiguas dentro de una región (por ejemplo, si una región constaba de varias islas). Para tener una mejor idea de lo que contienen los datos, podemos trazar mi_counties usando geom_point(), como se muestra en el panel izquierdo a continuación. En este gráfico, cada fila del marco de datos se traza como un único punto, lo que produce un diagrama de dispersión que muestra las esquinas de cada condado. Para convertir este diagrama de dispersión en un mapa, usamos geom_polygon(), que dibuja cada condado como un polígono distinto. Esto se ilustra en el panel derecho a continuación.\nEn ambos gráficos usamos coord_quickmap() para ajustar los ejes y garantizar que la longitud y la latitud se representen en la misma escala. Capítulo 15 analiza los sistemas de coordenadas en ggplot2 en términos más generales, pero como veremos a continuación, los datos geoespaciales a menudo requieren un enfoque más exigente. Por esta razón, ggplot2 proporciona geom_sf() y coord_sf() para manejar datos espaciales especificados en formato de características simples.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Mapas</span>"
    ]
  },
  {
    "objectID": "maps.html#sec-polygonmaps",
    "href": "maps.html#sec-polygonmaps",
    "title": "6  Mapas",
    "section": "",
    "text": "ggplot(mi_counties, aes(lon, lat)) + \n  geom_point(size = .25, show.legend = FALSE) +\n  coord_quickmap()\n\nggplot(mi_counties, aes(lon, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"grey50\") + \n  coord_quickmap()",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Mapas</span>"
    ]
  },
  {
    "objectID": "maps.html#sec-sf",
    "href": "maps.html#sec-sf",
    "title": "6  Mapas",
    "section": "\n6.2 Mapas de características simples",
    "text": "6.2 Mapas de características simples\nEl enfoque descrito anteriormente tiene algunas limitaciones, entre las que destaca el hecho de que el formato de datos simple “longitud-latitud” no se utiliza normalmente en la cartografía del mundo real. Los datos vectoriales para mapas normalmente se codifican utilizando el estándar de “características simples” producido por el Open Geospatial Consortium. El paquete sf (Pebesma 2018) desarrollado por Edzer Pebesma https://github.com/r-spatial/sf proporciona un excelente conjunto de herramientas para trabajar con dichos datos y las funciones geom_sf() y coord_sf() en ggplot2 están diseñados para funcionar junto con el paquete sf.\nPara presentar estas funciones, nos basamos en el paquete ozmaps de Michael Sumner https://github.com/mdsumner/ozmaps/ que proporciona mapas de las fronteras estatales de Australia, áreas de gobierno local, límites electorales, etc. (Sumner 2019) . Para ilustrar cómo se ve un conjunto de datos sf, importamos un conjunto de datos que representa las fronteras de los estados y territorios australianos:\n\nlibrary(ozmaps)\nlibrary(sf)\n#&gt; Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE\n\noz_states &lt;- ozmaps::ozmap_states\noz_states\n#&gt; Simple feature collection with 9 features and 1 field\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 106 ymin: -43.6 xmax: 168 ymax: -9.23\n#&gt; Geodetic CRS:  GDA94\n#&gt; # A tibble: 9 × 2\n#&gt;   NAME                                                                  geometry\n#&gt; * &lt;chr&gt;                                                       &lt;MULTIPOLYGON [°]&gt;\n#&gt; 1 New South Wales   (((151 -35.1, 151 -35.1, 151 -35.1, 151 -35.1, 151 -35.2, 1…\n#&gt; 2 Victoria          (((147 -38.7, 147 -38.7, 147 -38.7, 147 -38.7, 147 -38.7)),…\n#&gt; 3 Queensland        (((149 -20.3, 149 -20.4, 149 -20.4, 149 -20.3)), ((149 -20.…\n#&gt; 4 South Australia   (((137 -34.5, 137 -34.5, 137 -34.5, 137 -34.5, 137 -34.5, 1…\n#&gt; 5 Western Australia (((126 -14, 126 -14, 126 -14, 126 -14, 126 -14)), ((124 -16…\n#&gt; 6 Tasmania          (((148 -40.3, 148 -40.3, 148 -40.3, 148 -40.3)), ((147 -39.…\n#&gt; # ℹ 3 more rows\n\nEste resultado muestra algunos de los metadatos asociados con los datos (que se analizan momentáneamente) y nos dice que los datos son esencialmente un tibble con 9 filas y 2 columnas. Una ventaja de los datos de ciencia ficción es inmediatamente evidente: podemos ver fácilmente la estructura general de los datos: Australia se compone de seis estados y algunos territorios. Hay 9 unidades geográficas distintas, por lo que hay 9 filas en este tibble (cf. mi_counties data donde hay una fila por vértice del polígono).\nLa columna más importante es “geometría” geometry, que especifica la geometría espacial para cada uno de los estados y territorios. Cada elemento de la columna geometry es un objeto multipolígono que, como su nombre indica, contiene datos que especifican los vértices de uno o más polígonos que delimitan el borde de una región. Dados los datos en este formato, podemos usar geom_sf() y coord_sf() para dibujar un mapa útil sin especificar ningún parámetro o incluso declarar explícitamente ninguna estética:\n\nggplot(oz_states) + \n  geom_sf() + \n  coord_sf()\n\n\n\n\n\n\n\nPara entender por qué esto funciona, tenga en cuenta que geom_sf() se basa en una estética de geometry que no se utiliza en ninguna otra parte de ggplot2. Esta estética se puede especificar de una de tres maneras:\n\nEn el caso más simple (ilustrado arriba) cuando el usuario no hace nada, geom_sf() intentará asignarlo a una columna llamada geometry.\nSi el argumento data es un objeto sf entonces geom_sf() puede detectar automáticamente una columna de geometría, incluso si no se llama geometry.\nPuede especificar el mapeo manualmente de la forma habitual con aes(geometry = my_column). Esto es útil si tiene varias columnas de geometría.\n\nLa función coord_sf() gobierna la proyección del mapa, discutida en Sección 6.3.\n\n6.2.1 Mapas en capas\nEn algunos casos, es posible que desees superponer un mapa encima de otro. El paquete ggplot2 admite esto permitiéndole agregar múltiples capas geom_sf() a un gráfico. Como ejemplo, usaremos los datos de “oz_states” para dibujar los estados australianos en diferentes colores y superpondremos este gráfico con los límites de las regiones electorales australianas. Para hacer esto, hay que realizar dos pasos de preprocesamiento. Primero, usaremos dplyr::filter() para eliminar los “Other Territories” de las fronteras estatales.\nEl siguiente código dibuja un gráfico con dos capas de mapa: la primera usa oz_states para llenar los estados en diferentes colores, y la segunda usa oz_votes para dibujar los límites electorales. En segundo lugar, extraeremos los límites electorales de forma simplificada utilizando la función ms_simplify() del paquete rmapshaper (Teucher y Russell 2018). Generalmente, esto es una buena idea si el conjunto de datos original (en este caso, ozmaps::abs_ced) se almacena a una resolución más alta que la que requiere su gráfico, para reducir el tiempo necesario para renderizar el gráfico.\n\noz_states &lt;- ozmaps::ozmap_states %&gt;% filter(NAME != \"Other Territories\")\noz_votes &lt;- rmapshaper::ms_simplify(ozmaps::abs_ced)\n\nAhora que tenemos los conjuntos de datos oz_states y oz_votes para representar las fronteras estatales y electorales respectivamente, el gráfico deseado se puede construir agregando dos capas geom_sf() al gráfico:\n\nggplot() + \n  geom_sf(data = oz_states, mapping = aes(fill = NAME), show.legend = FALSE) +\n  geom_sf(data = oz_votes, fill = NA) + \n  coord_sf()\n\n\n\n\n\n\n\nVale la pena señalar que la primera capa de este gráfico asigna la estética del fill a una variable de los datos. En este caso, la variable NAME es una variable categórica y no transmite ninguna información adicional, pero se puede utilizar el mismo enfoque para visualizar otros tipos de metadatos de área. Por ejemplo, si oz_states tuviera una columna adicional que especificara el nivel de desempleo en cada estado, podríamos asignar la estética del fill a esa variable.\n\n6.2.2 Mapas etiquetados\nAgregar etiquetas a mapas es un ejemplo de anotar gráficos (Capítulo 8) y es compatible con geom_sf_label() y geom_sf_text(). Por ejemplo, si bien es razonable esperar que una audiencia australiana conozca los nombres de los estados australianos (y no están etiquetados en el gráfico anterior), pocos australianos conocerían los nombres de los diferentes electorados en la región metropolitana de Sydney. Entonces, para dibujar un mapa electoral de Sydney, primero necesitaríamos extraer los datos del mapa para los electorados relevantes y luego agregar la etiqueta. El siguiente gráfico se acerca a la región de Sydney especificando xlim y ylim en coord_sf() y luego usa geom_sf_label() para superponer cada electorado con una etiqueta:\n\n# Filtrar electorados en la región metropolitana de Sydney\nsydney_map &lt;- ozmaps::abs_ced %&gt;% filter(NAME %in% c(\n  \"Sydney\", \"Wentworth\", \"Warringah\", \"Kingsford Smith\", \"Grayndler\", \"Lowe\", \n  \"North Sydney\", \"Barton\", \"Bradfield\", \"Banks\", \"Blaxland\", \"Reid\", \n  \"Watson\", \"Fowler\", \"Werriwa\", \"Prospect\", \"Parramatta\", \"Bennelong\", \n  \"Mackellar\", \"Greenway\", \"Mitchell\", \"Chifley\", \"McMahon\"\n))\n\n# Dibuja el mapa electoral de Sydney\nggplot(sydney_map) + \n  geom_sf(aes(fill = NAME), show.legend = FALSE) + \n  coord_sf(xlim = c(150.97, 151.3), ylim = c(-33.98, -33.79)) + \n  geom_sf_label(aes(label = NAME), label.padding = unit(1, \"mm\"))\n#&gt; Warning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not\n#&gt; give correct results for longitude/latitude data\n\n\n\n\n\n\n\nVale la pena señalar el mensaje de advertencia. Internamente, geom_sf_label() usa la función st_point_on_surface() del paquete sf para colocar etiquetas, y el mensaje de advertencia aparece porque la mayoría de los algoritmos utilizados por sf para calcular cantidades geométricas (por ejemplo, centroides, puntos interiores) se basan en una suposición. que los puntos se encuentran sobre una superficie plana bidimensional y parametrizados con coordenadas cartesianas. Esta suposición no está estrictamente justificada y, en algunos casos (por ejemplo, regiones cercanas a los polos), los cálculos que tratan la longitud y la latitud de esta manera darán respuestas erróneas. Por este motivo, el paquete sf genera mensajes de advertencia cuando se basa en esta aproximación.\n\n\n6.2.3 Agregar otras geomas\nAunque geom_sf() es especial en algunos aspectos, se comporta de la misma manera que cualquier otra geom, lo que permite trazar datos adicionales en un mapa con geoms estándar. Por ejemplo, es posible que deseemos trazar las ubicaciones de las capitales australianas en el mapa usando geom_point(). El siguiente código ilustra cómo se hace esto:\n\noz_capitals &lt;- tibble::tribble( \n  ~city,           ~lat,     ~lon,\n  \"Sydney\",    -33.8688, 151.2093,  \n  \"Melbourne\", -37.8136, 144.9631, \n  \"Brisbane\",  -27.4698, 153.0251, \n  \"Adelaide\",  -34.9285, 138.6007, \n  \"Perth\",     -31.9505, 115.8605, \n  \"Hobart\",    -42.8821, 147.3272, \n  \"Canberra\",  -35.2809, 149.1300, \n  \"Darwin\",    -12.4634, 130.8456, \n)\n\nggplot() + \n  geom_sf(data = oz_votes) + \n  geom_sf(data = oz_states, colour = \"black\", fill = NA) + \n  geom_point(data = oz_capitals, mapping = aes(x = lon, y = lat), colour = \"red\") + \n  coord_sf()\n\n\n\n\n\n\n\nEn este ejemplo, geom_point se usa solo para especificar las ubicaciones de las ciudades capitales, pero la idea básica se puede ampliar para manejar metadatos de puntos de manera más general. Por ejemplo, si los datos de oz_capitals incluyeran una variable adicional que especificara el número de electorados dentro de cada área metropolitana, podríamos codificar esos datos utilizando la estética size.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Mapas</span>"
    ]
  },
  {
    "objectID": "maps.html#sec-mapproj",
    "href": "maps.html#sec-mapproj",
    "title": "6  Mapas",
    "section": "\n6.3 Proyecciones de mapas",
    "text": "6.3 Proyecciones de mapas\nAl comienzo del capítulo dibujamos mapas trazando la longitud y la latitud en un plano cartesiano, como si los datos geoespaciales no fueran diferentes de otros tipos de datos que uno podría querer trazar. En una primera aproximación, esto está bien, pero no es lo suficientemente bueno si lo que importa es la precisión. Hay dos problemas fundamentales con este enfoque.\nLa primera cuestión es la forma del planeta. La Tierra no es un plano ni una esfera perfecta. Como consecuencia, para asignar un valor de coordenadas (longitud y latitud) a una ubicación necesitamos hacer suposiciones sobre todo tipo de cosas. ¿Qué tan elipsoidal es la Tierra? ¿Dónde está el centro del planeta? ¿Dónde está el punto de origen de la longitud y la latitud? ¿Dónde está el nivel del mar? ¿Cómo se mueven las placas tectónicas? Todas estas cosas son relevantes y, dependiendo de las suposiciones que se hagan, la misma coordenada se puede asignar a ubicaciones que están a muchos metros de distancia. El conjunto de suposiciones sobre la forma de la Tierra se conoce como dato geodésico y, si bien puede no ser importante para algunas visualizaciones de datos, para otras es fundamental. Hay varias opciones diferentes que uno podría considerar: si su enfoque es América del Norte, el “Datum de América del Norte” (NAD83) es una buena opción, mientras que si su perspectiva es global, el “Sistema Geodésico Mundial” (WGS84) probablemente sea mejor.\nLa segunda cuestión es la forma de su mapa. La Tierra es aproximadamente elipsoidal, pero en la mayoría de los casos los datos espaciales deben dibujarse en un plano bidimensional. No es posible mapear la superficie de un elipsoide en un plano sin cierta distorsión o corte, y tendrás que elegir qué distorsiones estás dispuesto a aceptar al dibujar un mapa. Este es el trabajo de la proyección cartográfica.\nLas proyecciones cartográficas a menudo se clasifican en términos de las propiedades geométricas que conservan, p.\n\nLas proyecciones que preservan el área garantizan que las regiones de igual área en el mundo se dibujen con igual área en el mapa.\nLas proyecciones que preservan la forma (o conformes) garantizan que se conserve la forma local de las regiones.\n\nY desafortunadamente, no es posible que ninguna proyección conserve la forma y el área. Esto hace que esté un poco más allá del alcance de este libro discutir las proyecciones cartográficas en detalle, aparte de señalar que la especificación de características simples le permite indicar qué proyección cartográfica desea utilizar. Para obtener más información sobre proyecciones de mapas, consulte Geocómputo con R https://geocompr.robinlovelace.net/ (Lovelace, Nowosad, y Muenchow 2019).\nEn conjunto, el datum geodésico (p. ej., WGS84), el tipo de proyección cartográfica (p. ej., Mercator) y los parámetros de la proyección (p. ej., ubicación del origen) especifican un sistema de referencia de coordenadas, o CRS, un conjunto completo de suposiciones utilizadas para traducir la información de latitud y longitud en un mapa bidimensional. Un objeto sf a menudo incluye un CRS predeterminado, como se ilustra a continuación:\n\nst_crs(oz_votes)\n#&gt; Coordinate Reference System:\n#&gt;   User input: EPSG:4283 \n#&gt;   wkt:\n#&gt; GEOGCRS[\"GDA94\",\n#&gt;     DATUM[\"Geocentric Datum of Australia 1994\",\n#&gt;         ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#&gt;             LENGTHUNIT[\"metre\",1]]],\n#&gt;     PRIMEM[\"Greenwich\",0,\n#&gt;         ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;     CS[ellipsoidal,2],\n#&gt;         AXIS[\"geodetic latitude (Lat)\",north,\n#&gt;             ORDER[1],\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;         AXIS[\"geodetic longitude (Lon)\",east,\n#&gt;             ORDER[2],\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;     USAGE[\n#&gt;         SCOPE[\"Horizontal component of 3D system.\"],\n#&gt;         AREA[\"Australia including Lord Howe Island, Macquarie Islands, Ashmore and Cartier Islands, Christmas Island, Cocos (Keeling) Islands, Norfolk Island. All onshore and offshore.\"],\n#&gt;         BBOX[-60.56,93.41,-8.47,173.35]],\n#&gt;     ID[\"EPSG\",4283]]\n\nLa mayor parte de este resultado corresponde a una cadena de texto conocido (WKT) que describe sin ambigüedades el CRS. sf utiliza esta representación detallada de WKT internamente, pero hay varias formas de proporcionar información al usuario que sf comprenda. Uno de esos métodos es proporcionar entrada numérica en forma de código EPSG (consulte https://epsg.org/home.html). El CRS predeterminado en los datos oz_votes corresponde al código EPSG 4283: El CRS predeterminado en los datos oz_votes corresponde al código EPSG 4283:\n\nst_crs(oz_votes) == st_crs(4283)\n#&gt; [1] TRUE\n\nEn ggplot2, el CRS está controlado por coord_sf(), lo que garantiza que cada capa del gráfico utilice la misma proyección. Por defecto, coord_sf() usa el CRS asociado con la columna de geometría de los datos1. Dado que los datos de ciencia ficción suelen ofrecer una opción sensata de CRS, este proceso normalmente se desarrolla de forma invisible y no requiere intervención del usuario. Sin embargo, si necesita configurar el CRS usted mismo, puede especificar el parámetro crs pasando una entrada de usuario válida a st_crs(). El siguiente ejemplo ilustra cómo cambiar del CRS predeterminado al código EPSG 3112:\nggplot(oz_votes) + geom_sf()\nggplot(oz_votes) + geom_sf() + coord_sf(crs = st_crs(3112))",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Mapas</span>"
    ]
  },
  {
    "objectID": "maps.html#sec-sfdetail",
    "href": "maps.html#sec-sfdetail",
    "title": "6  Mapas",
    "section": "\n6.4 Trabajar con datos sf",
    "text": "6.4 Trabajar con datos sf\nComo se señaló anteriormente, los mapas creados usando geom_sf() y coord_sf() dependen en gran medida de las herramientas proporcionadas por el paquete sf y, de hecho, el paquete sf contiene muchas más herramientas útiles para manipular datos de características simples. En esta sección proporcionamos una introducción a algunas de estas herramientas; Puede encontrar una cobertura más detallada en el sitio web del paquete SF https://r-spatial.github.io/sf/.\nPara comenzar, recuerde que una ventaja de las características simples sobre otras representaciones de datos espaciales es que las unidades geográficas pueden tener una estructura complicada. Un buen ejemplo de esto en los datos de los mapas australianos es el distrito electoral de Eden-Monaro, que se muestra a continuación:\nedenmonaro &lt;- ozmaps::abs_ced %&gt;% filter(NAME == \"Eden-Monaro\")\n\np &lt;- ggplot(edenmonaro) + geom_sf()\np + coord_sf(xlim = c(147.75, 150.25), ylim = c(-37.5, -34.5)) \np + coord_sf(xlim = c(150, 150.25), ylim = c(-36.3, -36)) \n\n\n\n\n\n\n\n\n\n\nComo lo ilustra esto, Eden-Monaro se define en términos de dos polígonos distintos, uno grande en el continente australiano y una isla pequeña. Sin embargo, la gran región tiene un agujero en el medio (el agujero existe porque el Territorio de la Capital Australiana es una unidad política distinta que está totalmente contenida dentro de Eden-Monaro y, como se ilustra arriba, las fronteras electorales en Australia no cruzan las fronteras estatales). En terminología sf, este es un ejemplo de geometría MULTIPOLYGON. En esta sección hablaremos sobre la estructura de estos objetos y cómo trabajar con ellos.\nPrimero, usemos dplyr para tomar solo el objeto de geometría:\n\nedenmonaro &lt;- edenmonaro %&gt;% pull(geometry)\n\nSe puede acceder a los metadatos del objeto edenmonaro mediante funciones auxiliares. Por ejemplo, st_geometry_type() extrae el tipo de geometría (por ejemplo, MULTIPOLYGON), st_dimension() extrae el número de dimensiones (2 para datos XY, 3 para XYZ), st_bbox() extrae el cuadro delimitador como un vector numérico, y st_crs() extrae el CRS como una lista con dos componentes, uno para el código EPSG y el otro para proj4string. Por ejemplo:\n\nst_bbox(edenmonaro)\n#&gt;  xmin  ymin  xmax  ymax \n#&gt; 147.7 -37.5 150.2 -34.5\n\nNormalmente, cuando imprimimos el objeto edenmonaro, la salida mostrará toda la información adicional (dimensión, cuadro delimitador, dato geodésico, etc.), pero durante el resto de esta sección mostraremos solo las líneas relevantes de la salida. En este caso, edenmonaro está definido por una geometría MULTIPOLYGON que contiene una característica:\n\nedenmonaro \n#&gt; Geometry set for 1 feature \n#&gt; Geometry type: MULTIPOLYGON\n#&gt; MULTIPOLYGON (((150 -36.2, 150 -36.2, 150 -36.3...\n\nSin embargo, podemos “fundir” el MULTIPOLYGON en las dos geometrías POLYGON distintas a partir de las cuales está construido usando st_cast():\n\nst_cast(edenmonaro, \"POLYGON\")\n#&gt; Geometry set for 2 features \n#&gt; Geometry type: POLYGON\n#&gt; POLYGON ((150 -36.2, 150 -36.2, 150 -36.3, 150 ...\n#&gt; POLYGON ((148 -36.7, 148 -36.7, 148 -36.7, 148 ...\n\nPara ilustrar cuándo esto podría ser útil, consideremos el electorado de Dawson, que consta de 69 islas además de una región costera en el continente australiano.\n\ndawson &lt;- ozmaps::abs_ced %&gt;% \n  filter(NAME == \"Dawson\") %&gt;% \n  pull(geometry)\ndawson\n#&gt; Geometry set for 1 feature \n#&gt; Geometry type: MULTIPOLYGON\n#&gt; MULTIPOLYGON (((148 -19.9, 148 -19.8, 148 -19.8...\n\nggplot(dawson) + \n  geom_sf() +\n  coord_sf()\n\n\n\n\n\n\n\nSupongamos, sin embargo, que nuestro interés es sólo cartografiar las islas. Si es así, primero podemos usar la función st_cast() para dividir el electorado de Dawson en los polígonos constituyentes. Después de hacerlo, podemos usar st_area() para calcular el área de cada polígono y which.max() para encontrar el polígono con área máxima:\n\ndawson &lt;- st_cast(dawson, \"POLYGON\")\nwhich.max(st_area(dawson))\n#&gt; [1] 69\n\nLa gran región continental corresponde al polígono 69 dentro de Dawson. Armados con este conocimiento, podemos dibujar un mapa que muestre solo las islas:\n\nggplot(dawson[-69]) + \n  geom_sf() + \n  coord_sf()",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Mapas</span>"
    ]
  },
  {
    "objectID": "maps.html#sec-rastermaps",
    "href": "maps.html#sec-rastermaps",
    "title": "6  Mapas",
    "section": "\n6.5 Mapas ráster",
    "text": "6.5 Mapas ráster\n\nUna segunda forma de proporcionar información geoespacial para la cartografía es confiar en datos ráster. A diferencia del formato de entidades simples, en el que las entidades geográficas se especifican en términos de un conjunto de líneas, puntos y polígonos, los rásteres toman la forma de imágenes. En el caso más simple, los datos ráster pueden no ser más que un archivo de mapa de bits, pero existen muchos formatos de imagen diferentes. Específicamente en el contexto geoespacial, existen formatos de imágenes que incluyen metadatos (por ejemplo, datos geodésicos, sistema de referencia de coordenadas) que se pueden usar para mapear la información de la imagen en la superficie de la Tierra. Por ejemplo, un formato común es GeoTIFF, que es un archivo TIFF normal con metadatos adicionales. Afortunadamente, la mayoría de los formatos se pueden leer fácilmente en R con la ayuda de GDAL (la Biblioteca de abstracción de datos geoespaciales, https://gdal.org/). Por ejemplo, el paquete sf contiene una función sf::gdal_read() que proporciona acceso a los controladores ráster GDAL desde R. Sin embargo, rara vez es necesario llamar a esta función directamente, ya que existen otras funciones de alto nivel que se encargan de esto. para ti.\nComo ilustración, usaremos una imagen de satélite tomada por el satélite geoestacionario Himawari-8 operado por la Agencia Meteorológica de Japón y obtenida originalmente del sitio web de la Oficina Australiana de Meteorología. Esta imagen está almacenada en un archivo GeoTIFF llamado “IDE00422.202001072100.tif”.2 Para importar estos datos a R, usaremos el paquete de estrellas (Pebesma 2020) para crear objetos de estrellas:\n\nlibrary(stars)\n#&gt; Loading required package: abind\nsat_vis &lt;- read_stars(\n  \"IDE00422.202001072100.tif\", \n  RasterIO = list(nBufXSize = 600, nBufYSize = 600)\n)\n\nEn el código anterior, el primer argumento especifica la ruta al archivo ráster y el argumento RasterIO se usa para pasar una lista de parámetros de bajo nivel a GDAL. En este caso, hemos utilizado nBufXSize y nBufYSize para garantizar que R lea los datos en baja resolución (como una imagen de 600x600 píxeles). Para ver qué información ha importado R, podemos inspeccionar el objeto sat_vis:\n\nsat_vis\n#&gt; stars object with 3 dimensions and 1 attribute\n#&gt; attribute(s), summary of first 1e+05 cells:\n#&gt;                            Min. 1st Qu. Median Mean 3rd Qu. Max.\n#&gt; IDE00422.202001072100.tif     0       0      0 18.1       0  255\n#&gt; dimension(s):\n#&gt;      from  to   offset  delta                  refsys point x/y\n#&gt; x       1 600 -5500000  18333 Geostationary_Satellite FALSE [x]\n#&gt; y       1 600  5500000 -18333 Geostationary_Satellite FALSE [y]\n#&gt; band    1   3       NA     NA                      NA    NA\n\nEste resultado nos dice algo sobre la estructura de un objeto estrella. Para el objeto sat_vis, los datos subyacentes se almacenan como una matriz tridimensional, con las dimensiones x e y que especifican los datos espaciales. La dimensión band en este caso corresponde al canal de color (RGB), pero es redundante para esta imagen ya que los datos están en escala de grises. En otros conjuntos de datos puede haber bandas correspondientes a diferentes sensores y posiblemente también una dimensión temporal. Tenga en cuenta que los datos espaciales también están asociados con un sistema de referencia de coordenadas (denominado “refsys” en el resultado).\nPara trazar los datos sat_vis en ggplot2, podemos usar la función geom_stars() proporcionada por el paquete stars. Un gráfico mínimo podría verse así:\n\nggplot() + \n  geom_stars(data = sat_vis) + \n  coord_equal()\n\n\n\n\n\n\n\nLa función geom_stars() requiere que el argumento data sea un objeto de estrellas y asigna los datos ráster a la estética de relleno. En consecuencia, el sombreado azul en la imagen de satélite de arriba está determinado por la escala ggplot2, no por la imagen en sí. Es decir, aunque sat_vis contiene tres bandas, el gráfico anterior solo muestra la primera, y los valores de datos sin procesar (que van de 0 a 255) se asignan a la paleta azul predeterminada que usa ggplot2 para datos continuos. Para ver cómo se ve “realmente” el archivo de imagen, podemos separar las bandas usando facet_wrap():\n\nggplot() + \n  geom_stars(data = sat_vis, show.legend = FALSE) +\n  facet_wrap(vars(band)) + \n  coord_equal() + \n  scale_fill_gradient(low = \"black\", high = \"white\")\n\n\n\n\n\n\n\nUna limitación para mostrar solo la imagen sin procesar es que no es fácil determinar dónde están las masas de tierra relevantes y es posible que deseemos superponer los datos satelitales con el mapa vectorial oz_states para mostrar los contornos de las entidades políticas australianas. Sin embargo, se requiere cierto cuidado al hacerlo porque las dos fuentes de datos están asociadas con diferentes sistemas de referencia de coordenadas. Para proyectar los datos oz_states correctamente, los datos deben transformarse usando la función st_transform() del paquete sf. En el código siguiente, extraemos el CRS del objeto ráster sat_vis y transformamos los datos oz_states para usar el mismo sistema.\n\noz_states &lt;- st_transform(oz_states, crs = st_crs(sat_vis))\n\nUna vez hecho esto, ahora podemos dibujar el mapa vectorial sobre la parte superior de la imagen rasterizada para que la imagen sea más interpretable para el lector. Ahora se desprende claramente de la inspección que la imagen de satélite fue tomada durante el amanecer en Australia:\n\nggplot() + \n  geom_stars(data = sat_vis, show.legend = FALSE) +\n  geom_sf(data = oz_states, fill = NA, color = \"white\") + \n  coord_sf() + \n  theme_void() + \n  scale_fill_gradient(low = \"black\", high = \"white\")\n\n\n\n\n\n\n\n¿Qué pasaría si quisiéramos trazar datos más convencionales en la parte superior? Un ejemplo sencillo de esto sería trazar las ubicaciones de las capitales australianas según el marco de datos oz_capitals que contiene datos de latitud y longitud. Sin embargo, debido a que estos datos no están asociados con un CRS y no están en la misma escala que los datos ráster en sat_vis, también deberán transformarse. Para hacerlo, primero necesitamos crear un objeto sf a partir de los datos de oz_capitals usando st_as_sf():\n\ncities &lt;- oz_capitals %&gt;% \n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326, remove = FALSE)\n\nEsta proyección se establece utilizando el código EPSG 4326, una proyección elipsoidal que utiliza los valores de latitud y longitud como coordenadas y se basa en el datum WGS84. Una vez hecho esto, ahora podemos transformar las coordenadas de la geometría de latitud-longitud para que coincidan con la geometría de nuestros datos sat_vis:\n\ncities &lt;- st_transform(cities, st_crs(sat_vis))\n\nLos datos transformados ahora se pueden superponer usando geom_sf():\n\nggplot() + \n  geom_stars(data = sat_vis, show.legend = FALSE) +\n  geom_sf(data = oz_states, fill = NA, color = \"white\") + \n  geom_sf(data = cities, color = \"red\") + \n  coord_sf() + \n  theme_void() + \n  scale_fill_gradient(low = \"black\", high = \"white\")\n\n\n\n\n\n\n\nEsta versión de la imagen deja más claro que la imagen de satélite fue tomada aproximadamente al amanecer en Darwin: el sol había salido en todas las ciudades del este, pero no en Perth. Esto podría aclararse en la visualización de datos usando la función geom_sf_text() para agregar etiquetas a cada ciudad. Por ejemplo, podríamos agregar otra capa al gráfico usando un código como este:\n\ngeom_sf_text(data = cities, mapping = aes(label = city)) \n\naunque se requeriría algo de cuidado para asegurar que el texto esté bien colocado (ver Capítulo 8).",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Mapas</span>"
    ]
  },
  {
    "objectID": "maps.html#fuentes-de-datos",
    "href": "maps.html#fuentes-de-datos",
    "title": "6  Mapas",
    "section": "\n6.6 Fuentes de datos",
    "text": "6.6 Fuentes de datos\n\nEl paquete de límites de EE.UU., https://github.com/ropensci/USAboundaries contiene datos de estado, condado y código postal de EE. UU. (Mullen y Bratt 2018). Además de los límites actuales, también tiene límites estatales y de condado que se remontan al siglo XVII.\nEl paquete tigris, https://github.com/walkerke/tigris, facilita el acceso a los archivos de forma TIGRIS del censo de EE. UU. (Walker 2019). Contiene límites de estados, condados, códigos postales y zonas censales, así como muchos otros conjuntos de datos útiles.\nEl paquete rnaturalearth (South 2017) reúne los datos gratuitos y de alta calidad de https://naturalearthdata.com/. Contiene las fronteras de los países y las fronteras de la región de nivel superior dentro de cada país (por ejemplo, estados de EE. UU., regiones de Francia, condados del Reino Unido).\nEl paquete osmar, https://cran.r-project.org/package=osmar resume la API de OpenStreetMap para que pueda acceder a una amplia gama de datos vectoriales, incluidas calles y edificios individuales (Eugster y Schlesinger 2010).\nSi tienes tus propios archivos de formas (.shp) puedes cargarlos en R con sf::read_sf().\n\n\n\n\n\nEugster, Manuel J. A., y Thomas Schlesinger. 2010. «osmar: OpenStreetMap and R». R Journal. http://osmar.r-forge.r-project.org/RJpreprint.pdf.\n\n\nLovelace, Robin, Jakub Nowosad, y Jannes Muenchow. 2019. Geocomputation with R. CRC Press.\n\n\nMullen, Lincoln A., y Jordan Bratt. 2018. «USAboundaries: Historical and Contemporary Boundaries of the United States of America». Journal of Open Source Software 3: 314. https://doi.org/10.21105/joss.00314.\n\n\nPebesma, Edzer. 2018. «Simple Features for R: Standardized Support for Spatial Vector Data». The R Journal 10 (1): 439-46. https://doi.org/10.32614/RJ-2018-009.\n\n\n———. 2020. stars: Spatiotemporal Arrays, Raster and Vector Data Cubes.\n\n\nSouth, Andy. 2017. rnaturalearth: World Map Data from Natural Earth. https://CRAN.R-project.org/package=rnaturalearth.\n\n\nSumner, Michael. 2019. ozmaps: Australia Maps. https://CRAN.R-project.org/package=ozmaps.\n\n\nTeucher, Andy, y Kenton Russell. 2018. rmapshaper: Client for ’mapshaper’ for ’Geospatial’ Operations. https://CRAN.R-project.org/package=rmapshaper.\n\n\nWalker, Kyle. 2019. tigris: Load Census TIGER/Line Shapefiles. https://CRAN.R-project.org/package=tigris.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Mapas</span>"
    ]
  },
  {
    "objectID": "maps.html#footnotes",
    "href": "maps.html#footnotes",
    "title": "6  Mapas",
    "section": "",
    "text": "Si hay varios conjuntos de datos con un CRS asociado diferente, utiliza el CRS de la primera capa.↩︎\nSi desea probar este código usted mismo, puede encontrar una copia de la imagen en el repositorio de GitHub del libro: https://github.com/hadley/ggplot2-book/raw/master/IDE00422.202001072100.tif.↩︎",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Mapas</span>"
    ]
  },
  {
    "objectID": "networks.html",
    "href": "networks.html",
    "title": "7  Redes",
    "section": "",
    "text": "7.1 ¿Qué son los datos de red?\nAl igual que los mapas y los datos espaciales, las redes y los gráficos ocupan una parte especial del panorama de la visualización, pero mientras que los datos espaciales difieren en su mayoría de los trazados regulares en el uso de proyecciones, las redes aportan su propia estructura de datos, así como sus propios paradigmas de visualización. Debido a estas complicaciones, las redes no son compatibles directamente con ggplot2. Varios esfuerzos a lo largo de los años han intentado agregar esta pieza faltante y en este capítulo veremos cómo usar ggraph para visualización de redes. Otros paquetes que ofrecen algunas de las mismas funciones incluyen geomnet, ggnetwork, y GGally para gráficas de redes regulares, y ggtree y ggdendro para visualización de árboles específicamente.\nLas redes (o gráficos como se llama su concepto matemático) son datos que constan de entidades (nodos o vértices) y su relación (bordes o enlaces). Tanto los nodos como los bordes pueden tener datos adicionales adjuntos y, además, los bordes pueden considerarse dirigidos o no dirigidos dependiendo de la naturaleza de la conexión (una red que codifica amistad mutua tendría bordes no dirigidos, mientras que una red ancestral tendrá bordes dirigidos porque hijo de  no es una relación simétrica).\nLa naturaleza de los datos de la red significa que no se pueden representar fácilmente en un único marco de datos, lo cual es una de las complicaciones clave de su uso con ggplot2. Sin embargo, se puede codificar como dos marcos de datos interrelacionados, uno que codifica los nodos y el otro que codifica los bordes. Este es el enfoque utilizado en tidygraph, que es el paquete de manipulación de datos subyacente a ggraph. Por lo tanto, para hacer un mejor uso de ggraph es beneficioso comprender un poco sobre tidygraph.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Redes</span>"
    ]
  },
  {
    "objectID": "networks.html#qué-son-los-datos-de-red",
    "href": "networks.html#qué-son-los-datos-de-red",
    "title": "7  Redes",
    "section": "",
    "text": "7.1.1 Una API de manipulación de red ordenada\ntidygraph puede considerarse, ante todo, una API de dplyr para datos de red, que permite la misma semántica para manipular redes que se conoce en dplyr. Se puede ver un ejemplo de esto a continuación, donde creamos un gráfico aleatorio utilizando el método de muestreo Erdős-Rényi, asignamos una etiqueta aleatoria a los nodos y clasificamos los bordes según la etiqueta de su nodo de origen.\n\nlibrary(tidygraph)\n\ngraph &lt;- play_erdos_renyi(n = 10, p = 0.2) %&gt;% \n  activate(nodes) %&gt;% \n  mutate(class = sample(letters[1:4], n(), replace = TRUE)) %&gt;% \n  activate(edges) %&gt;% \n  arrange(.N()$class[from])\n#&gt; Warning: `play_erdos_renyi()` was deprecated in tidygraph 1.3.0.\n#&gt; ℹ Please use `play_gnp()` instead.\n\ngraph\n#&gt; # A tbl_graph: 10 nodes and 18 edges\n#&gt; #\n#&gt; # A directed simple graph with 1 component\n#&gt; #\n#&gt; # Edge Data: 18 × 2 (active)\n#&gt;    from    to\n#&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1     9     2\n#&gt; 2     5    10\n#&gt; 3     8     5\n#&gt; 4     8    10\n#&gt; 5     9     8\n#&gt; 6     9    10\n#&gt; # ℹ 12 more rows\n#&gt; #\n#&gt; # Node Data: 10 × 1\n#&gt;   class\n#&gt;   &lt;chr&gt;\n#&gt; 1 a    \n#&gt; 2 d    \n#&gt; 3 c    \n#&gt; # ℹ 7 more rows\n\nSi bien mutate(), arrange() y n() son bien conocidos, podemos ver algunas funciones nuevas que necesitan explicación: activate() informa a tidygraph en qué parte de la red deseas trabajar en, ya sea nodes o edges. Además, vemos el uso de .N() que da acceso a los datos del nodo del gráfico actual incluso cuando se trabaja con los bordes (también hay una función correspondiente .E() para acceder a los datos de los bordes, y . .G() para acceder a todo el gráfico).\n\n7.1.2 Conversión\nLos datos de la red a menudo se presentan en una variedad de formatos diferentes dependiendo de dónde se obtengan. tidygraph comprende la mayoría de las diferentes clases utilizadas en R para datos de red y estas se pueden convertir usando as_tbl_graph(). A continuación se muestra un ejemplo de conversión de un marco de datos codificado como lista de bordes, así como de conversión del resultado de hclust().\n\ndata(highschool, package = \"ggraph\")\nhead(highschool)\n#&gt;   from to year\n#&gt; 1    1 14 1957\n#&gt; 2    1 15 1957\n#&gt; 3    1 21 1957\n#&gt; 4    1 54 1957\n#&gt; 5    1 55 1957\n#&gt; 6    2 21 1957\n\n\nhs_graph &lt;- as_tbl_graph(highschool, directed = FALSE)\nhs_graph\n#&gt; # A tbl_graph: 70 nodes and 506 edges\n#&gt; #\n#&gt; # An undirected multigraph with 1 component\n#&gt; #\n#&gt; # Node Data: 70 × 0 (active)\n#&gt; #\n#&gt; # Edge Data: 506 × 3\n#&gt;    from    to  year\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1    13  1957\n#&gt; 2     1    14  1957\n#&gt; 3     1    20  1957\n#&gt; # ℹ 503 more rows\n\n\nluv_clust &lt;- hclust(dist(luv_colours[, 1:3]))\nluv_graph &lt;- as_tbl_graph(luv_clust)\nluv_graph\n#&gt; # A tbl_graph: 1313 nodes and 1312 edges\n#&gt; #\n#&gt; # A rooted tree\n#&gt; #\n#&gt; # Node Data: 1,313 × 4 (active)\n#&gt;   height leaf  label members\n#&gt;    &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;   &lt;int&gt;\n#&gt; 1     0  TRUE  \"101\"       1\n#&gt; 2     0  TRUE  \"427\"       1\n#&gt; 3   778. FALSE \"\"          2\n#&gt; 4     0  TRUE  \"571\"       1\n#&gt; 5     0  TRUE  \"426\"       1\n#&gt; 6     0  TRUE  \"424\"       1\n#&gt; # ℹ 1,307 more rows\n#&gt; #\n#&gt; # Edge Data: 1,312 × 2\n#&gt;    from    to\n#&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1     3     1\n#&gt; 2     3     2\n#&gt; 3     8     6\n#&gt; # ℹ 1,309 more rows\n\nPodemos ver que tidygraph agrega automáticamente información adicional al realizar la conversión, p. la columna year en los datos de la escuela secundaria y las propiedades label y leaft de los nodos en la agrupación jerárquica.\n\n7.1.3 Algoritmos\nSi bien simplemente manipular las redes es agradable, el beneficio real de las redes proviene de las diferentes operaciones que se pueden realizar en ellas utilizando la estructura subyacente. tidygraph tiene un amplio soporte para una variedad de diferentes grupos de algoritmos, como cálculo de centralidad (qué nodo es más central), clasificación (ordenar los nodos para que estén ubicados cerca de aquellos a los que están conectados), agrupación (encontrar clústeres dentro de la red), etc. La API del algoritmo está diseñada para usarse dentro de mutate() y siempre devolverá un vector con una longitud y un orden que coincidan con los nodos o bordes. Además, no requiere que especifiques el gráfico o los nodos que deseas calcular, ya que esto se proporciona implícitamente en la llamada mutate(). Como ejemplo, calcularemos la centralidad de los nodos en nuestro gráfico de muestra usando el algoritmo PageRank y ordenaremos los nodos de acuerdo con eso:\n\ngraph %&gt;% \n  activate(nodes) %&gt;% \n  mutate(centrality = centrality_pagerank()) %&gt;% \n  arrange(desc(centrality))\n#&gt; # A tbl_graph: 10 nodes and 18 edges\n#&gt; #\n#&gt; # A directed simple graph with 1 component\n#&gt; #\n#&gt; # Node Data: 10 × 2 (active)\n#&gt;   class centrality\n#&gt;   &lt;chr&gt;      &lt;dbl&gt;\n#&gt; 1 c         0.220 \n#&gt; 2 a         0.165 \n#&gt; 3 c         0.140 \n#&gt; 4 a         0.128 \n#&gt; 5 c         0.128 \n#&gt; 6 a         0.0703\n#&gt; # ℹ 4 more rows\n#&gt; #\n#&gt; # Edge Data: 18 × 2\n#&gt;    from    to\n#&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1     6     7\n#&gt; 2     2     1\n#&gt; 3     8     2\n#&gt; # ℹ 15 more rows\n\n\n7.1.4 ¿Quieren más?\nEsto es sólo un breve vistazo a tidygraph, con el fin de comprender ggraph. Si está interesado en obtener más información, el sitio web de tidygraph ofrece una descripción general de todas las funcionalidades del paquete: https://tidygraph.data-imaginist.com",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Redes</span>"
    ]
  },
  {
    "objectID": "networks.html#visualizando-redes",
    "href": "networks.html#visualizando-redes",
    "title": "7  Redes",
    "section": "\n7.2 Visualizando redes",
    "text": "7.2 Visualizando redes\nggraph se basa en tidygraph y ggplot2 para permitir una gramática de gráficos completa y familiar para datos de red. Aún así, es un poco diferente de la mayoría de los paquetes de extensión ggplot2 ya que funciona con otro tipo de datos que es fundamentalmente diferente de los datos tabulares. Más aún, la mayoría de las visualizaciones de redes no se preocupan por asignar variables a la estética x e y, ya que se preocupan por mostrar la topología de la red más que las relaciones entre dos variables. Para mostrar la topología de la red, se emplea el concepto de diseños. Los diseños son algoritmos que utilizan la estructura de la red para calcular (a menudo arbitrarios) los valores x e y para cada nodo que luego pueden usarse con fines de visualización. Para decirlo de otra manera, al trazar datos tabulares, la estética x e y casi siempre se asignan a variables existentes en los datos (o transformaciones estadísticas de datos existentes), mientras que al trazar datos de red x e y. se asignan a valores derivados de la topología de la red y que por sí solos no tienen sentido.\n\n7.2.1 Configurar la visualización\nMientras que un gráfico ggplot2 normal se inicializa con una llamada ggplot(), un gráfico ggraph se inicializa con una llamada ggraph(). El primer argumento son los datos, que pueden ser un tbl_graph o cualquier objeto convertible en uno. El segundo argumento es una función de diseño y cualquier argumento adicional se pasará a esa función. El diseño predeterminado elegirá un diseño apropiado según el tipo de gráfico que proporcione, pero si bien suele ser un punto de partida decente, siempre debe tomar el control y explorar los diferentes diseños disponibles. Las redes son conocidas por su capacidad para mostrar imágenes no gráficas. Relaciones existentes o exageradas en algunos diseños. Hay más diseños que los descritos en esta sección. La Guía de introducción a los diseños le brindará aún más información y le mostrará todos los diferentes diseños proporcionados por ggraph.\n\n7.2.1.1 Especificación de un diseño\nEl argumento de diseño puede tomar una cadena o una función. Si se proporciona una cadena, el nombre coincidirá con uno de los diseños integrados (de los cuales hay muchos). Si se proporciona una función, se supone que la función toma un tbl_graph y devuelve un marco de datos con al menos una columna xey y con el mismo número de filas que nodos en el gráfico de entrada. A continuación podemos ver ejemplos de cómo usar el diseño predeterminado, especificar un diseño específico y proporcionar argumentos para el diseño (que se evalúan en el contexto del gráfico de entrada):\n\nlibrary(ggraph)\nggraph(hs_graph) + \n  geom_edge_link() + \n  geom_node_point()\n#&gt; Using \"stress\" as default layout\n\n\n\n\n\n\n\n\nggraph(hs_graph, layout = \"drl\") + \n  geom_edge_link() + \n  geom_node_point()\n\n\n\n\n\n\n\n\nhs_graph &lt;- hs_graph %&gt;% \n  activate(edges) %&gt;% \n  mutate(edge_weights = runif(n()))\nggraph(hs_graph, layout = \"stress\", weights = edge_weights) + \n  geom_edge_link(aes(alpha = edge_weights)) + \n  geom_node_point() + \n  scale_edge_alpha_identity()\n\n\n\n\n\n\n\nPara mostrar el gráfico de arriba estamos usando las funciones geom_edge_link() y geom_node_point(), y aunque todavía no las hemos discutido, hacen exactamente lo que puedas imaginar: dibujar nodos como puntos y bordes como líneas rectas. .\n\n7.2.1.2 Circularidad\nAlgunos diseños se pueden utilizar tanto en versión lineal como circular. La forma correcta de cambiar esto en ggplot2 sería usar coord_polar() para cambiar el sistema de coordenadas, pero como solo queremos cambiar la posición de los nodos en el diseño y no afectar los bordes, esto es una función del disposición. Lo siguiente puede mostrar la diferencia:\n\nggraph(luv_graph, layout = \"dendrogram\", circular = TRUE) + \n  geom_edge_link() + \n  coord_fixed()\n\n\n\n\n\n\n\n\nggraph(luv_graph, layout = \"dendrogram\") + \n  geom_edge_link() + \n  coord_polar() + \n  scale_y_reverse()\n\n\n\n\n\n\n\nComo podemos ver, usar coord_polar() doblará nuestros bordes, lo cual no es una opción deseable.\n\n7.2.2 Nodos de dibujo\nDe los dos tipos de datos almacenados en un gráfico, los nodos son, con diferencia, los que más se parecen a lo que estamos acostumbrados a representar. Después de todo, a menudo se muestran como puntos de forma muy parecida a como se muestran las observaciones en un diagrama de dispersión. Si bien conceptualmente es simple, todavía no cubriremos todo lo que hay que saber sobre los nodos, por lo que, al igual que con los diseños, el lector interesado debe consultar la Guía de introducción a los nodos para aprender más. Todas las geoms de dibujo de nodos en ggraph tienen el prefijo geom_node_ y el que es más probable que uses con más frecuencia es geom_node_point(). Si bien superficialmente puede parecerse mucho geom_point() tiene algunas características adicionales que comparte con todas las geomas de nodos y bordes. Primero, no es necesario especificar la estética x e y. Estos vienen dados por el diseño y su mapeo está implícito. En segundo lugar, tienes acceso a una estética de filter que te permite desactivar el dibujo de nodos específicos. En tercer lugar, puede utilizar cualquier algoritmo de tidygraph dentro de aes() y se evaluarán en el gráfico que se visualiza. Para ver esto en acción, trazamos nuestro gráfico de secundaria nuevamente, pero esta vez solo muestra los nodos con más de 2 conexiones y coloreados según su centralidad de poder:\n\nggraph(hs_graph, layout = \"stress\") + \n  geom_edge_link() + \n  geom_node_point(\n    aes(filter = centrality_degree() &gt; 2, \n        colour = centrality_power()),\n    size = 4\n  )\n\n\n\n\n\n\n\nPoder usar algoritmos directamente dentro del código de visualización es una forma poderosa de iterar en su visualización, ya que no necesita regresar y cambiar el gráfico de entrada.\nAparte de los puntos, hay geoms más especializados, muchos de ellos vinculados a un tipo específico de diseño. Si uno desea dibujar un mapa de árbol, se necesita geom_node_tile():\n\nggraph(luv_graph, layout = \"treemap\") + \n  geom_node_tile(aes(fill = depth))\n#&gt; Warning: Existing variables `height` and `leaf` overwritten by layout variables\n\n\n\n\n\n\n\n\n7.2.3 Bordes de dibujo\nLas geoms de borde tienen muchas más características que las geoms de nodo, principalmente porque hay muchas formas diferentes de conectar dos cosas. No hay forma de abarcarlo todo, tanto en términos de los diferentes tipos de geoms, como de la funcionalidad común que tienen. La Guía de introducción a los bordes ofrecerá una descripción completa.\nYa hemos visto geom_edge_link() en acción, que dibuja una línea recta entre los nodos conectados, pero puede hacer más de lo que ya hemos visto. Debajo del capó, dividirá la línea en un montón de pequeños fragmentos y es posible usarlo para dibujar un degradado a lo largo del borde, por ejemplo. para mostrar dirección:\n\nggraph(graph, layout = \"stress\") + \n  geom_edge_link(aes(alpha = after_stat(index)))\n\n\n\n\n\n\n\nSi está dibujando muchos bordes, esta expansión puede consumir mucho tiempo y ggraph proporciona una versión con el sufijo 0 que lo dibuja como una geom simple (y no le permite dibujar gradientes). Además, para el caso especial en el que desea interpolar entre dos valores en los puntos finales (por ejemplo, variables en los nodos), también existe una versión con el sufijo 2:\n\nggraph(graph, layout = \"stress\") + \n  geom_edge_link2(\n    aes(colour = node.class), \n    width = 3,\n    lineend = \"round\")\n\n\n\n\n\n\n\nEl uso de la variable node.class puede sorprenderte. Las geoms de borde tienen acceso a las variables de los nodos terminales a través de variables con prefijos especiales. Para las versiones estándar y 0, están disponibles a través de las variables con prefijo node1. y node2., y para la versión 2, están disponibles a través de las variables con prefijo node. (como se usó anteriormente). Las tres versiones de geoms de borde son comunes a todos los tipos de geoms de borde, no solo a geom_edge_link().\nHay más formas de dibujar bordes que simples líneas rectas. Algunos son específicos de árboles o diseños específicos, pero muchos son de uso general. Un caso de uso específico para otro tipo de borde es cuando hay múltiples bordes entre los mismos nodos. Dibujarlos como líneas rectas oscurecerá la multiplicidad de los bordes, que es, por ejemplo, evidente con el gráfico de la escuela secundaria donde están presentes múltiples bordes paralelos pero invisibles en los gráficos anteriores. Para mostrar bordes paralelos, puede usar geom_edge_fan() o geom_edge_parallel():\n\nggraph(hs_graph, layout = \"stress\") + \n  geom_edge_fan()\n\n\n\n\n\n\n\n\nggraph(hs_graph, layout = \"stress\") + \n  geom_edge_parallel()\n\n\n\n\n\n\n\nEstá claro que estas geoms sólo deben usarse para gráficos relativamente simples, ya que aumentan la cantidad de desorden y sobretrazado en el gráfico. Al observar los árboles y específicamente los dendrogramas, un tipo de borde comúnmente utilizado es el borde del codo:\n\nggraph(luv_graph, layout = \"dendrogram\", height = height) + \n  geom_edge_elbow()\n\n\n\n\n\n\n\ngeom_edge_bend() y geom_edge_diagonal() son versiones más suaves de esto.\n\n7.2.3.1 Recortar bordes alrededor de los nodos.\nUn problema común, especialmente cuando se utilizan flechas para mostrar la direccionalidad de los bordes, es que el nodo se superpondrá al borde porque corre hacia el centro del nodo, no hacia el borde del punto que muestra el nodo. Esto se puede ver a continuación:\n\nggraph(graph, layout = \"stress\") + \n  geom_edge_link(arrow = arrow()) + \n  geom_node_point(aes(colour = class), size = 8)\n\n\n\n\n\n\n\nObviamente, nos gustaría que los bordes se detuvieran antes de llegar al punto para que la flecha no quede oculta. Esto es posible en ggraph usando la estética start_cap y end_cap que le permiten especificar una región de recorte alrededor de los nodos terminales. Para arreglar el gráfico anterior, estableceríamos una región de recorte circular del tamaño correcto alrededor de cada nodo:\n\nggraph(graph, layout = \"stress\") + \n  geom_edge_link(\n    arrow = arrow(), \n    start_cap = circle(5, \"mm\"),\n    end_cap = circle(5, \"mm\")\n  ) + \n  geom_node_point(aes(colour = class), size = 8)\n\n\n\n\n\n\n\n\n7.2.3.2 Un borde no siempre es una línea\nSi bien es natural pensar en los bordes como diferentes tipos de líneas que conectan puntos, esto sólo es cierto para ciertos tipos de trazados de red. Siempre hay que tener en cuenta que los nodos y los bordes son conceptos abstractos y se pueden visualizar de multitud de formas. Como ejemplo de esto, podemos observar los gráficos matriciales que muestran nodos implícitamente por posición de fila y columna, y muestran los bordes como puntos o mosaicos.\n\nggraph(hs_graph, layout = \"matrix\", sort.by = node_rank_traveller()) + \n  geom_edge_point()\n\n\n\n\n\n\n\n\n7.2.4 Facetado\nEl facetado no es un concepto que se aplica frecuentemente a la visualización de redes, pero es tan poderoso para redes como lo es para datos tabulares. Si bien las funciones de facetado estándar en ggplot2 funcionan técnicamente con ggraph, no lo hacen a nivel conceptual, ya que los nodos y los bordes están conectados y dividir los nodos en múltiples subtramas moverá automáticamente los bordes con ellos, aunque los bordes no tengan la variable de facetado en sus datos. Debido a esto, ggraph proporciona sus propias versiones especializadas de facet_wrap() y facet_grid(). facet_nodes() y facet_edges() apuntarán a nodos o bordes y envolverán los paneles de la misma manera que facet_wrap(). Para facet_nodes() la convención es que si un borde va entre dos nodos en el mismo panel, se mostrará en ese panel, pero si se divide entre varios paneles, se eliminará. Para facet_edges() los nodos se repetirán en todos los paneles. Para verlo en acción podemos mirar el gráfico de nuestra escuela secundaria y ver cómo han evolucionado sus amistades a lo largo de los años.\n\nggraph(hs_graph, layout = \"stress\") + \n  geom_edge_link() + \n  geom_node_point() + \n  facet_edges(~year)\n\n\n\n\n\n\n\nComo queda muy claro con el facetado, vemos una clara evolución de las amistades que van de dos grupos completamente separados a un solo grupo más mixto.\nComo el facetado también acepta algoritmos de tidygraph, es una excelente manera de evaluar, p. el resultado de agrupaciones sobre la marcha.\n\nggraph(hs_graph, layout = \"stress\") + \n  geom_edge_link() + \n  geom_node_point() + \n  facet_nodes(~ group_spinglass())\n\n\n\n\n\n\n\nEl último tipo de faceta incluido es facet_graph() que funciona como facet_grid(), pero le permite especificar en qué parte deben facetarse las filas y columnas, bordes o nodos.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Redes</span>"
    ]
  },
  {
    "objectID": "networks.html#quieren-más-1",
    "href": "networks.html#quieren-más-1",
    "title": "7  Redes",
    "section": "\n7.3 ¿Quieren más?",
    "text": "7.3 ¿Quieren más?\nEsto es sólo una muestra de las posibilidades presentadas en ggraph. Si desea profundizar más, puede encontrar útiles los recursos en https://tidygraph.data-imaginist.com y https://ggraph.data-imaginist.com. Comprender los fundamentos de tidygraph y la API aumentará su dominio y comprensión de ggraph, así que asegúrese de estudiarlos al unísono.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Redes</span>"
    ]
  },
  {
    "objectID": "annotations.html",
    "href": "annotations.html",
    "title": "8  Anotaciones",
    "section": "",
    "text": "8.1 Títulos de trama y eje\nAl construir una visualización de datos, a menudo es necesario hacer anotaciones en los datos mostrados. Conceptualmente, una anotación proporciona metadatos para el gráfico: es decir, proporciona información adicional sobre los datos que se muestran. Sin embargo, desde un punto de vista práctico, los metadatos son sólo otra forma de datos. Debido a esto, las herramientas de anotación en ggplot2 reutilizan las mismas geoms que se usan para crear otros gráficos. Sin embargo, para satisfacer las necesidades específicas que los usuarios suelen tener al anotar gráficos, existen algunas funciones auxiliares en ggplot2 y varios otros paquetes han ampliado ggplot2 de maneras que pueden resultarle útiles.\nAl personalizar un gráfico, suele ser útil modificar los títulos asociados con el gráfico, los ejes y las leyendas. Para ayudar con esta tarea, ggplot2 proporciona la función auxiliar labs(), que le permite configurar los diversos títulos usando pares de nombre-valor como título = \"Título de mi gráfico, x = \"Eje X\" o fill = \"fill legend\":\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(aes(colour = factor(cyl))) + \n  labs(\n    x = \"Cilindrada del motor (litros)\", \n    y = \"Millas de carretera por galón\", \n    colour = \"Número de cilindros\",\n    title = \"Kilometraje por tamaño de motor y cilindros.\",\n    subtitle = \"Fuente: https://fueleconomy.gov\"\n  )\nLos valores proporcionados a labs() suelen ser cadenas de texto, y \\n se usa para especificar saltos de línea, pero también puede proporcionar expresiones matemáticas envueltas en quote(). Las reglas mediante las cuales se interpretan estas expresiones se pueden encontrar escribiendo ?plotmath.\nvalues &lt;- seq(from = -2, to = 2, by = .01)\ndf &lt;- data.frame(x = values, y = values ^ 3)\nggplot(df, aes(x, y)) + \n  geom_path() + \n  labs(y = quote(f(x) == x^3))\nTambién es posible incluir (algunas) rebajas en los títulos de ejes y leyendas con la ayuda del paquete ggtext (Wilke 2020) y el sistema de temas ggplot2 (ver ?sec-polish). Para habilitar la reducción, debe configurar el elemento del tema relevante en ggtext::element_markdown(), como se demuestra a continuación:\nHay dos formas de eliminar la etiqueta del eje. Configurar labs(x = \"\") omite la etiqueta pero aún asigna espacio; configurar labs(x = NULL) elimina la etiqueta y su espacio.\nPara obtener más información sobre cómo se relaciona labs() con las escalas en ggplot2, consulte Sección 14.2.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Anotaciones</span>"
    ]
  },
  {
    "objectID": "annotations.html#sec-titles",
    "href": "annotations.html#sec-titles",
    "title": "8  Anotaciones",
    "section": "",
    "text": "df &lt;- data.frame(x = 1:3, y = 1:3)\nbase &lt;- ggplot(df, aes(x, y)) + \n  geom_point() + \n  labs(x = \"Título del eje con *cursiva* y **negrita**\")\n\nbase \nbase + theme(axis.title.x = ggtext::element_markdown())",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Anotaciones</span>"
    ]
  },
  {
    "objectID": "annotations.html#sec-text-labels",
    "href": "annotations.html#sec-text-labels",
    "title": "8  Anotaciones",
    "section": "\n8.2 Etiquetas de texto",
    "text": "8.2 Etiquetas de texto\n \nAgregar texto a un gráfico es una de las formas más comunes de anotación. La mayoría de los gráficos no se beneficiarán al agregar texto a cada observación en el gráfico, pero etiquetar los valores atípicos y otros puntos importantes es muy útil. Sin embargo, la anotación de texto puede resultar complicada debido a la forma en que R maneja las fuentes. El paquete ggplot2 no tiene todas las respuestas, pero proporciona algunas herramientas para hacerle la vida un poco más fácil. La herramienta principal para etiquetar gráficos es geom_text(), que agrega un etiqueta de texto, label, en las posiciones x e y especificadas. geom_text() tiene la mayor estética de cualquier geom, porque hay muchas maneras de controlar la apariencia de un texto:\n\n\nLa estética family proporciona el nombre de una fuente. Esta estética sí le permite usar el nombre de una fuente del sistema, pero se requiere algo de cuidado. Sólo hay tres fuentes que garantizan su funcionamiento en todas partes: “sans” (la predeterminada), “serif” o “mono”. Para ilustrar estos:\n\ndf &lt;- data.frame(x = 1, y = 3:1, family = c(\"sans\", \"serif\", \"mono\"))\nggplot(df, aes(x, y)) + \n  geom_text(aes(label = family, family = family))\n\n\n\n\n\n\n\nLa razón por la que puede resultar complicado utilizar fuentes del sistema en un gráfico es que cada dispositivo gráfico (GD) maneja el dibujo de texto de forma diferente. Hay dos grupos de GD: dispositivos de pantalla como windows() (para Windows), quartz() (para Mac), x11() (principalmente para Linux) y RStudioGD() (dentro de RStudio)) dibujan el gráfico en la pantalla, mientras que los dispositivos de archivos como png() y pdf() escriben el gráfico en un archivo. Desafortunadamente, los dispositivos no especifican las fuentes de la misma manera, por lo que si desea que una fuente funcione en todas partes, deberá configurar los dispositivos de diferentes maneras. Dos paquetes simplifican un poco el dilema:\n\nshowtext, https://github.com/yixuan/showtext, de Yixuan Qiu, crea gráficos independientes de GD al representar todo el texto como polígonos.\nextrafont, https://github.com/wch/extrafont, de Winston Chang, convierte fuentes a un formato estándar que todos los dispositivos pueden usar.\n\nAmbos enfoques tienen ventajas y desventajas, por lo que tendrás que probar ambos y ver cuál funciona mejor para tus necesidades. \n\n\nLa estética fontface especifica el formato y puede tomar tres valores: “plain” (el valor predeterminado), “bold” para negrita o “italic” para cursiva. Por ejemplo: \n\ndf &lt;- data.frame(x = 1, y = 3:1, face = c(\"plain\", \"bold\", \"italic\"))\nggplot(df, aes(x, y)) + \n  geom_text(aes(label = face, fontface = face))\n\n\n\n\n\n\n\n\n\nPuede ajustar la alineación del texto con las estéticas hjust (“left”, “center”, “right”, “inward”, “outward”) y vjust (“bottom”, “middle”, “top” , “inward”, “outward”). La alineación está centrada de forma predeterminada, pero a menudo hay buenas razones para anularla. Una de las alineaciones más útiles es la “inward”. Alinea el texto hacia el centro de la trama, lo que garantiza que las etiquetas permanezcan dentro de los límites de la trama: \ndf &lt;- data.frame(\n  x = c(1, 1, 2, 2, 1.5),\n  y = c(1, 2, 1, 2, 1.5),\n  text = c(\n    \"bottom-left\", \"top-left\",  \n    \"bottom-right\", \"top-right\", \"center\"\n  )\n)\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = text))\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = text), vjust = \"inward\", hjust = \"inward\")\n\n\n\n\n\n\n\n\n\n\n\nEl tamaño de fuente está controlado por la estética del size. A diferencia de la mayoría de herramientas, ggplot2 especifica el tamaño en milímetros (mm), en lugar de los puntos habituales (pts). El motivo de esta elección es que hace que las unidades para tamaños de fuente sean consistentes con la forma en que se especifican otros tamaños en ggplot2. (Hay 72,27 puntos en una pulgada, por lo que para convertir de puntos a mm, simplemente multiplique por 25,4/72,27). \nangle especifica la rotación del texto en grados.\n\nEl paquete ggplot2 le permite asignar valores de datos a la estética utilizada por geom_text(), pero debe usar moderación: es difícil percibir la relación entre las variables asignadas a esta estética, y rara vez es útil hacerlo.\nAdemás de las diversas estéticas, geom_text() tiene tres parámetros que puedes especificar. A diferencia de la estética, estos sólo toman valores únicos, por lo que deben ser los mismos para todas las etiquetas:\n\n\nA menudo desea etiquetar puntos existentes en el gráfico, pero no desea que el texto se superponga con los puntos (o barras, etc.). En esta situación es útil desplazar un poco el texto, lo que puedes hacer con los parámetros nudge_x y nudge_y:\n\ndf &lt;- data.frame(\n  treatment = c(\"a\", \"b\", \"c\"), \n  response = c(1.2, 3.4, 2.5)\n)\n\nggplot(df, aes(treatment, response)) + \n  geom_point() + \n  geom_text(\n    mapping = aes(label = paste0(\"(\", response, \")\")), \n    nudge_x = -0.3\n  ) + \n  ylim(1.1, 3.6)\n\n\n\n\n\n\n\n(Tenga en cuenta que modificamos manualmente los límites del eje y para darles a las etiquetas un poco más de espacio.)\n\n\nEl tercer parámetro es check_overlap. Si check_overlap = TRUE, las etiquetas superpuestas se eliminarán automáticamente del gráfico. El algoritmo es simple: las etiquetas se trazan en el orden en que aparecen en el marco de datos; si una etiqueta se superpone con un punto existente, se omite. \nggplot(mpg, aes(displ, hwy)) + \n  geom_text(aes(label = model)) + \n  xlim(1, 8)\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_text(aes(label = model), check_overlap = TRUE) + \n  xlim(1, 8)\n\n\n\n\n\n\n\n\n\n\nA primera vista, esta característica no parece muy útil, pero la simplicidad del algoritmo resulta útil. Si ordena los datos de entrada por orden de prioridad, el resultado es un gráfico con etiquetas que enfatizan puntos de datos importantes.\n\n\nUna variación de geom_text() es geom_label(): dibuja un rectángulo redondeado detrás del texto. Esto lo hace útil para agregar etiquetas a gráficos con fondos ocupados: \n\nlabel &lt;- data.frame(\n  waiting = c(55, 80), \n  eruptions = c(2, 4.3), \n  label = c(\"peak one\", \"peak two\")\n)\n\nggplot(faithfuld, aes(waiting, eruptions)) +\n  geom_tile(aes(fill = density)) + \n  geom_label(data = label, aes(label = label))\n\n\n\n\n\n\n\nEtiquetar bien los datos plantea algunos desafíos:\n\nEl texto no afecta los límites de la trama. Desafortunadamente, no hay forma de hacer que esto funcione ya que una etiqueta tiene un tamaño absoluto (por ejemplo, 3 cm), independientemente del tamaño de la trama. Esto significa que los límites de un gráfico tendrían que ser diferentes dependiendo del tamaño del mismo; simplemente no hay forma de que eso suceda con ggplot2. En su lugar, necesitarás modificar xlim() y ylim() según tus datos y el tamaño del gráfico.\n\nSi desea etiquetar muchos puntos, es difícil evitar superposiciones. check_overlap = TRUE es útil, pero ofrece poco control sobre qué etiquetas se eliminan. Una técnica popular para solucionar este problema es utilizar el paquete ggrepel https://github.com/slowkow/ggrepel de Kamil Slowikowski. El paquete proporciona geom_text_repel(), que optimiza la posición de la etiqueta para evitar la superposición. Funciona bastante bien siempre que el número de etiquetas no sea excesivo:\n\nmini_mpg &lt;- mpg[sample(nrow(mpg), 20), ]\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(colour = \"red\") + \n  ggrepel::geom_text_repel(data = mini_mpg, aes(label = class))\n\n\n\n\n\n\n\n\nA veces puede resultar difícil garantizar que las etiquetas de texto encajen en el espacio deseado. El paquete ggfittext https://github.com/wilkox/ggfittext de Claus Wilke contiene herramientas útiles que pueden ayudar con esto, incluidas funciones que le permiten colocar etiquetas de texto dentro de las columnas en un gráfico de barras.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Anotaciones</span>"
    ]
  },
  {
    "objectID": "annotations.html#sec-custom-annotations",
    "href": "annotations.html#sec-custom-annotations",
    "title": "8  Anotaciones",
    "section": "\n8.3 Crear anotaciones personalizadas",
    "text": "8.3 Crear anotaciones personalizadas\n\nEtiquetar puntos individuales con texto es un tipo importante de anotación, pero no es la única técnica útil. El paquete ggplot2 proporciona varias otras herramientas para anotar trazados usando las mismas geoms que usaría para mostrar datos. Por ejemplo, puedes utilizar:\n\ngeom_text() y geom_label() para agregar texto, como se ilustró anteriormente.\ngeom_rect() para resaltar interesantes regiones rectangulares de la trama. geom_rect() tiene estética xmin, xmax, ymin y ymax. \ngeom_line(), geom_path() y geom_segment() para agregar líneas. Todas estas geoms tienen una arrow parámetro, que le permite colocar una punta de flecha en la línea. Crea puntas de flecha con arrow(), que tiene argumentos angle, length, ends y type. \ngeom_vline(), geom_hline() y geom_abline() le permiten agregar líneas de referencia (a veces llamadas reglas), que abarcan todo el rango de la trama. \n\nNormalmente, puede colocar anotaciones en primer plano (usando alpha si es necesario para poder seguir viendo los datos) o en segundo plano. Con el fondo predeterminado, una línea blanca gruesa es una referencia útil: es fácil de ver pero no llama la atención. Para ilustrar cómo se pueden utilizar las herramientas ggplot2 para anotar gráficos, comenzaremos con una serie temporal que representa el desempleo en EE. UU. a lo largo del tiempo:\n\nggplot(economics, aes(date, unemploy)) + \n  geom_line()\n\n\n\n\n\n\n\nUna forma útil de anotar este gráfico es utilizar sombreado para indicar qué presidente estaba en el poder en ese momento. Para hacer esto, usamos geom_rect() para introducir sombreado, geom_vline() para introducir separadores, geom_text() para agregar etiquetas y luego usamos geom_line() para superponer los datos sobre estos fondos. elementos:\n\npresidential &lt;- subset(presidential, start &gt; economics$date[1])\n\nggplot(economics) + \n  geom_rect(\n    aes(xmin = start, xmax = end, fill = party), \n    ymin = -Inf, ymax = Inf, alpha = 0.2, \n    data = presidential\n  ) + \n  geom_vline(\n    aes(xintercept = as.numeric(start)), \n    data = presidential,\n    colour = \"grey50\", alpha = 0.5\n  ) + \n  geom_text(\n    aes(x = start, y = 2500, label = name), \n    data = presidential, \n    size = 3, vjust = 0, hjust = 0, nudge_x = 50\n  ) + \n  geom_line(aes(date, unemploy)) + \n  scale_fill_manual(values = c(\"blue\", \"red\")) +\n  xlab(\"Fecha\") + \n  ylab(\"Deseempleo\")\n\n\n\n\n\n\n\nTenga en cuenta que hay pocas novedades aquí: en su mayor parte, anotar gráficos en ggplot2 es una manipulación sencilla de geoms existentes. Dicho esto, hay una cosa especial a tener en cuenta en este código: el uso de -Inf e Inf como posiciones. Estos se refieren a los límites superior e inferior (o izquierdo y derecho) del gráfico. \nEsta técnica también se puede aplicar de otras formas. Por ejemplo, puedes usarlo para agregar una sola anotación a un gráfico, pero es un poco complicado porque tienes que crear un marco de datos de una fila:\n\nyrng &lt;- range(economics$unemploy)\nxrng &lt;- range(economics$date)\ncaption &lt;- paste(strwrap(\"Las tasas de desempleo en EE.UU. han\n  varió mucho a lo largo de los años\", 40), collapse = \"\\n\")\n\nggplot(economics, aes(date, unemploy)) + \n  geom_line() + \n  geom_text(\n    aes(x, y, label = caption), \n    data = data.frame(x = xrng[1], y = yrng[2], caption = caption), \n    hjust = 0, vjust = 1, size = 4\n  )\n\nEste código funciona y genera la trama deseada, pero es muy engorroso. Sería molesto tener que hacer esto cada vez que quieras agregar una sola anotación, por lo que ggplot2 incluye la función auxiliar annotate() que crea el marco de datos por ti: \n\nggplot(economics, aes(date, unemploy)) + \n  geom_line() + \n  annotate(\n    geom = \"text\", x = xrng[1], y = yrng[2], \n    label = caption, hjust = 0, vjust = 1, size = 4\n  )\n\n\n\n\n\n\n\nLa conveniencia de la función annotate() resulta útil en otras situaciones. Por ejemplo, una forma común de anotación es resaltar un subconjunto de puntos dibujando puntos más grandes en un color diferente debajo del conjunto de datos principal. Para resaltar los vehículos fabricados por Subaru, puedes usar esto para crear la trama básica:\n\np &lt;- ggplot(mpg, aes(displ, hwy)) +\n  geom_point(\n    data = filter(mpg, manufacturer == \"subaru\"), \n    colour = \"orange\",\n    size = 3\n  ) +\n  geom_point() \n\nEl problema con esto es que la categoría resaltada no estaría etiquetada. Esto se soluciona fácilmente usando annotate()\n\np + \n  annotate(geom = \"point\", x = 5.5, y = 40, colour = \"orange\", size = 3) + \n  annotate(geom = \"point\", x = 5.5, y = 40) + \n  annotate(geom = \"text\", x = 5.6, y = 40, label = \"subaru\", hjust = \"left\")\n\n\n\n\n\n\n\nEste enfoque tiene la ventaja de crear una etiqueta dentro de la región del trazado, pero el inconveniente es que la etiqueta está distante de los puntos que selecciona (de lo contrario, el punto naranja y negro adyacente a la etiqueta podría confundirse con datos reales). Un enfoque alternativo es utilizar una geom diferente para hacer el trabajo. geom_curve() y geom_segment() se pueden usar para dibujar curvas y líneas que conectan puntos con etiquetas, y se pueden usar junto con annotate() como se ilustra a continuación:\n\np + \n  annotate(\n    geom = \"curve\", x = 4, y = 35, xend = 2.65, yend = 27, \n    curvature = .3, arrow = arrow(length = unit(2, \"mm\"))\n  ) +\n  annotate(geom = \"text\", x = 4.1, y = 35, label = \"subaru\", hjust = \"left\")",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Anotaciones</span>"
    ]
  },
  {
    "objectID": "annotations.html#etiquetado-directo",
    "href": "annotations.html#etiquetado-directo",
    "title": "8  Anotaciones",
    "section": "\n8.4 Etiquetado directo",
    "text": "8.4 Etiquetado directo\nLos gráficos de Subaru anteriores proporcionan ejemplos de “etiquetado directo”, en los que la propia región del trazado contiene las etiquetas para grupos de puntos en lugar de utilizar una leyenda. Esto generalmente hace que el gráfico sea más fácil de leer porque acerca las etiquetas a los datos. El ecosistema más amplio de ggplot2 contiene una variedad de otras herramientas para lograr esto de una manera más automatizada. El paquete directlabels, de Toby Dylan Hocking, proporciona una serie de herramientas para facilitar esto: \nggplot(mpg, aes(displ, hwy, colour = class)) + \n  geom_point()\n\nggplot(mpg, aes(displ, hwy, colour = class)) + \n  geom_point(show.legend = FALSE) +\n  directlabels::geom_dl(aes(label = class), method = \"smart.grid\")\n\n\n\n\n\n\n\n\n\n\nDirectlabels proporciona varios métodos de posición. smart.grid es un lugar razonable para comenzar con los diagramas de dispersión, pero existen otros métodos que son más útiles para los polígonos de frecuencia y los diagramas de líneas. Consulte el sitio web de directlabels, http://directlabels.r-forge.r-project.org, para conocer otras técnicas.\nOtra versión de esta idea proviene del paquete ggforce de Thomas Lin Pedersen https://github.com/thomasp85/ggforce. El paquete ggforce contiene muchas herramientas útiles para ampliar la funcionalidad de ggplot2, incluidas funciones como geom_mark_ellipse() que superpone un gráfico con marcas circulares “resaltadas”. Por ejemplo:\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() + \n  ggforce::geom_mark_ellipse(aes(label = cyl, group = cyl))\n\n\n\n\n\n\n\nUn tercer enfoque para el etiquetado directo lo proporciona el paquete gghighlight de Hiroaki Yutani https://github.com/yutannihilation/gghighlight. En muchas situaciones es útil para resaltar puntos o líneas (o incluso una variedad de geoms diferentes) dentro de un gráfico, particularmente para datos longitudinales:\n\ndata(Oxboys, package = \"nlme\")\nggplot(Oxboys, aes(age, height, group = Subject)) + \n  geom_line() + \n  geom_point() + \n  gghighlight::gghighlight(Subject %in% 1:3)\n#&gt; Warning: Tried to calculate with group_by(), but the calculation failed.\n#&gt; Falling back to ungrouped filter operation...\n#&gt; Tried to calculate with group_by(), but the calculation failed.\n#&gt; Falling back to ungrouped filter operation...\n#&gt; label_key: Subject",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Anotaciones</span>"
    ]
  },
  {
    "objectID": "annotations.html#anotación-entre-facetas",
    "href": "annotations.html#anotación-entre-facetas",
    "title": "8  Anotaciones",
    "section": "\n8.5 Anotación entre facetas",
    "text": "8.5 Anotación entre facetas\nCuando se usan bien, las anotaciones pueden ser una herramienta poderosa para ayudar al lector a entender sus datos. Un ejemplo de esto es cuando desea que el lector compare grupos entre facetas. Por ejemplo, en el gráfico siguiente es fácil ver la relación dentro de cada faceta, pero las diferencias sutiles entre las facetas no resaltan:\n\nggplot(diamonds, aes(log10(carat), log10(price))) + \n  geom_bin2d() + \n  facet_wrap(vars(cut), nrow = 1)\n\n\n\n\n\n\n\nEs mucho más fácil ver estas sutiles diferencias si añadimos una línea de referencia:\n\nmod_coef &lt;- coef(lm(log10(price) ~ log10(carat), data = diamonds))\nggplot(diamonds, aes(log10(carat), log10(price))) + \n  geom_bin2d() + \n  geom_abline(intercept = mod_coef[1], slope = mod_coef[2], \n    colour = \"white\", linewidth = 1) + \n  facet_wrap(vars(cut), nrow = 1)\n\n\n\n\n\n\n\nEn este gráfico, cada faceta muestra los datos de una categoría frente a la misma línea de regresión. Esto facilita la comparación de las facetas entre sí porque existe una línea de referencia compartida para ayudar en la comparación visual.\nUna variación de este tema surge cuando desea que cada faceta de un gráfico muestre datos de un solo grupo, con el conjunto de datos completo trazado discretamente en cada panel para ayudar a la comparación visual. El paquete gghighlight es particularmente útil en este contexto:\n\nggplot(mpg, aes(displ, hwy, colour = factor(cyl))) +\n  geom_point() + \n  gghighlight::gghighlight() + \n  facet_wrap(vars(cyl))\n\n\n\n\n\n\n\n\n\n\n\nWilke, Claus O. 2020. ggtext: Improved Text Rendering Support for ’ggplot2’. https://CRAN.R-project.org/package=ggtext.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Anotaciones</span>"
    ]
  },
  {
    "objectID": "arranging-plots.html",
    "href": "arranging-plots.html",
    "title": "9  Organizar gráficas",
    "section": "",
    "text": "9.1 Disposición de gráficas una al lado de la otra\nLa gramática presentada en ggplot2 se ocupa de la creación de gráficos únicos. Si bien el sistema de facetas proporciona los medios para producir varias subgráficas, todas ellas forman parte de la misma visualización principal y comparten capas, datos y escalas. Sin embargo, a menudo es necesario utilizar múltiples gráficas dispares para contar una historia o presentar un argumento. Por supuesto, estos pueden crearse individualmente y ensamblarse en un programa de diseño, pero es beneficioso hacerlo en código para evitar un trabajo manual lento y no reproducible. Una variedad de paquetes han estado a la altura de las circunstancias y ofrecen diferentes enfoques para organizar gráficas separadas. Si bien este capítulo se centrará en el paquete patchwork, es posible que también encuentre algunas de las mismas funcionalidades en los paquetes cowplot, gridExtra y ggpubr.\nEste capítulo se dividirá en dos partes. El primero se ocupará de organizar las gráficas una al lado de la otra sin que se superpongan, mientras que el segundo se ocupará de organizar las gráficas una encima de la otra. Si bien estos dos escenarios no son necesariamente opuestos entre sí, el primero a menudo se beneficiará de una funcionalidad que tiene poco sentido en el segundo, p.e. alineación de las regiones de trazado.\nA menudo, uno quiere mostrar dos o más gráficas una al lado de la otra para mostrar diferentes aspectos de la misma historia de una manera convincente. Este es el escenario para el que se creó patchwork. En esencia, patchwork es un paquete que extiende el uso del operador + de ggplot2 para trabajar entre múltiples gráficos, así como también agrega operadores adicionales para composiciones especializadas y trabajar con composiciones de gráficos.\nComo ejemplo del uso más básico de patchwork, usaremos los siguientes 4 gráficos del conjunto de datos mpg\np1 &lt;- ggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy))\n\np2 &lt;- ggplot(mpg) + \n  geom_bar(aes(x = as.character(year), fill = drv), position = \"dodge\") + \n  labs(x = \"year\")\n\np3 &lt;- ggplot(mpg) + \n  geom_density(aes(x = hwy, fill = drv), colour = NA) + \n  facet_grid(rows = vars(drv))\n\np4 &lt;- ggplot(mpg) + \n  stat_summary(aes(x = drv, y = hwy, fill = drv), geom = \"col\", fun.data = mean_se) +\n  stat_summary(aes(x = drv, y = hwy), geom = \"errorbar\", fun.data = mean_se, width = 0.5)\nEl uso más simple de patchwork es usar + para sumar gráficos, creando así un conjunto de gráficos para mostrar juntos:\nlibrary(patchwork)\n\np1 + p2\n+ no especifica ningún diseño específico, solo que los gráficos deben mostrarse juntos. En ausencia de un diseño, el mismo algoritmo que gobierna el número de filas y columnas en facet_wrap() decidirá el número de filas y columnas. Esto significa que sumar 3 gráficas creará una cuadrícula de 1x3, mientras que sumar 4 gráficas creará una cuadrícula de 2x2.\np1 + p2 + p3 + p4\nComo se puede observar en los dos ejemplos anteriores, el patchwork se encarga de alinear las diferentes partes de las gráficas entre sí. Puede ver que todas las regiones de trazado están alineadas, incluso en presencia de facetado. Además, puede ver que los títulos del eje y en los dos gráficos más a la izquierda están alineados a pesar de que el texto del eje en el gráfico inferior izquierdo es más ancho.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Organizar gráficas</span>"
    ]
  },
  {
    "objectID": "arranging-plots.html#disposición-de-gráficas-una-al-lado-de-la-otra",
    "href": "arranging-plots.html#disposición-de-gráficas-una-al-lado-de-la-otra",
    "title": "9  Organizar gráficas",
    "section": "",
    "text": "9.1.1 Tomando el control del diseño\nA menudo, la cuadrícula creada automáticamente no es la que usted desea y, por supuesto, es posible controlarla. La forma más directa y poderosa de hacer esto es agregar una especificación plot_layout() al gráfico:\n\np1 + p2 + p3 + plot_layout(ncol = 2)\n\n\n\n\n\n\n\nUn escenario común es querer forzar una sola fila o columna. patchwork proporciona dos operadores, | y / respectivamente, para facilitar esto (debajo del capó, simplemente establecen el número de filas o columnas en el diseño en 1).\n\np1 / p2\n\n\n\n\n\n\n\n\n# Básicamente lo mismo que usar `+` pero la intención es más clara.\np3 | p4\n\n\n\n\n\n\n\npatchwork permite anidar diseños, lo que significa que es posible crear diseños muy complejos utilizando sólo estos dos operadores.\n\np3 | (p2 / (p1 | p4))\n\n\n\n\n\n\n\nAlternativamente, para diseños muy complejos, es posible especificar diseños no tabulares con una representación textual en el argumento design en plot_layout().\n\nlayout &lt;- \"\nAAB\nC#B\nCDD\n\"\n\np1 + p2 + p3 + p4 + plot_layout(design = layout)\n\n\n\n\n\n\n\nComo ha sido evidente en las últimas gráficas, la leyenda a menudo se vuelve redundante entre gráficas. Si bien es posible eliminar la leyenda en todos los gráficos menos uno antes de ensamblarlos, el mosaico proporciona algo más fácil para el caso común:\n\np1 + p2 + p3 + plot_layout(ncol = 2, guides = \"collect\")\n\n\n\n\n\n\n\nLa elección de recopilar guías tomará todas las guías y las reunirá en la posición regida por el tema global. Además, eliminará cualquier guía duplicada y dejará solo guías únicas en la gráfica. La detección de duplicaciones analiza la apariencia de la guía y no la escala subyacente de la que proviene. Por lo tanto, sólo eliminará las guías que sean exactamente iguales. Si desea optimizar el uso del espacio colocando guías en un área vacía del diseño, puede especificar un área de trazado para las guías recopiladas:\n\np1 + p2 + p3 + guide_area() + plot_layout(ncol = 2, guides = \"collect\")\n\n\n\n\n\n\n\n\n9.1.2 Modificando subgráficas\nUno de los principios del patchwork es que los gráficos permanecen como objetos estándar de ggplot hasta que se renderizan. Esto significa que son susceptibles de modificación una vez ensamblados. Los gráficos específicos se pueden recuperar y configurar con la indexación [[]]:\n\np12 &lt;- p1 + p2\np12[[2]] &lt;- p12[[2]] + theme_light()\np12\n\n\n\n\n\n\n\nSin embargo, a menudo es necesario modificar todas las subgráficas a la vez, por ejemplo. darles un tema común. patchwork proporciona el & para este escenario:\n\np1 + p4 & theme_minimal()\n\n\n\n\n\n\n\nEsto también se puede utilizar para darle a las gráficas un eje común si comparten la misma estética en ese eje:\n\np1 + p4 & scale_y_continuous(limits = c(0, 45))\n\n\n\n\n\n\n\n\n9.1.3 Agregar anotaciones\nUna vez ensambladas las gráficas, pasan a formar una sola unidad. Esto también significa que los títulos, subtítulos y subtítulos a menudo pertenecerán al conjunto completo y no a gráficas individuales. Se pueden agregar títulos, etc. a los gráficos de mosaico usando la función plot_annotation().\n\np34 &lt;- p3 + p4 + plot_annotation(\n  title = \"Una mirada más cercana al efecto de la transmisión en los automóviles\",\n  caption = \"Fuente: conjunto de datos de mpg en ggplot2\"\n)\np34\n\n\n\n\n\n\n\nLos títulos formateados según la especificación del tema en la llamada plot_annotation().\n\np34 + plot_annotation(theme = theme_gray(base_family = \"mono\"))\n\n\n\n\n\n\n\nComo el tema global a menudo sigue el tema de las subgráficas, usar & junto con un objeto de tema modificará el tema global así como los temas de las subgráficas.\n\np34 & theme_gray(base_family = \"mono\")\n\n\n\n\n\n\n\nOtro tipo de anotación, conocida especialmente en la literatura científica, consiste en agregar etiquetas a cada subgráfica que luego se utilizarán para identificarlas en el texto y el título. ggplot2 tiene el elemento tag exactamente para esto y patchwork ofrece funcionalidad para configurarlo automáticamente usando el argumento tag_levels. Puede generar niveles automáticos en caracteres latinos, números arábigos o números romanos.\n\np123 &lt;- p1 | (p2 / p3)\np123 + plot_annotation(tag_levels = \"I\") # Números romanos en mayúsculas\n\n\n\n\n\n\n\nUna característica adicional es que es posible utilizar el anidamiento para definir nuevos niveles de etiquetado:\n\np123[[2]] &lt;- p123[[2]] + plot_layout(tag_level = \"new\")\np123 + plot_annotation(tag_levels = c(\"I\", \"a\"))\n\n\n\n\n\n\n\n\nComo puede verse, el patchwork ofrece una amplia gama de posibilidades a la hora de organizar gráficas, y la API escala con el nivel de complejidad del ensamblaje, desde simplemente usar + para colocar múltiples gráficas en la misma área, hasta usar anidamiento. , diseños y anotaciones para crear diseños personalizados avanzados.",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Organizar gráficas</span>"
    ]
  },
  {
    "objectID": "arranging-plots.html#organizar-gráficas-una-encima-de-la-otra.",
    "href": "arranging-plots.html#organizar-gráficas-una-encima-de-la-otra.",
    "title": "9  Organizar gráficas",
    "section": "\n9.2 Organizar gráficas una encima de la otra.",
    "text": "9.2 Organizar gráficas una encima de la otra.\nSi bien gran parte de la funcionalidad del patchwork se refiere a alinear trazados en una cuadrícula, también permite hacer inserciones, es decir, pequeños trazados colocados encima de otro trazado. La funcionalidad para esto está incluida en la función inset_element() que sirve para marcar el gráfico dado como un recuadro que se colocará en el gráfico anterior, además de registrar la ubicación deseada, etc. El uso básico es el siguiente:\n\np1 + inset_element(p2, left = 0.5, bottom = 0.4, right = 0.9, top = 0.95)\n\n\n\n\n\n\n\nLa posición se especifica mediante la ubicación izquierda, derecha, superior e inferior del recuadro. El valor predeterminado es usar unidades npc que van de 0 a 1 en el área dada, pero se puede usar cualquier grid::unit() brindándolas explícitamente. La ubicación está establecida de forma predeterminada en el área del panel, pero esto se puede cambiar con el argumento align_to. Combinando todo esto podemos colocar un recuadro exactamente a 15 mm de la esquina superior derecha así:\n\np1 + \n  inset_element(\n    p2, \n    left = 0.4, \n    bottom = 0.4, \n    right = unit(1, \"npc\") - unit(15, \"mm\"), \n    top = unit(1, \"npc\") - unit(15, \"mm\"),\n    align_to = \"full\"\n  )\n\n\n\n\n\n\n\nlos recuadros no se limitan a ggplots. Se puede utilizar cualquier gráfico compatible con wrap_elements(), incluidos los mosaicos:\n\np24 &lt;- p2 / p4 + plot_layout(guides = \"collect\")\np1 + inset_element(p24, left = 0.5, bottom = 0.05, right = 0.95, top = 0.9)\n\n\n\n\n\n\n\nUna característica interesante de los recuadros es que se comportan como subgráficas estándar de mosaico hasta que se renderizan. Esto significa que son susceptibles de modificaciones después del montaje, p.e. usando &:\n\np12 &lt;- p1 + inset_element(p2, left = 0.5, bottom = 0.5, right = 0.9, top = 0.95)\np12 & theme_bw()\n\n\n\n\n\n\n\nY el etiquetado automático también funciona como se esperaba:\n\np12 + plot_annotation(tag_levels = \"A\")",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Organizar gráficas</span>"
    ]
  },
  {
    "objectID": "arranging-plots.html#terminando",
    "href": "arranging-plots.html#terminando",
    "title": "9  Organizar gráficas",
    "section": "\n9.3 Terminando",
    "text": "9.3 Terminando\nEste capítulo ha ofrecido una breve descripción de algunas de las posibilidades de composición que ofrece el patchwork, pero de ninguna manera es exhaustivo. Patchwork proporciona soporte para algo más que ggplots y también le permite combinar elementos gráficos de cuadrícula y base con sus gráficos si es necesario. También permite diseños aún más complejos utilizando el constructor area() en lugar de la representación textual que se muestra aquí. Todas estas funcionalidades y muchas más están cubiertas en las diferentes guías disponibles en su sitio web: https://patchwork.data-imaginist.com",
    "crumbs": [
      "Layers",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Organizar gráficas</span>"
    ]
  },
  {
    "objectID": "scales.html",
    "href": "scales.html",
    "title": "Scales",
    "section": "",
    "text": "Scales in ggplot2 control the mapping from data to aesthetics. They take your data and turn it into something that you can see, like size, colour, position or shape. They also provide the tools that let you interpret the plot: the axes and legends. You can generate plots with ggplot2 without knowing how scales work, but understanding scales and learning how to manipulate them will give you much more control.\nIn ggplot2, guides are produced automatically based on the layers in your plot. You don’t directly control the legends and axes; instead, you set up the data so that there’s a clear mapping between data and aesthetics, and a guide is generated for you. This is very different to base R graphics, where you have total control over the legend, and can be frustrating when you first start using ggplot2. However, once you get the hang of it, you’ll find that it saves you time, and there is little you cannot do.\nThe scales toolbox divides scales into three main groups, covered in separate chapters:\n\nPosition scales and axes are described in 10  Escalas de posición y ejes..\nColour scales and legends are described in 11  Escalas de colores y leyendas..\nScales for other aesthetics are described in 12  Otra estéticas.\n\nThe theory of scales is covered in 14  Escalas y guías, which expands on these chapters as well as other sections in the book that refer to scales (e.g., Títulos de trama y eje is extended by Nombres de escala).",
    "crumbs": [
      "Scales"
    ]
  },
  {
    "objectID": "scales-position.html",
    "href": "scales-position.html",
    "title": "10  Escalas de posición y ejes.",
    "section": "",
    "text": "10.1 Escalas de posición numéricas\nLas escalas de posición se utilizan para controlar las ubicaciones de entidades visuales en un gráfico y cómo esas ubicaciones se asignan a los valores de datos. Cada gráfico tiene dos escalas de posición, correspondientes a la estética xey. En la mayoría de los casos, esto queda claro en la especificación del gráfico, porque el usuario especifica explícitamente las variables asignadas a xey. Sin embargo, este no es siempre el caso. Considere esta especificación de la gráfica:\nEn este ejemplo, el usuario no especifica la estética y. Más bien, la estética se asigna a una variable calculada: geom_histogram() calcula una variable count que se asigna a la estética y. El comportamiento predeterminado de geom_histogram() es equivalente al siguiente:\nDado que las escalas de posición se utilizan en todos los gráficos, es útil comprender cómo funcionan y cómo se pueden modificar. En este capítulo discutiremos esto en detalle. El capítulo está organizado en cuatro secciones principales:\nLas escalas de posición continua más comunes son las funciones predeterminadas scale_x_continuous() y scale_y_continuous(). En el caso más simple, se asignan linealmente desde el valor de los datos hasta una ubicación en el gráfico. Hay varias otras escalas de posición para variables continuas—scale_x_log10(), scale_x_reverse(), etc.—la mayoría de las cuales son funciones de conveniencia utilizadas para proporcionar un fácil acceso a transformaciones comunes, analizadas en ?sec-scale -transformación.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Escalas de posición y ejes.</span>"
    ]
  },
  {
    "objectID": "scales-position.html#sec-numeric-position-scales",
    "href": "scales-position.html#sec-numeric-position-scales",
    "title": "10  Escalas de posición y ejes.",
    "section": "",
    "text": "10.1.1 Límites\n \nTodas las escalas tienen límites que especifican los valores de la estética sobre los cuales se define la escala. Es muy natural pensar en estos límites para escalas de posición numéricas, ya que se asignan directamente a los rangos de los ejes. De forma predeterminada, los límites se calculan a partir del rango de la variable de datos, pero a veces necesitarás establecer los límites manualmente usando el argumento limits de la función de escala. Siempre que la escala sea continua, como es el caso de las escalas de posición numéricas, debe ser un vector numérico de longitud dos. Si solo desea establecer el límite superior o inferior, puede establecer el otro valor en NA.\nEstablecer límites de escala manualmente es una tarea común cuando es necesario asegurarse de que las escalas en diferentes gráficos sean consistentes entre sí. Para ilustrar por qué esto es necesario, considere este diagrama facetado:\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() +\n  facet_wrap(vars(year))\n\n\n\n\n\n\n\nEn este gráfico, ggplot2 se ha asegurado automáticamente de que ambas facetas tengan los mismos límites de eje, lo que facilita la comparación visual de los dos diagramas de dispersión. Sin embargo, al crear los gráficos individualmente, los límites de escala en diferentes gráficos a menudo serán inconsistentes:\nmpg_99 &lt;- mpg %&gt;% filter(year == 1999)\nmpg_08 &lt;- mpg %&gt;% filter(year == 2008)\n\nbase_99 &lt;- ggplot(mpg_99, aes(displ, hwy)) + geom_point() \nbase_08 &lt;- ggplot(mpg_08, aes(displ, hwy)) + geom_point() \n\nbase_99\nbase_08\n\n\n\n\n\n\n\n\n\n\nCada gráfico tiene sentido por sí solo, pero la comparación visual entre los dos es difícil debido a la escala inconsistente de los ejes. Para garantizar una escala de eje consistente, podemos establecer el argumento limits para cada escala por separado:\nbase_99 + \n  scale_x_continuous(limits = c(1, 7)) +\n  scale_y_continuous(limits = c(10, 45))\n\nbase_08 + \n  scale_x_continuous(limits = c(1, 7)) +\n  scale_y_continuous(limits = c(10, 45))\n\n\n\n\n\n\n\n\n\n\nSin embargo, este código es un poco difícil de manejar. Debido a que modificar los límites de escala es una tarea tan común, ggplot2 proporciona la función de conveniencia lims() para simplificar el código. De manera análoga a la función labs() utilizada para especificar etiquetas de eje (Sección 8.1), lims() toma pares nombre-valor como entradas: el nombre del argumento se usa para especificar la estética y el valor se usa para especificar los límites de escala. \nbase_99 + lims(x = c(1, 7), y = c(10, 45))\nbase_08 + lims(x = c(1, 7), y = c(10, 45))\n\n\n\n\n\n\n\n\n\n\nEn el caso especial en el que solo es necesario especificar un límite de eje, ggplot2 también proporciona funciones auxiliares xlim() y ylim(), que pueden ahorrarle algunas pulsaciones de teclas. En la práctica, lims() tiende a ser más útil, porque puede usarse para establecer límites para varias estéticas a la vez. Verás un ejemplo de lims() aplicado a la estética sin posición en Sección 11.3.5.\n\n10.1.2 Acercándose\nLos ejemplos de la sección anterior amplían los límites de la escala más allá del rango abarcado por los datos. También es posible reducir los límites de escala predeterminados, pero se requiere cuidado: cuando trunca los límites de escala, algunos puntos de datos quedarán fuera de los límites que estableció y ggplot2 tiene que tomar una decisión sobre qué hacer con estos puntos de datos. El comportamiento predeterminado en ggplot2 es convertir cualquier valor de datos fuera de los límites de la escala a NA. Esto significa que cambiar los límites de una escala no siempre es lo mismo que hacer un acercamiento visual a una región del gráfico. Si su objetivo es ampliar una parte de la gráfica, normalmente es mejor utilizar los argumentos xlim y ylim de coord_cartesian():\nbase &lt;- ggplot(mpg, aes(drv, hwy)) + \n  geom_hline(yintercept = 28, colour = \"red\") + \n  geom_boxplot() \n\nbase\nbase + coord_cartesian(ylim = c(10, 35)) # funciona como se esperaba\nbase + ylim(10, 35) # distorsiona el diagrama de caja \n#&gt; Warning: Removed 6 rows containing non-finite outside the scale range\n#&gt; (`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\nLa única diferencia entre los gráficos de la izquierda y del medio es que este último está ampliado. Algunos de los puntos atípicos no se muestran debido a la restricción del rango, pero los diagramas de caja en sí siguen siendo idénticos. Por el contrario, en el gráfico de la derecha uno de los diagramas de caja ha cambiado. Al modificar los límites de la escala, todas las observaciones con un kilometraje en carretera superior a 35 se convierten a NA antes de que se calcule la estadística (en este caso, el diagrama de caja). Debido a que estos valores “fuera de límites” ya no están disponibles, el resultado final es que la mediana de la muestra se desplaza hacia abajo, lo que casi nunca es un comportamiento deseable. En retrospectiva, queda claro que esta no fue una buena elección de diseño, porque es una fuente común de confusión para los usuarios. Desafortunadamente, sería muy difícil cambiar este valor predeterminado sin romper una gran cantidad de código existente.\nPuede obtener más información sobre los sistemas de coordenadas en Sección 15.1. Para obtener más información sobre cómo se manejan los valores “fuera de límites” para escalas continuas y agrupadas, consulte Sección 14.4.\n\n10.1.3 Ampliación del rango visual\nSi tienes ojos de águila, habrás notado que el rango visual de los ejes en realidad se extiende un poco más allá de los límites numéricos que hemos especificado en los distintos ejemplos. Esto garantiza que los datos no se superpongan a los ejes, lo que suele ser deseable (pero no siempre). Puede anular los valores predeterminados configurando el argumento expand, que espera un vector numérico creado por expansion().\nPor ejemplo, un caso en el que normalmente es preferible eliminar este espacio es cuando usamos geom_raster(), lo que podemos lograr estableciendo expand = expansion(0): \nbase &lt;- ggplot(faithfuld, aes(waiting, eruptions)) + \n  geom_raster(aes(fill = density)) + \n  theme(legend.position = \"none\") + \n  labs(x = NULL, y = NULL)\n\nbase \nbase + \n  scale_x_continuous(expand = expansion(0)) + \n  scale_y_continuous(expand = expansion(0)) \n\n\n\n\n\n\n\n\n\n\nLas expansiones del eje se describen en términos de un factor “aditivo”, que especifica un espacio constante agregado fuera de los límites nominales del eje, y uno “multiplicativo” que agrega espacio definido como una proporción del tamaño del límite del eje. Estos corresponden a los argumentos add y mult de expansion(), que pueden tener longitud uno (si la expansión es la misma en ambos lados) o longitud dos (para establecer diferentes expansiones en cada lado):\n# Expansión aditiva de tres unidades en ambos ejes.\nbase + \n  scale_x_continuous(expand = expansion(add = 3)) + \n  scale_y_continuous(expand = expansion(add = 3))\n\n# Expansión multiplicativa del 20% en ambos ejes.\nbase + \n  scale_x_continuous(expand = expansion(mult = .2)) + \n  scale_y_continuous(expand = expansion(mult = .2)) \n\n# Expansión multiplicativa del 5% en el extremo inferior \n# de cada eje y del 20% en el extremo superior; para \n# el eje y la expansión se establece directamente en\n# lugar de usar expansion()\nbase + \n  scale_x_continuous(expand = expansion(mult = c(.05, .2))) + \n  scale_y_continuous(expand = c(.05, 0, .2, 0))\n\n\n\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta el comportamiento diferente en los gráficos de la izquierda y del medio: el argumento add se especifica en la misma escala que la variable de datos, mientras que el argumento mult se especifica en relación con el rango del eje.\n\n\n\n\n\n\n\n\n\n\n\n\n\n10.1.4 Rupturas\nEstablecer las ubicaciones de las marcas de los ejes es una tarea común de visualización de datos. En ggplot2, las marcas de eje y las marcas de leyenda son casos especiales de “saltos de escala” y se pueden modificar utilizando el argumento breaks de la función de escala. Ilustraremos esto usando un conjunto de datos de juguetes que reaparecerá en varios lugares a lo largo de esta parte del libro:\n\ntoy &lt;- data.frame(\n  const = 1, \n  up = 1:4,\n  txt = letters[1:4], \n  big = (1:4)*1000,\n  log = c(2, 5, 10, 2000)\n)\ntoy\n#&gt;   const up txt  big  log\n#&gt; 1     1  1   a 1000    2\n#&gt; 2     1  2   b 2000    5\n#&gt; 3     1  3   c 3000   10\n#&gt; 4     1  4   d 4000 2000\n\nPara establecer pausas manualmente, pase un vector de valores de datos a breaks, o establezca breaks = NULL para eliminar por completo las pausas y las marcas de verificación correspondientes. En el siguiente gráfico, al eliminar las rupturas del eje y también se eliminan las líneas de cuadrícula correspondientes:\n\nbase &lt;- ggplot(toy, aes(big, const)) + \n  geom_point() + \n  labs(x = NULL, y = NULL) +\n  scale_y_continuous(breaks = NULL) \n\nbase\n\n\n\n\n\n\n\nAlternativamente, observe que cuando los saltos se establecen manualmente, se mueven las líneas de cuadrícula principales y las líneas de cuadrícula menores entre ellas:\nbase + scale_x_continuous(breaks = c(1000, 2000, 4000))\nbase + scale_x_continuous(breaks = c(1000, 1500, 2000, 4000))\n\n\n\n\n\n\n\n\n\n\nTambién es posible pasar una función a breaks. Esta función debe tener un argumento que especifique los límites de la escala (un vector numérico de longitud dos) y debe devolver un vector numérico de rupturas. Puedes escribir tu propia función de interrupción, pero en muchos casos no es necesaria gracias al paquete de escalas (Wickham y Seidel 2020). Proporciona varias herramientas que son útiles para este propósito:\n\n\nscales::breaks_extended() crea rupturas automáticas para los ejes numéricos.\n\nscales::breaks_log() crea rupturas apropiadas para los ejes del registro.\n\nscales::breaks_pretty() crea rupturas “bonitas” para fechas y horas.\n\nscales::breaks_width() crea rupturas igualmente espaciadas.\n\nLa función breaks_extended() es el método estándar utilizado en ggplot2 y, en consecuencia, los dos primeros gráficos a continuación son iguales. Podemos alterar el número deseado de rupturas configurando n = 2, como se ilustra en el tercer gráfico. Tenga en cuenta que breaks_extended() trata a n como una sugerencia en lugar de una restricción estricta. Si necesita especificar pausas exactas, es mejor hacerlo manualmente.\nbase \nbase + scale_x_continuous(breaks = scales::breaks_extended())\nbase + scale_x_continuous(breaks = scales::breaks_extended(n = 2))\n\n\n\n\n\n\n\n\n\n\n\n\n\nOtro enfoque que a veces resulta útil es especificar un width fijo que defina el espacio entre cortes. Para esto se utiliza la función breaks_width(). El primer ejemplo siguiente muestra cómo fijar el ancho en un valor específico; el segundo ejemplo ilustra el uso del argumento offset que desplaza todas las rupturas en una cantidad específica:\nbase + \n  scale_x_continuous(breaks = scales::breaks_width(800))\nbase + \n  scale_x_continuous(breaks = scales::breaks_width(800, offset = 200))\nbase + \n  scale_x_continuous(breaks = scales::breaks_width(800, offset = -200))\n\n\n\n\n\n\n\n\n\n\n\n\n\nObserve la diferencia entre establecer un desplazamiento de 200 y -200.\n\n10.1.5 Rupturas menores\n\nPuede ajustar las rupturas menores (las líneas tenues de la cuadrícula sin etiquetar que aparecen entre las líneas principales de la cuadrícula) proporcionando un vector numérico de posiciones al argumento minor_breaks.\nLas rupturas menores son particularmente útiles para las escalas logarítmicas porque dan un indicador visual claro de que la escala no es lineal. Para mostrarlos, primero crearemos un vector de valores de ruptura menores (en la escala transformada), usando %o% para generar rápidamente una tabla de multiplicar y as.numeric() para aplanar la tabla a un vector. .\n\nmb &lt;- unique(as.numeric(1:10 %o% 10 ^ (0:3)))\nmb\n#&gt;  [1]     1     2     3     4     5     6     7     8     9    10    20    30\n#&gt; [13]    40    50    60    70    80    90   100   200   300   400   500   600\n#&gt; [25]   700   800   900  1000  2000  3000  4000  5000  6000  7000  8000  9000\n#&gt; [37] 10000\n\nLos siguientes gráficos ilustran el efecto de establecer las pausas menores:\nbase &lt;- ggplot(toy, aes(log, const)) + \n  geom_point() + \n  labs(x = NULL, y = NULL) +\n  scale_y_continuous(breaks = NULL) \n\nbase + scale_x_log10()\nbase + scale_x_log10(minor_breaks = mb)\n\n\n\n\n\n\n\n\n\n\nAl igual que con breaks, también puedes proporcionar una función a minor_breaks, como las funciones scales::minor_breaks_n() o scales::minor_breaks_width() que pueden ser útiles para controlar los breaks menores.\n\n10.1.6 Etiquetas\nCada ruptura está asociada con una etiqueta y estas se pueden cambiar configurando el argumento labels en la función de escala:\nbase &lt;- ggplot(toy, aes(big, const)) + \n  geom_point() + \n  labs(x = NULL, y = NULL) +\n  scale_y_continuous(breaks = NULL) \n\nbase\nbase + \n  scale_x_continuous(\n    breaks = c(2000, 4000), \n    labels = c(\"2k\", \"4k\")\n  ) \n\n\n\n\n\n\n\n\n\n\nA menudo, no es necesario configurar las etiquetas manualmente y, en su lugar, puede especificar una función de etiquetado de la misma manera que lo hace con las rupturas. Una función pasada a label debe aceptar un vector numérico de saltos como entrada y devolver un vector de caracteres de etiquetas (la misma longitud que la entrada). Nuevamente, el paquete de escalas proporciona una serie de herramientas que construirán automáticamente funciones de etiquetas. Algunos de los ejemplos más útiles de datos numéricos incluyen:\n\n\nscales::label_bytes() formatea números como kilobytes, megabytes, etc.\n\nscales::label_comma() formatea los números como decimales con comas agregadas.\n\nscales::label_dollar() formatea los números como moneda.\n\nscales::label_ordinal() formatea los números en orden de clasificación: 1.st, 2.nd, 3.rd, etc.\n\nscales::label_percent() formatea los números como porcentajes.\n\nscales::label_pvalue() formatea los números como valores p: &lt;.05, &lt;.01, .34, etc.\n\nA continuación se muestran algunos ejemplos para ilustrar cómo se utilizan estas funciones:\nbase &lt;- ggplot(toy, aes(big, const)) + \n  geom_point() + \n  labs(x = NULL, y = NULL) +\n  scale_x_continuous(breaks = NULL)\n\nbase\nbase + scale_y_continuous(labels = scales::label_percent())\nbase + scale_y_continuous(\n  labels = scales::label_dollar(prefix = \"\", suffix = \"€\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPuede suprimir etiquetas con labels = NULL. Esto eliminará las etiquetas del eje o leyenda y dejará sus otras propiedades sin cambios. Observe la diferencia entre configurar breaks = NULL y labels = NULL:\nbase + scale_y_continuous(breaks = NULL)\nbase + scale_y_continuous(labels = NULL)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10.1.7 Transformaciones\nCuando se trabaja con datos continuos, el valor predeterminado es mapear linealmente desde el espacio de datos al espacio estético. Es posible anular este valor predeterminado mediante transformaciones de escala, que alteran la forma en que se realiza este mapeo. En algunos casos no es necesario profundizar en los detalles, porque existen funciones convenientes como scale_x_log10(), scale_x_reverse() que puede hacer el trabajo por usted:\nbase &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()\n\nbase\nbase + scale_x_reverse()\nbase + scale_y_reverse()\n\n\n\n\n\n\n\n\n\n\n\n\n\nSin embargo, incluso en estos casos una comprensión más profunda puede resultar valiosa. Cada escala continua toma un argumento trans, lo que permite el uso de una variedad de transformaciones: \n# convertir de economía de combustible a consumo de combustible\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  scale_y_continuous(trans = \"reciprocal\")\n\n# transformación logarítmica de los ejes x e y\nggplot(diamonds, aes(price, carat)) + \n  geom_bin2d() + \n  scale_x_continuous(trans = \"log10\") +\n  scale_y_continuous(trans = \"log10\")\n\n\n\n\n\n\n\n\n\n\nLa transformación la lleva a cabo un “transformador”, que describe la transformación, su inversa y cómo dibujar las etiquetas. Puedes construir tu propio transformador usando scales::trans_new(), pero como lo ilustran los gráficos anteriores, ggplot2 comprende muchas transformaciones comunes proporcionadas por el paquete scales. La siguiente tabla enumera algunas de las variantes más comunes:\n\n\n\n\n\n\n\n\nNombre\nTransformador\nFunción \\(f(x)\\)\n\nInversa \\(f^{-1}(x)\\)\n\n\n\n\n\"asn\"\nscales::asn_trans()\n\\(\\tanh^{-1}(x)\\)\n\\(\\tanh(y)\\)\n\n\n\"exp\"\nscales::exp_trans()\n\\(e ^ x\\)\n\\(\\log(y)\\)\n\n\n\"identity\"\nscales::identity_trans()\n\\(x\\)\n\\(y\\)\n\n\n\"log\"\nscales::log_trans()\n\\(\\log(x)\\)\n\\(e ^ y\\)\n\n\n\"log10\"\nscales::log10_trans()\n\\(\\log_{10}(x)\\)\n\\(10 ^ y\\)\n\n\n\"log2\"\nscales::log2_trans()\n\\(\\log_2(x)\\)\n\\(2 ^ y\\)\n\n\n\"logit\"\nscales::logit_trans()\n\\(\\log(\\frac{x}{1 - x})\\)\n\\(\\frac{1}{1 + e(y)}\\)\n\n\n\"probit\"\nscales::probit_trans()\n\\(\\Phi(x)\\)\n\\(\\Phi^{-1}(y)\\)\n\n\n\"reciprocal\"\nscales::reciprocal_trans()\n\\(x^{-1}\\)\n\\(y^{-1}\\)\n\n\n\"reverse\"\nscales::reverse_trans()\n\\(-x\\)\n\\(-y\\)\n\n\n\"sqrt\"\nscales::scale_x_sqrt()\n\\(x^{1/2}\\)\n\\(y ^ 2\\)\n\n\n\nPuede especificar el argumento trans como una cadena que contiene el nombre de la transformación o llamando al transformador directamente. Los siguientes son equivalentes:\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  scale_y_continuous(trans = \"reciprocal\")\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  scale_y_continuous(trans = scales::reciprocal_trans())\n\n\n\nEn algunos casos, ggplot2 simplifica esto aún más y proporciona funciones convenientes para las transformaciones más comunes: scale_x_log10(), scale_x_sqrt() y scale_x_reverse() proporcionan la transformación relevante en el eje x, con funciones similares proporcionadas. para el eje y. Por tanto, estas dos especificaciones de gráfica también son equivalentes:\nggplot(diamonds, aes(price, carat)) + \n  geom_bin2d() + \n  scale_x_continuous(trans = \"log10\") +\n  scale_y_continuous(trans = \"log10\")\n\nggplot(diamonds, aes(price, carat)) + \n  geom_bin2d() + \n  scale_x_log10() +\n  scale_y_log10()\n\n\n\nTenga en cuenta que no hay nada que le impida realizar estas transformaciones manualmente. Por ejemplo, en lugar de usar scale_x_log10() para transformar la escala, podría transformar los datos y trazar log10(x). La apariencia de la geom será la misma, pero las etiquetas de marca serán diferentes. Específicamente, si utiliza una escala transformada, los ejes se etiquetarán en el espacio de datos original; Si transforma los datos, los ejes se etiquetarán en el espacio transformado. Como consecuencia, estas especificaciones de la gráfica son ligeramente diferentes:\n# transformación manual\nggplot(mpg, aes(log10(displ), hwy)) + \n  geom_point()\n\n# transformar usando escalas\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  scale_x_log10()\n\n\n\n\n\n\n\n\n\n\nIndependientemente del método que utilice, la transformación se produce antes de cualquier resúmenes estadísticos. Para transformar después del cálculo estadístico utilice coord_trans(). Consulte Sección 15.1 para obtener más detalles sobre los sistemas de coordenadas y Sección 14.6 si necesita transformar algo que no sea una escala de posición numérica.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Escalas de posición y ejes.</span>"
    ]
  },
  {
    "objectID": "scales-position.html#sec-date-scales",
    "href": "scales-position.html#sec-date-scales",
    "title": "10  Escalas de posición y ejes.",
    "section": "\n10.2 Escalas de posición de fecha y hora",
    "text": "10.2 Escalas de posición de fecha y hora\n \nUn caso especial de posición numérica surge cuando una estética se asigna a un tipo de fecha/hora. Ejemplos de tipos de fecha/hora incluyen las clases base Date (para fechas) y POSIXct (para fechas y horas), así como la clase hms para valores de “hora del día” proporcionada por el paquete hms [@ hms]. Si sus fechas están en un formato diferente, necesitará convertirlas usando as.Date(), as.POSIXct() o hms::as_hms(). También puede encontrar útil el paquete lubridate para manipular datos de fecha/hora. (Grolemund y Wickham 2011).\nSuponiendo que tiene datos formateados apropiadamente asignados a la estética x, ggplot2 usará scale_x_date() como escala predeterminada para fechas y scale_x_datetime() como escala predeterminada para datos de fecha y hora. Las escalas correspondientes para otras estéticas siguen las reglas de nomenclatura habituales. Las escalas de fechas se comportan de manera similar a otras escalas continuas, pero contienen argumentos adicionales que le permiten trabajar en unidades compatibles con las fechas. Esta sección analiza las escalas de fecha y hora para la estética de la posición: consulte ?sec-date-color-scales para conocer la estética del color y el relleno.\n\n10.2.1 Rupturas\nEl argumento date_breaks le permite colocar saltos por unidades de fecha (años, meses, semanas, días, horas, minutos y segundos). Por ejemplo, date_breaks = \"2 weeks\" colocará una marca importante cada dos semanas y date_breaks = \"15 years\" las colocará cada 15 años:\ndate_base &lt;- ggplot(economics, aes(date, psavert)) + \n  geom_line(na.rm = TRUE) +\n  labs(x = NULL, y = NULL)\n\ndate_base \ndate_base + scale_x_date(date_breaks = \"15 years\")\n\n\n\n\n\n\n\n\n\n\nEn comparación con el gráfico de la izquierda, dos cosas han cambiado en el gráfico de la derecha: las marcas se colocan en intervalos de 15 años y el formato de la etiqueta ha cambiado. Analizaremos el etiquetado de fechas en Sección 10.2.3, pero por ahora nos centraremos en las pausas.\nPara entender cómo ggplot2 interpreta date_breaks = \"15 years\", es útil tener en cuenta que es simplemente una abreviatura conveniente para configurar breaks = scales::breaks_width(\"15 years\"). La forma más larga suele ser innecesaria, pero puede ser útil si, como se explica en Sección 10.1.4, desea especificar un offset. Por ejemplo, supongamos que el objetivo es trazar datos que abarquen un año calendario, con rupturas mensuales. Especificar date_breaks = \"1 month\" es equivalente a configurar scales::breaks_width(\"1 month\"), lo que produce estas rupturas:\n\nthe_year &lt;- as.Date(c(\"2021-01-01\", \"2021-12-31\"))\nset_breaks &lt;- scales::breaks_width(\"1 month\")\nset_breaks(the_year)\n#&gt;  [1] \"2021-01-01\" \"2021-02-01\" \"2021-03-01\" \"2021-04-01\" \"2021-05-01\"\n#&gt;  [6] \"2021-06-01\" \"2021-07-01\" \"2021-08-01\" \"2021-09-01\" \"2021-10-01\"\n#&gt; [11] \"2021-11-01\" \"2021-12-01\" \"2022-01-01\"\n\nEn este ejemplo, la función set_breaks() devuelta por scales::break_width() produce rupturas espaciadas con un mes de diferencia, donde la fecha de cada descanso cae en el primer día del mes. Por lo general, es sensato colocar cada pausa al comienzo del año calendario, pero hay excepciones. Quizás los datos rastrean los ingresos y gastos de un hogar en el que se paga un salario mensual el noveno día de cada mes. En esta situación puede ser sensato alinear las rupturas con los depósitos salariales. Para hacer esto, podemos establecer offset = 8 cuando definimos la función set_breaks():\n\nset_breaks &lt;- scales::breaks_width(\"1 month\", offset = 8)\nset_breaks(the_year)\n#&gt;  [1] \"2021-01-09\" \"2021-02-09\" \"2021-03-09\" \"2021-04-09\" \"2021-05-09\"\n#&gt;  [6] \"2021-06-09\" \"2021-07-09\" \"2021-08-09\" \"2021-09-09\" \"2021-10-09\"\n#&gt; [11] \"2021-11-09\" \"2021-12-09\" \"2022-01-09\"\n\n\n10.2.2 Rupturas menores\nLas escalas de fecha/hora también tienen un argumento date_minor_breaks que le permite especificar las pausas menores al usar unidades de fecha, exactamente de la misma manera que lo hace date_breaks para las pausas mayores. Para ilustrar esto, definiremos un gráfico vacío con una escala de fecha en el eje y y modificaremos el tema (?sec-polising) para que las líneas de la cuadrícula sean más prominentes visualmente:\ndf &lt;- data.frame(y = as.Date(c(\"2022-01-01\", \"2022-04-01\")))\nbase &lt;- ggplot(df, aes(y = y)) + \n  labs(y = NULL) + \n  theme_minimal() + \n  theme(\n    panel.grid.major = element_line(colour = \"black\"),\n    panel.grid.minor = element_line(colour = \"grey50\")\n  )\n\nbase + scale_y_date(date_breaks = \"1 month\")\nbase + \n  scale_y_date(date_breaks = \"1 month\", date_minor_breaks = \"1 week\")\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta que en el primer gráfico, las pausas menores están espaciadas uniformemente entre las pausas principales mensuales. En el segundo gráfico, las rupturas mayores y menores siguen patrones ligeramente diferentes: las rupturas menores siempre están separadas por 7 días, pero las rupturas mayores están separadas por 1 mes. Debido a que los meses varían en duración, esto genera un espaciamiento ligeramente desigual.\n\n10.2.3 Etiquetas\nLas escalas de fecha contienen un argumento labels que se comporta de manera similar al argumento correspondiente para escalas numéricas, pero a menudo es más conveniente usar el argumento date_labels. Controla la visualización de las etiquetas utilizando las mismas cadenas de formato que en strptime() y format(). Para mostrar fechas como 14/10/1979, por ejemplo, usaría la cadena \"%d/%m/%Y\": en esta expresión %d produce un día numérico del mes, %m produce un mes numérico y %Y produce un año de cuatro dígitos. La siguiente tabla proporciona una lista de texto de formato:\n\n\nTexto\nSignificado\n\n\n\n%S\nsegundo (00-59)\n\n\n%M\nminuto (00-59)\n\n\n%l\nhora, en reloj de 12-horas (1-12)\n\n\n%I\nhora, en reloj de 12-horas (01-12)\n\n\n%p\nam/pm\n\n\n%H\nhora, en reloj de 24-horas (00-23)\n\n\n%a\ndía de la semana, abreviado (Mon-Sun)\n\n\n%A\ndía de la semana, completo (Monday-Sunday)\n\n\n%e\ndía del mes (1-31)\n\n\n%d\ndía del mes (01-31)\n\n\n%m\nmes, númerico (01-12)\n\n\n%b\nmes, abreviado (Jan-Dec)\n\n\n%B\nmes, completo (January-December)\n\n\n%y\naño, sin siglo (00-99)\n\n\n%Y\naño, con siglo (0000-9999)\n\n\n\nUn escenario útil para el formato de etiquetas de fecha es cuando no hay suficiente espacio para especificar un año de cuatro dígitos. El uso de %y garantiza que solo se muestren los dos últimos dígitos:\nbase &lt;- ggplot(economics, aes(date, psavert)) + \n  geom_line(na.rm = TRUE) +\n  labs(x = NULL, y = NULL)\n\nbase + scale_x_date(date_breaks = \"5 years\")\nbase + scale_x_date(date_breaks = \"5 years\", date_labels = \"%y\")\n\n\n\n\n\n\n\n\n\n\nPuede resultar útil incluir el carácter de salto de línea \\n en una cadena de formato, especialmente cuando se incluyen nombres completos de meses:\nlim &lt;- as.Date(c(\"2004-01-01\", \"2005-01-01\"))\n\nbase + scale_x_date(limits = lim, date_labels = \"%b %y\")\nbase + scale_x_date(limits = lim, date_labels = \"%B\\n%Y\")\n\n\n\n\n\n\n\n\n\n\nEn estos ejemplos hemos especificado las etiquetas manualmente mediante el argumento date_labels. Un enfoque alternativo es pasar una función de etiquetado al argumento labels, de la misma manera que describimos en Sección 10.1.6. Puede escribir su propia función de etiquetado personalizada, pero esto suele ser innecesario. El paquete scales proporciona funciones convenientes que pueden generar etiquetas para usted, en particular scales::label_date() y scales::label_date_short(). Rara vez necesitas llamar a scales::label_date() directamente, porque esa es la función que usa date_labels. Sin embargo, si desea utilizar scales::label_date_short() deberá hacerlo explícitamente. El objetivo de label_date_short() es construir automáticamente etiquetas cortas que sean suficientes para identificar de forma única las fechas:\n\nbase + \n  scale_x_date(\n    limits = lim, \n    labels = scales::label_date_short()\n  )\n\n\n\n\n\n\n\nA menudo, esto puede producir gráficas más claras: en el ejemplo anterior, cada año se etiqueta solo una vez en lugar de aparecer en cada etiqueta, lo que reduce la cantidad de desorden visual y facilita al espectador ver dónde comienza y termina cada año.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Escalas de posición y ejes.</span>"
    ]
  },
  {
    "objectID": "scales-position.html#sec-discrete-position",
    "href": "scales-position.html#sec-discrete-position",
    "title": "10  Escalas de posición y ejes.",
    "section": "\n10.3 Escalas de posición discreta",
    "text": "10.3 Escalas de posición discreta\nTambién es posible asignar variables discretas a escalas de posición, siendo las escalas predeterminadas scale_x_discrete() y scale_y_discrete(). Por ejemplo, las siguientes dos especificaciones de trazado son equivalentes\n\nggplot(mpg, aes(x = hwy, y = class)) + \n  geom_point()\n\nggplot(mpg, aes(x = hwy, y = class)) + \n  geom_point() + \n  scale_x_continuous() +\n  scale_y_discrete()\n\nInternamente, ggplot2 maneja escalas discretas asignando cada categoría a un valor entero y luego dibujando la geom en la ubicación de coordenadas correspondiente. Para ilustrar esto, podemos agregar una anotación personalizada (consulte Sección 8.3) al gráfico:\n\nggplot(mpg, aes(x = hwy, y = class)) + \n  geom_point() +\n  annotate(\"text\", x = 5, y = 1:7, label = 1:7)\n\n\n\n\n\n\n\nMapear cada categoría a un valor entero es útil porque significa que se pueden especificar otras cantidades de ancho como una proporción del rango de categorías. Por ejemplo, en el gráfico anterior, podríamos especificar una fluctuación vertical para cada punto que abarque la mitad del ancho del contenedor de categorías implícito:\n\nggplot(mpg, aes(x = hwy, y = class)) + \n  geom_jitter(width = 0, height = .25) +\n  annotate(\"text\", x = 5, y = 1:7, label = 1:7)\n\n\n\n\n\n\n\nEl mismo mecanismo sustenta los anchos de las barras y los diagramas de caja. Debido a que cada categoría tiene un ancho de 1 en una escala discreta, establecer width = .4 cuando se usa geom_boxplot() garantiza que el cuadro ocupe el 40% del ancho asignado a la categoría:\nggplot(mpg, aes(x = drv, y = hwy)) + geom_boxplot()\nggplot(mpg, aes(x = drv, y = hwy)) + geom_boxplot(width = .4)\n\n\n\n\n\n\n\n\n\n\n\n10.3.1 Límites, rupturas y etiquetas\n \nLos límites, se rompe. y las etiquetas para una escala de posición discreta se pueden establecer usando los argumentos limits, breaks y labels. En su mayor parte, estos se comportan de manera idéntica a los argumentos correspondientes para escalas numéricas (Sección 10.1), aunque existen algunas diferencias. Por ejemplo, los límites de una escala discreta no se definen en términos de puntos finales, sino que corresponden al conjunto de valores permitidos para esa variable. En consecuencia, ggplot2 espera que los limits de una escala discreta sean un vector de caracteres que enumere todos los valores posibles en el orden en que deberían aparecer:\nbase &lt;- ggplot(toy, aes(const, txt)) + \n  geom_label(aes(label = txt)) +\n  scale_x_continuous(breaks = NULL) +\n  labs(x = NULL, y = NULL)\n\nbase \nbase + scale_y_discrete(limits = c(\"a\", \"b\", \"c\", \"d\", \"e\"))\nbase + scale_y_discrete(limits = c(\"d\", \"c\", \"a\", \"b\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nEl argumento breaks prácticamente no ha cambiado y enumera un conjunto de valores que se mostrarán en las etiquetas de los ejes. El argumento labels para escalas discretas tiene alguna funcionalidad adicional: también tiene la opción de usar un vector con nombre para establecer las etiquetas asociadas con valores particulares. Esto permite cambiar unas etiquetas y otras no, sin alterar el orden ni las rupturas:\nbase + scale_y_discrete(breaks = c(\"b\", \"c\"))\nbase + scale_y_discrete(labels = c(c = \"carrot\", b = \"banana\")) \n\n\n\n\n\n\n\n\n\n\nAl igual que con otras escalas, las escalas de posición discreta le permiten pasar una función al argumento labels. La función scales::label_wrap() puede ser particularmente valiosa para datos categóricos, ya que le permite ajustar cadenas largas en varias líneas.\n\n10.3.2 Posiciones de etiquetas\nAl trazar datos categóricos, a menudo es necesario mover las etiquetas de los ejes de alguna manera para evitar que se superpongan:\n\nbase &lt;- ggplot(mpg, aes(manufacturer, hwy)) + geom_boxplot() \nbase\n\n\n\n\n\n\n\nIncluso cuando se le asigna mucho espacio horizontal, las etiquetas de los ejes se superponen considerablemente en este gráfico. Podemos controlar esto con la ayuda de la función guides(), que funciona de manera similar a la función auxiliar labs() descrita en Sección 8.1. Ambos toman el nombre de diferentes estéticas (por ejemplo, color, x, relleno) como argumentos y le permiten especificar su propio valor. Para una estética de posición, usamos guide_axis() para indicarle a ggplot2 cómo queremos modificar las etiquetas de los ejes. Por ejemplo, podríamos decirle a ggplot2 que “esquive” la posición de las etiquetas configurando guide_axis(n.dodge = 3), o que las rote configurando guide_axis(angle = 90):\nbase + guides(x = guide_axis(n.dodge = 3))\nbase + guides(x = guide_axis(angle = 90))\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta que, de la misma manera que labs() es una forma abreviada de especificar el argumento name en una o más escalas, la función guides() es una forma abreviada de establecer los argumentos guide en una o más escalas. Entonces el siguiente código logra el mismo resultado:\nbase + scale_x_discrete(guide = guide_axis(n.dodge = 3))\nbase + scale_x_discrete(guide = guide_axis(angle = 90))\n\n\n\nPara obtener más información sobre las funciones de guía, consulte Sección 14.5.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Escalas de posición y ejes.</span>"
    ]
  },
  {
    "objectID": "scales-position.html#sec-binned-position",
    "href": "scales-position.html#sec-binned-position",
    "title": "10  Escalas de posición y ejes.",
    "section": "\n10.4 Escalas de posición agrupadas",
    "text": "10.4 Escalas de posición agrupadas\nUna variación de las escalas de posición discretas son las escalas agrupadas, donde una variable continua se divide en varias ubicaciones y se traza la variable discretizada. Para la estética de la posición, las escalas agrupadas se utilizan principalmente para crear histogramas y gráficos relacionados. El siguiente ejemplo muestra cómo aproximar el comportamiento de geom_histogram() usando geom_bar() en combinación con una escala de posición agrupada:\nggplot(mpg, aes(hwy)) + geom_histogram(bins = 8)\nggplot(mpg, aes(hwy)) + \n  geom_bar() +\n  scale_x_binned() \n\n\n\n\n\n\n\n\n\n\nEn la práctica, este no es el ejemplo más útil, ya que geom_histogram() ya existe y proporciona valores predeterminados que generalmente son más apropiados para histogramas, pero la técnica se puede ampliar. Supongamos que queremos usar geom_count() en lugar de geom_point() para mostrar el número de observaciones en cada ubicación. La ventaja de geom_count() es que el tamaño de cada punto aumenta con el número de observaciones en cada ubicación, pero como ilustra la siguiente figura, este método no funciona muy bien cuando los datos varían continuamente:\n\nbase &lt;- ggplot(mpg, aes(displ, hwy)) + \n  geom_count()\n\nbase\n\n\n\n\n\n\n\nEsta gráfica está bastante desordenada y no es particularmente fácil de leer. Para mejorar esto, podemos usar scale_x_binned() para cortar los valores en contenedores antes de pasarlos a la geom:\n\nbase + \n  scale_x_binned(n.breaks = 15) +\n  scale_y_binned(n.breaks = 15)\n\n\n\n\n\n\n\nPuede leer más sobre cómo se utilizan las escalas agrupadas para la estética sin posición en ?sec-binned-color y Sección 12.1.2.\n\n\n\n\nGrolemund, Garrett, y Hadley Wickham. 2011. «Dates and Times Made Easy with lubridate». Journal of Statistical Software 40 (3): 1-25. http://www.jstatsoft.org/v40/i03/.\n\n\nWickham, Hadley, y Dana Seidel. 2020. scales: Scale Functions for Visualization. https://CRAN.R-project.org/package=scales.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Escalas de posición y ejes.</span>"
    ]
  },
  {
    "objectID": "scales-colour.html",
    "href": "scales-colour.html",
    "title": "11  Escalas de colores y leyendas.",
    "section": "",
    "text": "11.1 Un poco de teoría del color.\nDespués de la posición, la estética más utilizada es la basada en el color, y hay muchas formas de asignar valores a colores en ggplot2. Debido a que el color es complejo, el capítulo comienza con una discusión sobre la teoría del color (?sec-color-theory) con especial referencia al daltonismo (?sec-color-blindness). Reflejando la estructura de los capítulos anteriores, las siguientes tres secciones están dedicadas a escalas de color continuas (?sec-color-continuous), escalas de colores discretas (?sec-color-discrete) y escalas de colores agrupadas (?sec-binned-color). ). El capítulo concluye analizando las escalas de color de fecha/hora (?sec-date-color-scales), las escalas de transparencia (Sección 11.6) y la mecánica del posicionamiento de la leyenda (Sección 11.7).\nAntes de ver los detalles, es útil aprender un poco de teoría del color. La teoría del color es compleja porque la biología subyacente del ojo y el cerebro es compleja, y esta introducción sólo tocará algunas de las cuestiones más importantes. Una exposición excelente y más detallada está disponible en línea en http://tinyurl.com/clrdtls.\nA nivel físico, el color se produce por una mezcla de longitudes de onda de luz. Para caracterizar completamente un color, necesitamos conocer la mezcla completa de longitudes de onda. Afortunadamente para nosotros, el ojo humano sólo tiene tres receptores de color diferentes, por lo que podemos resumir la percepción de cualquier color en sólo tres números. Quizás esté familiarizado con la codificación RGB del espacio de color, que define un color según las intensidades de luz roja, verde y azul necesarias para producirlo. Un problema con este espacio es que no es perceptualmente uniforme: los dos colores que están separados por una unidad pueden parecer similares o muy diferentes dependiendo de dónde se encuentren en el espacio de color. Esto dificulta la creación de un mapeo de una variable continua a un conjunto de colores. Ha habido muchos intentos de crear espacios de color que sean más perceptualmente uniformes. Usaremos un intento moderno llamado espacio de color HCL, que tiene tres componentes: hue, chroma y lluminance:\nLas tres dimensiones tienen propiedades diferentes. Los tonos están dispuestos alrededor de una rueda de colores y no se perciben como ordenados: p.e. el verde no parece “más grande” que el rojo, y el azul no parece estar “entre” el verde y el rojo. Por el contrario, tanto el croma como la luminancia se perciben como ordenados: el rosa se percibe entre el rojo y el blanco, y el gris entre el blanco y el negro.\nLa combinación de estos tres componentes no produce una forma geométrica simple. La siguiente figura intenta mostrar la forma tridimensional del espacio. Cada corte es una luminancia (brillo) constante con tono asignado al ángulo y croma al radio. Puedes ver que el centro de cada rebanada es gris y los colores se vuelven más intensos a medida que se acercan al borde.\nLa forma del espacio de color HCL. El tono se asigna al ángulo, el croma al radio y cada corte muestra una luminancia diferente. El espacio HCL tiene una forma bastante extraña, pero puedes ver que los colores cerca del centro de cada segmento son grises y, a medida que avanzas hacia los bordes, se vuelven más intensos. Se omiten los cortes para las luminancias 0 y 100 porque serían, respectivamente, un único punto negro y un único punto blanco.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Escalas de colores y leyendas.</span>"
    ]
  },
  {
    "objectID": "scales-colour.html#sec-colour-theory",
    "href": "scales-colour.html#sec-colour-theory",
    "title": "11  Escalas de colores y leyendas.",
    "section": "",
    "text": "Hue varía de 0 a 360 (un ángulo) y proporciona el “color” del color (azul, rojo, naranja, etc.).\n\nChroma es la “pureza” de un color, que va desde 0 (gris) hasta un máximo que varía con la luminancia.\n\nLuminance es la luminosidad del color, que va de 0 (negro) a 1 (blanco).\n\n\n\n\n\n11.1.1 Daltonismo\nUna complicación adicional es que una minoría considerable de personas no posee el complemento habitual de receptores de color y, por tanto, puede distinguir menos colores que otros. Debido a esto, es importante considerar cómo se verá una paleta de colores para las personas con formas comunes de daltonismo. Una heurística simple es evitar los contrastes rojo-verde y verificar sus gráficos con sistemas que simulen el daltonismo. Además de las muchas herramientas en línea que pueden ayudar con esto (por ejemplo, https://www.vischeck.com/), existen varios paquetes de R que proporcionan herramientas que pueden resultarle útiles. El paquete dicromático (dichroma?) proporciona herramientas para simular el daltonismo y un conjunto de combinaciones de colores que se sabe que funcionan bien para las personas daltónicas. Otra herramienta útil es el paquete colorBlindness (Ou 2021) que proporciona una función displayAllColors() que le ayuda a aproximar la apariencia de un conjunto determinado de colores bajo diferentes formas de daltonismo. A modo de ilustración, revela rápidamente que los colores proporcionados por la paleta rainbow() no son apropiados si estás tratando de crear gráficos que sean legibles para personas daltónicas, ni se reproducen bien en escala de grises:\n\ncolorBlindness::displayAllColors(rainbow(6))\n\n\n\n\n\n\n\nA modo de contraste, los colores proporcionados por viridis::viridis() son discriminables bajo las formas más comunes de daltonismo y se reproducen bien en escala de grises:\n\ncolorBlindness::displayAllColors(viridis::viridis(6))\n\n\n\n\n\n\n\nAdemás del paquete viridis, existen otros paquetes R que proporcionan paletas que son explícitamente seguras para daltónicos y los verá en uso a lo largo del capítulo. Finalmente, también puedes ayudar a las personas con daltonismo de la misma manera que puedes ayudar a las personas con impresoras en blanco y negro: proporcionando asignaciones redundantes a otras estéticas como el tamaño, el tipo de línea o la forma.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Escalas de colores y leyendas.</span>"
    ]
  },
  {
    "objectID": "scales-colour.html#sec-colour-continuous",
    "href": "scales-colour.html#sec-colour-continuous",
    "title": "11  Escalas de colores y leyendas.",
    "section": "\n11.2 Escalas de color continuas",
    "text": "11.2 Escalas de color continuas\nLos degradados de color se utilizan a menudo para mostrar la altura de una superficie 2D. Los gráficos de esta sección utilizan la superficie de una estimación de densidad 2D del conjunto de datos faithful (Azzalini y Bowman 1990), que registra el tiempo de espera entre erupciones y durante cada erupción del géiser Old Faithful en el Parque Yellowstone. Ocultamos las leyendas y configuramos expand en 0, para centrarnos en la apariencia de los datos. Recuerde: aunque usamos la gráfica erupt para ilustrar conceptos usando una estética de relleno, las mismas ideas se aplican a las escalas de color. Cada vez que hacemos referencia a scale_fill_*() en esta sección, hay un scale_color_*() correspondiente para la estética del color (o scale_color_*() si prefiere la ortografía estadounidense). \n\nerupt &lt;- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) +\n  geom_raster() +\n  scale_x_continuous(NULL, expand = c(0, 0)) + \n  scale_y_continuous(NULL, expand = c(0, 0)) + \n  theme(legend.position = \"none\")\n\n\n11.2.1 Paletas particulares\nHay varias formas de especificar escalas de color continuas. Más adelante hablaremos sobre herramientas de uso general que puede utilizar para construir su propia paleta, pero esto suele ser innecesario ya que hay muchas paletas “seleccionadas a mano” disponibles. Por ejemplo, ggplot2 proporciona dos funciones de escala que agrupan paletas preespecificadas, scale_fill_viridis_c() y scale_fill_distiller(). Las escalas viridis (Garnier 2018) están diseñadas para ser perceptualmente uniformes tanto en color como cuando se reducen a blanco y negro, y para ser perceptibles para personas con diversas formas de daltonismo.\nerupt\nerupt + scale_fill_viridis_c()\nerupt + scale_fill_viridis_c(option = \"magma\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara la mayoría de los casos de uso, las escalas viridis funcionarán mejor que otras escalas continuas integradas en ggplot2, pero existen otras opciones que son útiles en algunas situaciones. Un segundo grupo de escalas de color continuas integradas en ggplot2 se derivan de las escalas de ColorBrewer: scale_fill_brewer() proporciona estos colores como paletas discretas, mientras que scale_fill_distiller() y scale_fill_fermenter() son los análogos continuos y agrupados. Analizamos estas escalas en ?sec-color-discrete, pero con fines ilustrativos incluimos algunos ejemplos aquí:\nerupt + scale_fill_distiller()\nerupt + scale_fill_distiller(palette = \"RdPu\")\nerupt + scale_fill_distiller(palette = \"YlOrBr\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nHay muchos otros paquetes que proporcionan paletas de colores útiles. Por ejemplo, scico (Pedersen y Crameri 2020) proporciona más paletas que son perceptualmente uniformes y adecuadas para la visualización científica:\nerupt + scico::scale_fill_scico(palette = \"bilbao\") # por defecto\nerupt + scico::scale_fill_scico(palette = \"vik\")\nerupt + scico::scale_fill_scico(palette = \"lajolla\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nSin embargo, como hay muchos paquetes de paletas en R, un paquete particularmente útil es Paletteer (Hvitfeldt 2020), cuyo objetivo es proporcionar una interfaz común:\nerupt + paletteer::scale_fill_paletteer_c(\"viridis::plasma\")\nerupt + paletteer::scale_fill_paletteer_c(\"scico::tokyo\")\n\n\n\n\n\n\n\n\n\n\n\n11.2.2 Recetas robustas\nLa escala predeterminada para escalas de relleno continuo es scale_fill_continuous() que a su vez por defecto es scale_fill_gradient(). Como consecuencia, estos tres comandos producen el mismo gráfico usando una escala de gradiente:\nerupt\nerupt + scale_fill_continuous()\nerupt + scale_fill_gradient()\n\n\n\n\n\n\n\n\n\n\n\n\n\nLas escalas de degradado proporcionan un método sólido para crear cualquier combinación de colores que desee. Todo lo que necesitas hacer es especificar dos o más colores de referencia y ggplot2 interpolará linealmente entre ellos. Hay tres funciones que puede utilizar para este propósito: \n\n\nscale_fill_gradient() produce un degradado de dos colores\n\nscale_fill_gradient2() produce un degradado de tres colores con un punto medio especificado\n\nscale_fill_gradientn() produce un gradiente de n colores\n\nThe use of gradient scales is illustrated below. The first plot uses a scale that linearly interpolates from grey (hex code: \"#bebebe\") at the low end of the scale limits to brown (\"#a52a2a\") at the high end. The second plot has the same endpoints but uses scale_fill_gradient2() to interpolate first from grey to white (#ffffff) and then from white to brown. Note that the mid argument specifies the colour to be shown at the intermediate point, and midpoint is the value in the data at which this colour is used (the default is midpoint = 0). The third method is to use scale_fill_gradientn() which takes a vector of reference colours as its argument, and constructs a scale that linearly interpolates between the specified values. By default, the colours are presumed to be equally spaced along the scale, but if you prefer you can specify a vector of values that correspond to each of the reference colours.\nEl uso de escalas de gradiente se ilustra a continuación. El primer gráfico utiliza una escala que interpola linealmente desde el gris (código hexadecimal: \"#bebebe\") en el extremo inferior low de los límites de la escala hasta el marrón (\"#a52a2a\") en el extremo alto high. El segundo gráfico tiene los mismos puntos finales pero usa scale_fill_gradient2() para interpolar primero de gris a blanco (#ffffff) y luego de blanco a marrón. Tenga en cuenta que el argumento mid especifica el color que se mostrará en el punto intermedio, y midpoint es el valor de los datos en el que se utiliza este color (el valor predeterminado es midpoint = 0). El tercer método es utilizar scale_fill_gradientn() que toma un vector de colores de referencia como argumento y construye una escala que interpola linealmente entre los valores especificados. De forma predeterminada, se supone que los “colores” están igualmente espaciados a lo largo de la escala, pero si lo prefiere, puede especificar un vector de values que corresponda a cada uno de los colores de referencia.\nerupt + scale_fill_gradient(low = \"grey\", high = \"brown\")\nerupt + \n  scale_fill_gradient2(\n    low = \"grey\", \n    mid = \"white\", \n    high = \"brown\", \n    midpoint = .02\n  )\nerupt + scale_fill_gradientn(colours = terrain.colors(7))\n\n\n\n\n\n\n\n\n\n\n\n\n\nCrear buenas paletas de colores requiere cierto cuidado. Generalmente, para una escala de gradiente de dos puntos desea transmitir la impresión perceptiva de que los valores están ordenados secuencialmente, por lo que desea mantener el tono constante y variar el croma y la luminancia. El sistema de color Munsell es útil para esto, ya que proporciona una forma sencilla de especificar colores en función de su tono, croma y luminancia. El paquete munsell (Wickham 2018) proporciona fácil acceso a los colores Munsell, que luego se pueden usar para especificar una escala de gradiente:\nmunsell::hue_slice(\"5P\") +  # Generar un ggplot con hue_slice()\n  annotate(                 # Agregar flechas para anotaciones\n    geom = \"segment\", \n    x = c(7, 7), \n    y = c(1, 10), \n    xend = c(7, 7), \n    yend = c(2, 9), \n    arrow = arrow(length = unit(2, \"mm\"))\n  ) \n#&gt; Warning: Removed 31 rows containing missing values or values outside the scale range\n#&gt; (`geom_text()`).\n\n# Escala de construcción\nerupt + scale_fill_gradient(\n  low = munsell::mnsl(\"5P 2/12\"), \n  high = munsell::mnsl(\"5P 7/12\")\n)\n\n\n\n\n\n\n\n\n\n\nLas etiquetas en el gráfico de la izquierda son un poco difíciles de leer en esta escala, por lo que hemos usado annotate() para agregar flechas que resaltan la columna utilizada para construir la escala de la derecha. Para obtener más información sobre el paquete munsell, consulte https://github.com/cwickham/munsell/.\nLas escalas de gradiente de tres puntos tienen criterios de diseño ligeramente diferentes. Normalmente, el objetivo de una escala de este tipo es transmitir la impresión perceptiva de que existe un punto medio natural (a menudo un valor cero) del cual divergen los demás valores. El gráfico de la izquierda a continuación muestra cómo crear una escala divergente “amarillo/azul”, aunque es un poco artificial en este ejemplo.\nFinalmente, si tiene colores que son significativos para sus datos (por ejemplo, colores de carrocería negros o colores de terreno estándar), o desea utilizar una paleta producida por otro paquete, es posible que desee utilizar un degradado de n puntos. A modo de ilustración, los gráficos del centro y de la derecha a continuación utilizan el paquete colorspace (Zeileis, Hornik, y Murrell 2008). Para obtener más información sobre el paquete de espacio de color, consulte https://colorspace.r-forge.r-project.org/. \n# ejemplo de munsell\nerupt + scale_fill_gradient2(\n  low = munsell::mnsl(\"5B 7/8\"),\n  high = munsell::mnsl(\"5Y 7/8\"),\n  mid = munsell::mnsl(\"N 7/0\"),\n  midpoint = .02\n) \n\n# ejemplos de espacio de color\nerupt + scale_fill_gradientn(colours = colorspace::heat_hcl(7))\nerupt + scale_fill_gradientn(colours = colorspace::diverge_hcl(7))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11.2.3 Valores faltantes\nTodas las escalas de colores continuos tienen un parámetro na.value que controla qué color se utiliza para los valores faltantes (incluidos los valores fuera del rango de los límites de la escala). Por defecto está configurado en gris, que resaltará cuando uses una escala de colores. Si usa una escala de blanco y negro, es posible que desee configurarla en otra cosa para que sea más obvia. Puedes configurar na.value = NA para hacer invisibles los valores faltantes, o elegir un color específico si lo prefieres: \ndf &lt;- data.frame(x = 1, y = 1:5, z = c(1, 3, 2, NA, 5))\nbase &lt;- ggplot(df, aes(x, y)) + \n  geom_tile(aes(fill = z), linewidth = 5) + \n  labs(x = NULL, y = NULL) +\n  scale_x_continuous(labels = NULL)\n\nbase\nbase + scale_fill_gradient(na.value = NA)\nbase + scale_fill_gradient(na.value = \"yellow\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11.2.4 Límites, rupturas y etiquetas\nEn el capítulo anterior discutimos cómo se puede controlar la apariencia de los ejes estableciendo los límites, limites (Sección 10.1.1), rupturas, breaks (Sección 10.1.4) y etiquetas, labels (@ argumento sec-position-continuous-labels) para la función de escala. El comportamiento de las escalas de color se puede controlar de forma análoga:\nbase &lt;- ggplot(toy, aes(up, up, fill = big)) + \n  geom_tile() + \n  labs(x = NULL, y = NULL) \n\nbase \nbase + scale_fill_continuous(limits = c(0, 10000))\n\n\n\n\n\n\n\n\n\n\nbase + scale_fill_continuous(breaks = c(1000, 2000, 4000))\nbase + scale_fill_continuous(labels = scales::label_dollar())\n\n\n\n\n\n\n\n\n\n\n(El conjunto de datos del juguete utilizado aquí es el mismo definido en Sección 10.1.4). Puede suprimir las pausas por completo configurándolas en NULL, lo que elimina las claves y las etiquetas.\n\n11.2.5 Leyendas\n \nCada escala está asociada a una guía que muestra la relación entre la estética y los datos. En las escalas de posición, los ejes cumplen esta función. En el caso de las escalas de colores, este papel lo desempeña la leyenda, que se puede personalizar con la ayuda de una función de guía. Para escalas de colores continuas, la leyenda predeterminada toma la forma de una “barra de colores” que muestra un degradado continuo de colores:\n\nbase &lt;- ggplot(mpg, aes(cyl, displ, colour = hwy)) +\n  geom_point(size = 2)\n\nbase\n\n\n\n\n\n\n\nLa apariencia de la leyenda se puede controlar usando la función guide_colourbar(). Hay muchos argumentos para esta función, lo que le permite ejercer un control preciso sobre la leyenda. Los argumentos más importantes se ilustran a continuación:\n\nreverse voltea la barra de colores para colocar los valores más bajos en la parte superior.\nbarwidth y barheight Le permite especificar el tamaño de la barra. Se trata de unidades de rejilla, p. unit(1, \"cm\").\ndirection especifica la dirección de la guía, \"horizontal\" o \"vertical\".\n\nEn Sección 10.3.2 introdujimos la función guides() que se utiliza para configurar leyendas y ejes personalizados. Cuando se aplica a escalas de colores, le permite crear leyendas personalizadas como estas:\nbase + guides(colour = guide_colourbar(reverse = TRUE))\nbase + guides(colour = guide_colourbar(barheight = unit(2, \"cm\")))\nbase + guides(colour = guide_colourbar(direction = \"horizontal\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nUna forma alternativa de lograr el mismo objetivo es especificar el argumento guide para la función de escala. Estas dos especificaciones de la gráfica son idénticas:\nbase + guides(colour = guide_colourbar(reverse = TRUE))\nbase + scale_colour_continuous(guide = guide_colourbar(reverse = TRUE))\n\n\n\n\n\n\n\n\n\n\nPuede obtener más información sobre las funciones de la guía en Sección 14.5.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Escalas de colores y leyendas.</span>"
    ]
  },
  {
    "objectID": "scales-colour.html#sec-colour-discrete",
    "href": "scales-colour.html#sec-colour-discrete",
    "title": "11  Escalas de colores y leyendas.",
    "section": "\n11.3 Escalas de colores discretas",
    "text": "11.3 Escalas de colores discretas\nEn muchas situaciones se producen escalas de color y relleno discretas. Un ejemplo típico es un gráfico de barras que codifica tanto la posición como el relleno en la misma variable. Muchos conceptos de ?sec-color-continuous se aplican a escalas discretas, que ilustraremos usando este gráfico de barras como ejemplo: \n\ndf &lt;- data.frame(x = c(\"a\", \"b\", \"c\", \"d\"), y = c(3, 4, 1, 2))\nbars &lt;- ggplot(df, aes(x, y, fill = x)) + \n  geom_bar(stat = \"identity\") + \n  labs(x = NULL, y = NULL) +\n  theme(legend.position = \"none\")\n\nLa escala predeterminada para colores discretos es scale_fill_discrete() que a su vez por defecto es scale_fill_hue() entonces estas son gráficas idénticas:\nbars\nbars + scale_fill_discrete()\nbars + scale_fill_hue()\n\n\n\n\n\n\n\n\n\n\n\n\n\nEsta escala predeterminada tiene algunas limitaciones (que se analizan en breve), por lo que comenzaremos analizando las herramientas para producir paletas discretas más bonitas.\n\n11.3.1 Básculas de cerveza\nscale_colour_brewer() es una escala de color discreta que, junto con la escala analógica continua scale_colour_distiller() y analógico agrupado scale_colour_fermenter()—utiliza colores “ColorBrewer” cuidadosamente seleccionados tomados de https://colorbrewer2.org/. Estos colores han sido diseñados para funcionar bien en una amplia variedad de situaciones, aunque la atención se centra en los mapas, por lo que los colores tienden a funcionar mejor cuando se muestran en áreas grandes. Hay muchas opciones diferentes:\n\nRColorBrewer::display.brewer.all()\n\n\n\n\n\n\n\nEl primer grupo de paletas son escalas secuenciales que son útiles cuando la escala discreta está ordenada (por ejemplo, clasificar datos) y están disponibles para datos continuos usando scale_colour_distiller(). Para datos categóricos desordenados, las paletas de mayor interés son las del segundo grupo. ‘Set1’ y ‘Dark2’ son particularmente buenos para los puntos, y ‘Set2’, ‘Pastel1’, ‘Pastel2’ y ‘Accent’ funciona bien para áreas. \nbars + scale_fill_brewer(palette = \"Set1\")\nbars + scale_fill_brewer(palette = \"Set2\")\nbars + scale_fill_brewer(palette = \"Accent\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta que ninguna paleta es uniformemente buena para todos los propósitos. Los diagramas de dispersión suelen utilizar marcadores de diagrama pequeños y los colores brillantes tienden a funcionar mejor que los sutiles:\n# gráfico de dispersión\ndf &lt;- data.frame(\n  x = 1:3 + runif(30), \n  y = runif(30), \n  z = c(\"a\", \"b\", \"c\")\n)\npoint &lt;- ggplot(df, aes(x, y)) +\n  geom_point(aes(colour = z))  + \n  theme(legend.position = \"none\") +\n  labs(x = NULL, y = NULL)\n\n# tres paletas\npoint + scale_colour_brewer(palette = \"Set1\")\npoint + scale_colour_brewer(palette = \"Set2\")  \npoint + scale_colour_brewer(palette = \"Pastel1\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nLos gráficos de barras suelen contener grandes manchas de color y los colores brillantes pueden resultar abrumadores. Los colores sutiles tienden a funcionar mejor en esta situación:\n# diagrama de barras\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = c(\"a\", \"b\", \"c\"))\narea &lt;- ggplot(df, aes(x, y)) + \n  geom_bar(aes(fill = z), stat = \"identity\") + \n  theme(legend.position = \"none\") +\n  labs(x = NULL, y = NULL)\n\n# tres paletas\narea + scale_fill_brewer(palette = \"Set1\")\narea + scale_fill_brewer(palette = \"Set2\")\narea + scale_fill_brewer(palette = \"Pastel1\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11.3.2 Tono y escalas de grises\nEl esquema de color predeterminado selecciona tonos espaciados uniformemente alrededor de la rueda de colores HCL. Esto funciona bien con hasta ocho colores, pero después resulta difícil distinguir los diferentes colores. Puedes controlar el croma y la luminancia predeterminados, y el rango de tonos, con los argumentos h, c y l: \nbars\nbars + scale_fill_hue(c = 40)\nbars + scale_fill_hue(h = c(180, 300))\n\n\n\n\n\n\n\n\n\n\n\n\n\nHay algunos problemas con este esquema predeterminado. Una es que, a diferencia de muchas de las otras paletas analizadas en este capítulo, no son seguras para los daltónicos (lo que se analiza en ?sec-color-blindness). La segunda es que, debido a que todos los colores tienen la misma luminancia y croma, todos aparecen con un tono de gris idéntico cuando se imprimen en blanco y negro. Si desea imprimir una escala de color discreta en blanco y negro, es mejor usar explícitamente scale_fill_grey() que asigna datos discretos a grises, de claro a oscuro: \nbars + scale_fill_grey()\nbars + scale_fill_grey(start = 0.5, end = 1)\nbars + scale_fill_grey(start = 0, end = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11.3.3 Básculas paletizadoras\nOtra alternativa la proporciona el paquete Paletteer, discutido anteriormente en relación con las escalas de color continuas en Sección 11.2.1. Al proporcionar una interfaz unificada que abarca una gran cantidad de paquetes, Paletteer permite elegir entre una gran cantidad de paletas de manera consistente:\nbars + paletteer::scale_fill_paletteer_d(\"rtist::vangogh\")\nbars + paletteer::scale_fill_paletteer_d(\"colorBlindness::paletteMartin\")\nbars + paletteer::scale_fill_paletteer_d(\"wesanderson::FantasticFox1\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11.3.4 Balanzas manuales\nSi ninguna de las paletas preexistentes es adecuada, o si tiene sus propios colores preferidos, puede usar scale_fill_manual() para configurar los colores manualmente. Esto puede resultar útil si desea elegir colores que resalten una estructura de agrupación secundaria o llamen la atención sobre diferentes comparaciones: \nbars + \n  scale_fill_manual(\n    values = c(\"sienna1\", \"sienna4\", \"hotpink1\", \"hotpink4\")\n  )\n\nbars + \n  scale_fill_manual(\n    values = c(\"tomato1\", \"tomato2\", \"tomato3\", \"tomato4\")\n  )\n\nbars + \n  scale_fill_manual(\n    values = c(\"grey\", \"black\", \"grey\", \"grey\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nTambién puede utilizar un vector con nombre para especificar los colores que se asignarán a cada nivel, lo que le permite especificar los niveles en el orden que desee:\n\nbars + \n  scale_fill_manual(\n    values = c(\n      \"d\" = \"grey\",\n      \"c\" = \"grey\",\n      \"b\" = \"black\",\n      \"a\" = \"grey\"\n    )\n  )\n\n\n\n\n\n\n\nPara obtener más información sobre básculas manuales, consulte Sección 12.5.\n\n11.3.5 Límites, rupturas y etiquetas\nLos límites de escala para escalas de colores discretas se pueden establecer usando el argumento limits para el argumento de escala, o usando la función auxiliar lims(). Esto puede ser importante cuando la misma variable se representa en diferentes gráficos y desea asegurarse de que los colores sean consistentes en todos los gráficos. Para demostrar esto, ampliaremos el ejemplo de Sección 10.1.1. El color representa el tipo de combustible, que puede ser rregular, etanol, ddiesel, premium o cgas natural comprimido.\nmpg_99 &lt;- mpg %&gt;% filter(year == 1999)\nmpg_08 &lt;- mpg %&gt;% filter(year == 2008)\n\nbase_99 &lt;- ggplot(mpg_99, aes(displ, hwy, colour = fl)) + geom_point() \nbase_08 &lt;- ggplot(mpg_08, aes(displ, hwy, colour = fl)) + geom_point() \n\nbase_99\nbase_08\n\n\n\n\n\n\n\n\n\n\nCada gráfica tiene sentido por sí sola, pero la comparación visual entre las dos es difícil. Los límites de los ejes son diferentes y, debido a que en los datos de 1998 sólo se representan los combustibles regular, premium y diésel, los colores se asignan de manera inconsistente. Para garantizar un mapeo consistente para la estética del color, podemos usar lims() para establecer los límites manualmente. Como se analiza en Sección 10.1.1, toma pares nombre-valor como entrada, donde el nombre especifica la estética y el valor especifica los límites:\nbase_99 + lims(colour = c(\"c\", \"d\", \"e\", \"p\", \"r\"))\nbase_08 + lims(colour = c(\"c\", \"d\", \"e\", \"p\", \"r\"))\n\n\n\n\n\n\n\n\n\n\nLo bueno de lims() es que podemos establecer límites para múltiples estéticas a la vez. Para garantizar que x, y y color utilicen límites consistentes, podemos hacer esto:\nbase_99 + \n  lims(\n    x = c(1, 7), \n    y = c(10, 45), \n    colour = c(\"c\", \"d\", \"e\", \"p\", \"r\")\n  )\n\nbase_08 + \n  lims(\n    x = c(1, 7), \n    y = c(10, 45), \n    colour = c(\"c\", \"d\", \"e\", \"p\", \"r\")\n  )\n\n\n\n\n\n\n\n\n\n\nHay dos limitaciones potenciales para estas gráficas. En primer lugar, si bien establecer los límites de la escala garantiza que los colores se representen de manera idéntica en ambos gráficos, también significa que el gráfico de los datos de 1999 muestra etiquetas para los cinco tipos de combustible, a pesar de que no se utilizaban etanol ni gas natural comprimido. En ese tiempo. Podemos solucionar esto configurando manualmente los saltos de escala, asegurándonos de que solo los tipos de combustible que aparecen en los datos se muestren en la leyenda. La segunda limitación es que las etiquetas no son particularmente útiles, lo que podemos solucionar especificándolas manualmente. Al configurar múltiples propiedades de una sola escala, puede ser más útil personalizar usando los argumentos de la función de escala en lugar de usar la función auxiliar lims():\n\nbase_99 + \n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"), \n    breaks = c(\"d\", \"p\", \"r\"),\n    labels = c(\"diesel\", \"premium\", \"regular\")\n  )\n\n\n\n\n\n\n\nSin embargo, no hay nada que le impida usar lims() para controlar los límites estéticos de la posición, mientras usa scale_colour_discrete() para ejercer un control más detallado sobre la estética del color:\nbase_99 + \n  lims(x = c(1, 7), y = c(10, 45)) +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"), \n    breaks = c(\"d\", \"p\", \"r\"),\n    labels = c(\"diesel\", \"premium\", \"regular\")\n  )\n\nbase_08 + \n  lims(x = c(1, 7), y = c(10, 45)) +\n  scale_color_discrete(\n    limits = c(\"c\", \"d\", \"e\", \"p\", \"r\"), \n    labels = c(\"compressed\", \"diesel\", \"ethanol\", \"premium\", \"regular\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n11.3.6 Leyendas\n\nLas leyendas para escalas de colores discretas se pueden personalizar usando el argumento guide de la función de escala o con la función auxiliar guides(), descrita en ?sec-guide-colorbar. Para una escala discreta, la leyenda predeterminada muestra claves individuales en una tabla, que se puede personalizar usando guide_legend(). Las opciones más útiles son:\n\n\nnrow o ncol que especifican las dimensiones de la mesa. byrow controla cómo se llena la tabla: FALSE la llena por columna (el valor predeterminado), TRUE la llena por fila.\nbase &lt;- ggplot(mpg, aes(drv, fill = factor(cyl))) + geom_bar() \n\nbase\nbase + guides(fill = guide_legend(ncol = 2))\nbase + guides(fill = guide_legend(ncol = 2, byrow = TRUE))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreverse invierte el orden de las claves:\nbase\nbase + guides(fill = guide_legend(reverse = TRUE))\n\n\n\n\n\n\n\n\n\n\n\n\noverride.aes es útil cuando desea que los elementos de la leyenda se muestren de manera diferente a las geomas del gráfico. Esto suele ser necesario cuando se ha utilizado transparencia o tamaño para tratar un sobretrazado moderado y también se ha utilizado color en el trazado. \nbase &lt;- ggplot(mpg, aes(displ, hwy, colour = drv)) +\n  geom_point(size = 4, alpha = .2, stroke = 0)\n\nbase + guides(colour = guide_legend())\nbase + guides(colour = guide_legend(override.aes = list(alpha = 1)))\n\n\n\n\n\n\n\n\n\n\n\nkeywidth y keyheight (junto con default.unit) le permite especificar el tamaño de las claves. Se trata de unidades de rejilla, p. unit(1, \"cm\").\n\nPuedes conocer más sobre las guías en Sección 14.5.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Escalas de colores y leyendas.</span>"
    ]
  },
  {
    "objectID": "scales-colour.html#sec-binned-colour",
    "href": "scales-colour.html#sec-binned-colour",
    "title": "11  Escalas de colores y leyendas.",
    "section": "\n11.4 Escalas de colores agrupadas",
    "text": "11.4 Escalas de colores agrupadas\nLas escalas de colores también vienen en versiones agrupadas. La escala predeterminada es scale_fill_binned() que a su vez es scale_fill_steps(). Al igual que con las escalas de posición agrupadas analizadas en Sección 10.4, estas escalas tienen un argumento n.breaks que controla el número de categorías de color discretas creadas por la escala. Contrariamente a la intuición, debido a que el sistema visual humano es muy bueno para detectar bordes, esto a veces puede hacer que un gradiente de color continuo sea más fácil de percibir:\nerupt + scale_fill_binned()\nerupt + scale_fill_steps()\nerupt + scale_fill_steps(n.breaks = 8)\n\n\n\n\n\n\n\n\n\n\n\n\n\nEn otros aspectos, scale_fill_steps() es análogo a scale_fill_gradient() y te permite construir tus propios degradados de dos colores. También hay una variante de tres colores scale_fill_steps2() y una variante de escala de n colores scale_fill_stepsn() que se comportan de manera similar a sus contrapartes continuas:\nerupt + scale_fill_steps(low = \"grey\", high = \"brown\")\nerupt + \n  scale_fill_steps2(\n    low = \"grey\", \n    mid = \"white\", \n    high = \"brown\", \n    midpoint = .02\n  )\nerupt + scale_fill_stepsn(n.breaks = 12, colours = terrain.colors(12))\n\n\n\n\n\n\n\n\n\n\n\n\n\nLas paletas viridis se pueden usar de la misma manera, llamando directamente a las funciones generadoras de paletas al especificar el argumento colors para scale_fill_stepsn():\nerupt + scale_fill_stepsn(n.breaks = 9, colours = viridis::viridis(9))\nerupt + scale_fill_stepsn(n.breaks = 9, colours = viridis::magma(9))\nerupt + scale_fill_stepsn(n.breaks = 9, colours = viridis::inferno(9))\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlternativamente, también existe un análogo de cerveza para básculas agrupadas, y se llama scale_fill_fermenter():\nerupt + scale_fill_fermenter(n.breaks = 9)\nerupt + scale_fill_fermenter(n.breaks = 9, palette = \"Oranges\")\nerupt + scale_fill_fermenter(n.breaks = 9, palette = \"PuOr\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta que, al igual que el discreto scale_fill_brewer()—y a diferencia del continuo scale_fill_distiller()—la función agrupada scale_fill_fermenter() no interpola entre los colores de la cafetera, y si configura n.breaks Si es mayor que el número de colores de la paleta, aparecerá un mensaje de advertencia y algunos colores no se mostrarán.\n\n11.4.1 Limits, breaks, and labels\nIn most respects setting limits, breaks, and labels for a binned scale follows the same logic that applies to continuous scales (Sección 10.1.4 and Sección 11.2.4). Like a continuous scale, the limits argument is typically a numeric vector of length two specifying the end points, breaks is a numeric vector specifying the break points, and labels is a character vector specifying the labels. All three arguments will accept functions as input (discussed in Sección 10.1). The main difference between binned and continuous scales is that the breaks argument defines the edges of the bins rather than simply specifying locations of tick marks. Límites, rupturas y etiquetas\nEn la mayoría de los aspectos, establecer límites, interrupciones y etiquetas para una escala agrupada sigue la misma lógica que se aplica a las escalas continuas (Sección 10.1.4 y ?sec-color-continuous-limits). Al igual que una escala continua, el argumento limits suele ser un vector numérico de longitud dos que especifica los puntos finales, breaks es un vector numérico que especifica los puntos de interrupción y labels es un vector de caracteres que especifica las etiquetas. Los tres argumentos aceptarán funciones como entrada (discutidas en Sección 10.1). La principal diferencia entre escalas agrupadas y continuas es que el argumento breaks define los bordes de las ubicaciones en lugar de simplemente especificar las ubicaciones de las marcas.\n\n11.4.2 Leyendas\nLa leyenda predeterminada para escalas agrupadas utiliza pasos de color en lugar de una barra de colores y se puede personalizar usando la función guide_coloursteps(). Una leyenda de paso de color muestra el área entre cortes como un único color constante, en lugar de mostrar un degradado de color que varía suavemente a lo largo de la barra. Los argumentos de guide_coloursteps() en su mayoría reflejan los de guide_colourbar() (ver Sección 11.2.5), con argumentos adicionales que son relevantes para escalas agrupadas:\n\n\nshow.limits indica si los valores deben mostrarse en los extremos de la barra de color escalonada, de forma análoga al argumento correspondiente en guide_bins()\nbase &lt;- ggplot(mpg, aes(cyl, displ, colour = hwy)) +\n  geom_point(size = 2) +\n  scale_color_binned()\n\nbase \nbase + guides(colour = guide_coloursteps(show.limits = TRUE))\n\n\n\n\n\n\n\n\n\n\n\nticks es una variable lógica que indica si las marcas deben mostrarse junto a las etiquetas de leyenda (el valor predeterminado es NULL, en cuyo caso el valor se hereda de la escala)\neven.steps es una variable lógica que indica si los contenedores deben estar espaciados uniformemente (el valor predeterminado es TRUE) o su tamaño debe ser proporcional a su frecuencia en los datos.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Escalas de colores y leyendas.</span>"
    ]
  },
  {
    "objectID": "scales-colour.html#sec-date-colour-scales",
    "href": "scales-colour.html#sec-date-colour-scales",
    "title": "11  Escalas de colores y leyendas.",
    "section": "\n11.5 Escalas de color de fecha y hora",
    "text": "11.5 Escalas de color de fecha y hora\nCuando una estética de color se asigna a un tipo de fecha/hora, ggplot2 usa scale_colour_date() o scale_colour_datetime() para especificar la escala. Están diseñados para manejar datos de fechas, de forma análoga a las escalas de fechas analizadas en Sección 10.2. Estas escalas tienen argumentos date_breaks y date_labels que hacen que sea un poco más fácil trabajar con estos datos, como lo ilustra el siguiente ejemplo ligeramente artificial:\nbase &lt;- ggplot(economics, aes(psavert, uempmed, colour = date)) + \n  geom_point() \n\nbase\nbase + \n  scale_colour_date(\n    date_breaks = \"142 months\", \n    date_labels = \"%b %Y\"\n  )",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Escalas de colores y leyendas.</span>"
    ]
  },
  {
    "objectID": "scales-colour.html#sec-scales-alpha",
    "href": "scales-colour.html#sec-scales-alpha",
    "title": "11  Escalas de colores y leyendas.",
    "section": "\n11.6 Escalas alfa",
    "text": "11.6 Escalas alfa\nLas escalas alfa asignan la transparencia de una sombra a un valor en los datos. No suelen ser útiles, pero pueden ser una manera conveniente de restar importancia visual a observaciones menos importantes. scale_alpha() es un alias para scale_alpha_continuous() ya que ese es el uso más común de alpha y ahorra un poco de escritura. A continuación se muestra un ejemplo de una escala alfa utilizando los datos de las erupciones:\n\nggplot(faithfuld, aes(waiting, eruptions, alpha = density)) +\n  geom_raster(fill = \"maroon\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0))",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Escalas de colores y leyendas.</span>"
    ]
  },
  {
    "objectID": "scales-colour.html#sec-legend-layout",
    "href": "scales-colour.html#sec-legend-layout",
    "title": "11  Escalas de colores y leyendas.",
    "section": "\n11.7 Posición de la leyenda",
    "text": "11.7 Posición de la leyenda\nUna serie de configuraciones que afectan la visualización general de las leyendas se controlan a través del sistema de temas. Aprenderás más sobre eso en Sección 17.2, pero por ahora, todo lo que necesitas saber es que modificas la configuración del tema con la función theme(). \nLa posición y justificación de las leyendas están controladas por la configuración del tema legend.position, que toma valores “right”, “left”, “top”, “bottom” o “none” (sin leyenda). \nbase &lt;- ggplot(toy, aes(up, up)) + \n  geom_point(aes(colour = txt), size = 3) + \n  xlab(NULL) + \n  ylab(NULL)\n\nbase + theme(legend.position = \"left\")\nbase + theme(legend.position = \"right\") # el valor por defecto\nbase + theme(legend.position = \"bottom\")\nbase + theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCambiar entre izquierda/derecha y arriba/abajo modifica cómo se distribuyen las claves en cada leyenda (horizontal o verticalmente) y cómo se apilan varias leyendas (horizontal o verticalmente). Si es necesario, puedes ajustar esas opciones de forma independiente:\n\nlegend.direction: disposición de elementos en leyendas (“horizontal” o “vertical”).\nlegend.box: disposición de múltiples leyendas (“horizontal” o “vertical”).\nlegend.box.just: justificación de cada leyenda dentro del cuadro delimitador general, cuando hay varias leyendas (“top”, “bottom”, “left”, o “right”).\n\nAlternativamente, si hay mucho espacio en blanco en su gráfica, es posible que desee colocar la leyenda dentro de la gráfica. Puede hacer esto estableciendo legend.position en un vector numérico de longitud dos. Los números representan una ubicación relativa en el área del panel: c(0, 1) es la esquina superior izquierda y c(1, 0) es la esquina inferior derecha. Usted controla a qué esquina de la leyenda se refiere legend.position con legend.justification, que se especifica de manera similar. Desafortunadamente, colocar la leyenda exactamente donde la desea requiere mucho ensayo y error.\nbase &lt;- ggplot(toy, aes(up, up)) + \n  geom_point(aes(colour = txt), size = 3)\n\nbase + \n  theme(\n    legend.position = c(0, 1), \n    legend.justification = c(0, 1)\n  )\n#&gt; Warning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2\n#&gt; 3.5.0.\n#&gt; ℹ Please use the `legend.position.inside` argument of `theme()` instead.\n\nbase + \n  theme(\n    legend.position = c(0.5, 0.5), \n    legend.justification = c(0.5, 0.5)\n  )\n\nbase + \n  theme(\n    legend.position = c(1, 0), \n    legend.justification = c(1, 0)\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nTambién hay un margen alrededor de las leyendas, que puedes suprimir con legend.margin = unit(0, \"mm\").\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAzzalini, A., y A. W. Bowman. 1990. «A look at some data on the Old Faithful geyser.» Applied Statistics 39: 357-65.\n\n\nGarnier, Simon. 2018. viridis: Default Color Maps from ’matplotlib’. https://CRAN.R-project.org/package=viridis.\n\n\nHvitfeldt, Emil. 2020. paletteer: Comprehensive Collection of Color Palettes. https://CRAN.R-project.org/package=paletteer.\n\n\nOu, Jianhong. 2021. colorBlindness: Safe Color Set for Color Blindness. https://CRAN.R-project.org/package=colorBlindness.\n\n\nPedersen, Thomas Lin, y Fabio Crameri. 2020. scico: Colour Palettes Based on the Scientific Colour-Maps. https://CRAN.R-project.org/package=scico.\n\n\nWickham, Charlotte. 2018. munsell: Utilities for Using Munsell Colours. https://CRAN.R-project.org/package=munsell.\n\n\nZeileis, Achim, Kurt Hornik, y Paul Murrell. 2008. «Escaping RGBland: Selecting Colors for Statistical Graphics». Computational Statistics & Data Analysis. http://statmath.wu-wien.ac.at/~zeileis/papers/Zeileis+Hornik+Murrell-2008.pdf.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Escalas de colores y leyendas.</span>"
    ]
  },
  {
    "objectID": "scales-other.html",
    "href": "scales-other.html",
    "title": "12  Otra estéticas",
    "section": "",
    "text": "12.1 Tamaño\nAdemás de la posición y el color, ggplot2 puede utilizar otras funciones estéticas para representar datos. En este capítulo, analizaremos las escalas de tamaño (Sección 12.1), de forma (Sección 12.2), de ancho de línea (Sección 12.3) y de tipo de línea (Sección 12.4), que utilizan características visuales distintas a la ubicación y el color para representar los valores de los datos. Además, hablaremos de las escalas manuales (Sección 12.5) y de identidad (Sección 12.6): estas no utilizan necesariamente características visuales diferentes, pero construyen asignaciones de datos de una forma inusual.\nLa estética de tamaño se usa típicamente para escalar puntos y texto. La escala predeterminada para la estética de tamaño es scale_size(), donde un aumento lineal en la variable se asigna a un aumento lineal en el área (no en el radio) del geom. Escalar en función del área es una opción predeterminada sensata, ya que la percepción humana del tamaño se asemeja más al escalar el área que al escalar el radio. Por defecto, el valor más pequeño de los datos (más precisamente, en los límites de escala) se asigna a un tamaño de 1 y el más grande a un tamaño de 6. El argumento range permite escalar el tamaño de los geoms:\nHay varias escalas de tamaño que vale la pena mencionar brevemente:",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Otra estéticas</span>"
    ]
  },
  {
    "objectID": "scales-other.html#sec-scale-size",
    "href": "scales-other.html#sec-scale-size",
    "title": "12  Otra estéticas",
    "section": "",
    "text": "base &lt;- ggplot(mpg, aes(displ, hwy, size = cyl)) + \n  geom_point()\n\nbase\nbase + scale_size(range = c(1, 2))\n\n\n\nscale_size_area() y scale_size_binned_area() son versiones de scale_size() y scale_size_binned() que garantizan que un valor de 0 se asigne a un área de 0.\nscale_radius() asigna el valor de los datos al radio en lugar de al área (Sección 12.1.1).\nscale_size_binned() es una escala de tamaño que se comporta como scale_size(), pero asigna valores continuos a categorías de tamaño discretas, de forma análoga a las escalas de posición y color agrupadas que se describen en Sección 10.4 y Sección 11.4, respectivamente. Las leyendas asociadas con esta escala se describen en Sección 12.1.2.\nscale_size_date() y scale_size_datetime() están diseñados para manejar datos de fechas, de forma análoga a las escalas de fechas analizadas en Sección 10.2.\n\n\n12.1.1 Escalas de tamaño de radio\nExisten situaciones en las que el escalado de área no es deseable, y para ello se proporciona la función scale_radius(). Para ilustrar cuándo scale_radius() es apropiada, considere un conjunto de datos que contiene datos astronómicos que incluyen el radio de diferentes planetas:\n\nplanets\n#&gt;      name  type position radius    orbit\n#&gt; 1 Mercury Inner        1   2440 5.79e+07\n#&gt; 2   Venus Inner        2   6052 1.08e+08\n#&gt; 3   Earth Inner        3   6378 1.50e+08\n#&gt; 4    Mars Inner        4   3390 2.28e+08\n#&gt; 5 Jupiter Outer        5  71400 7.78e+08\n#&gt; 6  Saturn Outer        6  60330 1.43e+09\n#&gt; 7  Uranus Outer        7  25559 2.87e+09\n#&gt; 8 Neptune Outer        8  24764 4.50e+09\n\nEn este caso, un gráfico que utiliza la estética del tamaño para representar el radio de los planetas debe usar scale_radius() en lugar del scale_size() predeterminado. También es importante en este caso establecer los límites de escala para que un planeta con radio 0 se dibuje con un disco con radio 0.\nbase &lt;- ggplot(planets, aes(1, name, size = radius)) + \n  geom_point() + \n  scale_x_continuous(breaks = NULL) + \n  labs(x = NULL, y = NULL, size = NULL)\n  \nbase + ggtitle(\"not to scale\")\nbase + \n  scale_radius(limits = c(0, NA), range = c(0, 10)) + \n  ggtitle(\"to scale\")\n\n\n\n\n\n\n\n\n\n\nA la izquierda es difícil distinguir Júpiter de Saturno, a pesar de que la diferencia entre ambos debería ser el doble del tamaño de la Tierra; Compare esto con el gráfico de la derecha, donde el radio de Júpiter es visiblemente mayor.\n\n12.1.2 Escalas de tamaño agrupadas\nLas escalas de tamaño agrupadas funcionan de forma similar a las escalas agrupadas para la estética de color y posición (Sección 11.4 y Sección 10.4). Una diferencia radica en cómo se muestran las leyendas. La leyenda predeterminada para una escala de tamaño agrupada, y para todas las escalas agrupada, excepto la estética de posición y color, se rige por guide_bins(). Por ejemplo, en los datos mpg, podríamos usar scale_size_binned() para crear una versión agrupada de la variable continua hwy:\n\nbase &lt;- ggplot(mpg, aes(displ, manufacturer, size = hwy)) +\n  geom_point(alpha = .2) +\n  scale_size_binned()\n\nbase\n\n\n\n\n\n\n\nA diferencia de guide_legend(), la guía creada para una escala agrupada por guide_bins() no organiza las claves individuales en una tabla. En lugar de ello, están organizados en una columna (o fila) a lo largo de un único eje vertical (u horizontal), que de forma predeterminada se muestra con su propio eje. Los argumentos importantes para guide_bins() se enumeran a continuación:\n\n\naxis indica si se debe dibujar el eje (el valor predeterminado es TRUE)\n\nbase + guides(size = guide_bins(axis = FALSE))\n#&gt; Warning: Ignoring unknown argument to `guide_bins()`: `axis`.\n\n\n\n\n\n\n\n\n\ndirection es una cadena de caracteres que especifica la dirección de la guía, ya sea \"vertical\" (por defecto) o \"horizontal\"\n\nbase + guides(size = guide_bins(direction = \"horizontal\"))\n\n\n\n\n\n\n\n\n\nshow.limits especifica si se muestran marcas en los extremos del eje guía (el valor predeterminado es FALSE)\n\nbase + guides(size = guide_bins(show.limits = TRUE))\n\n\n\n\n\n\n\n\n\naxis.colour, axis.linewidth y axis.arrow se utilizan para controlar el eje guía que se muestra junto a las entradas de la leyenda\n\nbase + guides(\n  size = guide_bins(\n    axis.colour = \"red\",\n    axis.arrow = arrow(\n      length = unit(.1, \"inches\"), \n      ends = \"first\", \n      type = \"closed\"\n    )\n  )\n)\n#&gt; Warning: Ignoring unknown arguments to `guide_bins()`: `axis.colour` and\n#&gt; `axis.arrow`.\n\n\n\n\n\n\n\n\nkeywidth, keyheight, reverse y override.aes tienen el mismo comportamiento para guide_bins() com para guide_legend() (see Sección 11.3.6)",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Otra estéticas</span>"
    ]
  },
  {
    "objectID": "scales-other.html#sec-scale-shape",
    "href": "scales-other.html#sec-scale-shape",
    "title": "12  Otra estéticas",
    "section": "\n12.2 Forma",
    "text": "12.2 Forma\nLos valores se pueden asignar a la estética de la forma. El uso típico de esto es cuando tiene una pequeña cantidad de categorías discretas: si la variable de datos contiene más de 6 valores, resulta difícil distinguir entre formas y generará una advertencia. La función predeterminada scale_shape() contiene un solo argumento: establezca solid = TRUE (el valor predeterminado) para usar una “paleta” que consta de tres formas sólidas y tres formas huecas, o establezca solid = FALSE para usar seis formas huecas formas:\nbase &lt;- ggplot(mpg, aes(displ, hwy, shape = factor(cyl))) + \n  geom_point()\n\nbase\nbase + scale_shape(solid = FALSE)\n\n\n\n\n\n\n\n\n\n\nAunque es poco probable que un gráfico sea legible con más de 6 marcadores distintos, hay 25 formas posibles para elegir, cada una asociada con un valor entero:\n\n\n\n\n\n\n\n\nPuede especificar los tipos de marcador para cada valor de datos manualmente usando scale_shape_manual():\n\nbase + \n  scale_shape_manual(\n    values = c(\"4\" = 16, \"5\" = 17, \"6\" = 1 , \"8\" = 2)\n  )\n\n\n\n\n\n\n\nPara obtener más información sobre básculas manuales, consulte Sección 12.5.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Otra estéticas</span>"
    ]
  },
  {
    "objectID": "scales-other.html#sec-scale-linewidth",
    "href": "scales-other.html#sec-scale-linewidth",
    "title": "12  Otra estéticas",
    "section": "\n12.3 Ancho de línea",
    "text": "12.3 Ancho de línea\nLa estética del ancho de línea, introducida en ggplot2 3.4.0, se utiliza para controlar el ancho de las líneas. En versiones anteriores de ggplot2 se usaba la estética del tamaño para este propósito, lo que causaba algunas dificultades para geoms complejas como geom_pointrange() que contienen tanto puntos como líneas. Para estas geoms suele ser importante poder controlar por separado el tamaño de los puntos y el ancho de las líneas. Esto se ilustra en los gráficos siguientes. En el gráfico más a la izquierda, tanto la estética del tamaño como del ancho de línea se establecen en sus valores predeterminados. El gráfico del medio aumenta el tamaño de los puntos sin cambiar el ancho de línea, mientras que el gráfico de la derecha aumenta el ancho de línea sin cambiar el tamaño de los puntos.\nbase &lt;- ggplot(airquality, aes(x = factor(Month), y = Temp))\n\nbase + geom_pointrange(stat = \"summary\", fun.data = \"median_hilow\")\nbase + geom_pointrange(\n  stat = \"summary\", \n  fun.data = \"median_hilow\", \n  size = 2\n)\nbase + geom_pointrange(\n  stat = \"summary\", \n  fun.data = \"median_hilow\", \n  linewidth = 2\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nEn la práctica, lo más probable es que establezcas el ancho de línea como un parámetro fijo, como se muestra en el ejemplo anterior, pero es una verdadera estética y se puede asignar a valores de datos:\n\nggplot(airquality, aes(Day, Temp, group = Month)) + \n  geom_line(aes(linewidth = Month)) + \n  scale_linewidth(range = c(0.5, 3))\n\n\n\n\n\n\n\nLas escalas de ancho de línea se comportan como escalas de tamaño en la mayoría de los casos, pero existen diferencias. Como se analizó anteriormente, el comportamiento predeterminado de una escala de tamaño es aumentar linealmente con el área del marcador de trazado (por ejemplo, el diámetro de un marcador de trazado circular aumenta con la raíz cuadrada del valor de los datos). Por el contrario, el ancho de línea aumenta linealmente con el valor de los datos.\nSe pueden agregar escalas de ancho de línea agrupadas usando scale_linewidth_binned().",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Otra estéticas</span>"
    ]
  },
  {
    "objectID": "scales-other.html#sec-scale-linetype",
    "href": "scales-other.html#sec-scale-linetype",
    "title": "12  Otra estéticas",
    "section": "\n12.4 Tipo de línea",
    "text": "12.4 Tipo de línea\nEs posible asignar una variable a la estética del tipo de línea en ggplot2. Esto funciona mejor para variables discretas con una pequeña cantidad de categorías, y scale_linetype() es un alias para scale_linetype_discrete(). Las variables continuas no se pueden asignar a tipos de línea a menos que se use scale_linetype_binned(): aunque existe una función scale_linetype_continuous(), lo único que hace es producir un error. Para ver por qué la estética del tipo de línea es adecuada sólo para casos con unas pocas categorías, considere este gráfico:\n\nggplot(economics_long, aes(date, value01, linetype = variable)) +\n  geom_line()\n\n\n\n\n\n\n\nCon cinco categorías, la gráfica es bastante difícil de leer y es poco probable que quieras utilizar la estética del tipo de línea para más que eso. La “paleta” predeterminada para el tipo de línea la proporciona la función scales::linetype_pal() e incluye los 13 tipos de línea que se muestran a continuación:\n\ndf &lt;- data.frame(value = letters[1:13])\nbase &lt;- ggplot(df, aes(linetype = value)) +\n  geom_segment(\n    mapping = aes(x = 0, xend = 1, y = value, yend = value),\n    show.legend = FALSE\n  ) +\n  theme(panel.grid = element_blank()) +\n  scale_x_continuous(NULL, NULL) \n\nbase\n\n\n\n\n\n\n\nPuede controlar el tipo de línea especificando una cadena con hasta 8 valores hexadecimales (es decir, de 0 a F). En esta especificación, el primer valor es la longitud del primer segmento de línea, el segundo valor es la longitud del primer espacio entre segmentos, y así sucesivamente. Esto le permite especificar sus propios tipos de línea usando scale_linetype_manual(), o alternativamente, pasando una función personalizada al argumento palette:\n\nlinetypes &lt;- function(n) {\n  types &lt;- c(\"55\",  \"75\", \"95\", \"1115\", \"111115\", \"11111115\",\n             \"5158\", \"9198\", \"c1c8\")\n  return(types[seq_len(n)])\n}\n\nbase + discrete_scale(\"linetype\", palette = linetypes)\n#&gt; Warning: Removed 4 rows containing missing values or values outside the scale range\n#&gt; (`geom_segment()`).\n\n\n\n\n\n\n\nTenga en cuenta que las últimas cuatro líneas están en blanco, porque la función linetypes() definida anteriormente devuelve NA cuando el número de categorías excede 9. La función discrete_scale() contiene un argumento na.value usado para especificar qué Se traza un tipo de línea para estos valores. De forma predeterminada, esto produce una línea en blanco, pero puede anular esto configurando na.value = \"dotted\":\n\nbase + discrete_scale(\"linetype\", palette = linetypes, na.value = \"dotted\")\n\n\n\n\n\n\n\nLos tipos de línea válidos se pueden configurar utilizando una cadena de caracteres legible por humanos: \"blank\" para una línea de color blanco, \"solid\" para una línea de color negro, \"dashed\" para una línea discontinua, \"dotted\" para una línea de puntos, \"dotdash\" para una línea que alterna entre discontinua y puntos, \"longdash\" para una línea discontinua con fragmentos más largos, y\"twodash\" para una línea que alterna entre discontinua con fragmentos cortos y largos.",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Otra estéticas</span>"
    ]
  },
  {
    "objectID": "scales-other.html#sec-scale-manual",
    "href": "scales-other.html#sec-scale-manual",
    "title": "12  Otra estéticas",
    "section": "\n12.5 Escala manual",
    "text": "12.5 Escala manual\nLas escalas manuales son solo una lista de valores válidos que se asignan a valores discretos únicos. Si desea personalizar estas escalas, necesita crear su propia escala nueva con la versión “manual” de cada una: scale_linetype_manual(), scale_shape_manual(), scale_colour_manual(), etc. La escala manual tiene una argumento importante, values, donde especifica los valores que la escala debe producir si se nombra este vector, hará coincidir los valores de la salida con los valores de la entrada; de lo contrario, coincidirá en el orden de los niveles de la variable discreta. Necesitará algunos conocimientos de los valores estéticos válidos, que se describen en vignette(\"ggplot2-specs\"). \nLas escalas manuales aparecieron antes, en ?sec-manual-color y Sección 12.2. En este ejemplo, mostraremos un uso creativo de scale_colour_manual() para mostrar múltiples variables en el mismo gráfico y mostrar una leyenda útil. En la mayoría de los sistemas de trazado, colorearías las líneas y luego agregarías una leyenda: \n\nhuron &lt;- data.frame(year = 1875:1972, level = as.numeric(LakeHuron))\n\nggplot(huron, aes(year)) +\n  geom_line(aes(y = level + 5), colour = \"red\") +\n  geom_line(aes(y = level - 5), colour = \"blue\")\n\n\n\n\n\n\nFigura 12.1\n\n\n\n\nEso no funciona en ggplot porque no hay forma de agregar una leyenda manualmente. En su lugar, asigne etiquetas informativas a las líneas:\n\nggplot(huron, aes(year)) +\n  geom_line(aes(y = level + 5, colour = \"above\")) +\n  geom_line(aes(y = level - 5, colour = \"below\"))\n\n\n\n\n\n\nFigura 12.2\n\n\n\n\nY luego dile a la escala cómo asignar etiquetas a colores:\n\nggplot(huron, aes(year)) +\n  geom_line(aes(y = level + 5, colour = \"above\")) +\n  geom_line(aes(y = level - 5, colour = \"below\")) +\n  scale_colour_manual(\"Direction\",\n    values = c(\"above\" = \"red\", \"below\" = \"blue\")\n  )\n\n\n\n\n\n\nFigura 12.3",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Otra estéticas</span>"
    ]
  },
  {
    "objectID": "scales-other.html#sec-scale-identity",
    "href": "scales-other.html#sec-scale-identity",
    "title": "12  Otra estéticas",
    "section": "\n12.6 Escalas de identidad",
    "text": "12.6 Escalas de identidad\nLas escalas de identidad, como scale_colour_identity() y scale_shape_identity(), se utilizan cuando los datos ya están escalados de manera que los datos y los espacios estéticos sean los mismos. El siguiente código muestra un ejemplo en el que la escala de identidad es útil. luv_colours contiene las ubicaciones de todos los colores integrados de R en el espacio de color LUV (el espacio en el que se basa HCL). Una leyenda es innecesaria, porque el color del punto se representa a sí mismo: los datos y los espacios estéticos son los mismos. \n\nhead(luv_colours)\n#&gt;      L         u    v           col\n#&gt; 1 9342 -3.37e-12    0         white\n#&gt; 2 9101 -4.75e+02 -635     aliceblue\n#&gt; 3 8810  1.01e+03 1668  antiquewhite\n#&gt; 4 8935  1.07e+03 1675 antiquewhite1\n#&gt; 5 8452  1.01e+03 1610 antiquewhite2\n#&gt; 6 7498  9.03e+02 1402 antiquewhite3\n\nggplot(luv_colours, aes(u, v)) + \ngeom_point(aes(colour = col), size = 3) + \nscale_color_identity() + \ncoord_equal()",
    "crumbs": [
      "Scales",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Otra estéticas</span>"
    ]
  },
  {
    "objectID": "mastery.html",
    "href": "mastery.html",
    "title": "La Gramática",
    "section": "",
    "text": "Construyendo un diagrama de dispersión\nPara desbloquear todo el poder de ggplot2, necesitarás dominar la gramática subyacente. Al comprender la gramática y cómo encajan sus componentes, puede crear una gama más amplia de visualizaciones, combinar múltiples fuentes de datos y personalizarlas a su gusto.\nEste capítulo describe la base teórica de ggplot2: la gramática en capas de gráficos. La gramática en capas se basa en la gramática de gráficos de Wilkinson (Wilkinson 2005), pero agrega una serie de mejoras que la ayudan a ser más expresiva y encajar perfectamente en el entorno R. Las diferencias entre la gramática en capas y la gramática de Wilkinson se describen detalladamente en Wickham (2008). En este capítulo aprenderá un poco sobre cada componente de la gramática y cómo encajan todos. Los siguientes capítulos analizan los componentes con más detalle y brindan más ejemplos de cómo usarlos en la práctica.\nLa gramática le facilita la actualización iterativa de un gráfico, cambiando una sola característica a la vez. La gramática también es útil porque sugiere los aspectos de alto nivel de una gráfica que pueden cambiarse, brindándole un marco para pensar en los gráficos y, con suerte, acortando la distancia entre la mente y el papel. También fomenta el uso de gráficos personalizados para un problema particular, en lugar de depender de tipos de gráficos específicos.\nEste capítulo comienza describiendo en detalle el proceso de dibujar una gráfica simple. Construyendo un diagrama de dispersión comienza con un diagrama de dispersión simple, luego Añadiendo complejidad lo hace más complejo agregando una línea suave y facetas. Mientras trabaja en estos ejemplos, se le presentarán los seis componentes de la gramática, que luego se definen con mayor precisión en Componentes de la gramática en capas..\n¿Cómo se relacionan el tamaño del motor y la economía de combustible? Podríamos crear un diagrama de dispersión de la cilindrada del motor y las mpg en carretera con puntos coloreados según el número de cilindros:\nggplot(mpg, aes(displ, hwy, colour = factor(cyl))) +\n  geom_point()\nPuedes crear gráficas como esta fácilmente, pero ¿qué sucede debajo de la superficie? ¿Cómo dibuja ggplot2 este gráfico?",
    "crumbs": [
      "La Gramática"
    ]
  },
  {
    "objectID": "mastery.html#sec-simple-plot",
    "href": "mastery.html#sec-simple-plot",
    "title": "La Gramática",
    "section": "",
    "text": "Mapeo de la estética a los datos\n¿Qué es exactamente un diagrama de dispersión? Has visto muchos antes y probablemente incluso hayas dibujado algunos a mano. Un diagrama de dispersión representa cada observación como un punto, posicionado según el valor de dos variables. Además de una posición horizontal y vertical, cada punto también tiene un tamaño, un color y una forma. Estos atributos se llaman estética y son las propiedades que se pueden percibir en el gráfico. Cada estética se puede asignar a partir de una variable o establecerse en un valor constante. En el gráfico anterior, “displ” se asigna a la posición horizontal, “hwy” a la posición vertical y “cyl” al color. El tamaño y la forma no se asignan, pero permanecen en sus valores predeterminados (constantes). \nUna vez que tengamos estas asignaciones, podemos crear un nuevo conjunto de datos que registre esta información:\n\n\n\n\nx\ny\ncolour\n\n\n\n1.8\n29\n4\n\n\n1.8\n29\n4\n\n\n2.0\n31\n4\n\n\n2.0\n30\n4\n\n\n2.8\n26\n6\n\n\n2.8\n26\n6\n\n\n3.1\n27\n6\n\n\n1.8\n26\n4\n\n\n\n\n\nEste nuevo conjunto de datos es el resultado de aplicar las asignaciones estéticas a los datos originales. Podemos crear muchos tipos diferentes de gráficos utilizando estos datos. El diagrama de dispersión utiliza puntos, pero si en su lugar se dibujasen líneas obtendríamos un diagrama de líneas. Si usáramos barras, obtendríamos un diagrama de barras. Ninguno de esos ejemplos tiene sentido para estos datos, pero aún así podríamos dibujarlos (hemos omitido las leyendas para ahorrar espacio):\nggplot(mpg, aes(displ, hwy, colour = factor(cyl))) +\n  geom_line() + \n  theme(legend.position = \"none\")\n\nggplot(mpg, aes(displ, hwy, colour = factor(cyl))) +\n  geom_bar(stat = \"identity\", position = \"identity\", fill = NA) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\nEn ggplot, podemos producir muchos gráficos que no tienen sentido, pero que son gramaticalmente válidos. Esto no es diferente al español, donde podemos crear oraciones sin sentido pero gramaticales como la roca enojada ladra como una coma.\nLos puntos, las líneas y las barras son ejemplos de objetos geométricos o geoms. Las geomas determinan el “tipo” de la gráfica. Las gráficas que utilizan una sola geom suelen recibir un nombre especial:\n\n\nNamed plot\nGeom\nOther features\n\n\n\ngráfico de dispersión\npoint\n\n\n\ngráfico de burbujas\npoint\nsize mapped to a variable\n\n\ngráfico de barras\nbar\n\n\n\ndiagrama de caja\nboxplot\n\n\n\ngráfico de línea\nline\n\n\n\n\nLas gráficas más complejas con combinaciones de múltiples geoms no tienen un nombre especial y tenemos que describirlas a mano. Por ejemplo, este gráfico superpone una línea de regresión por grupo encima de un diagrama de dispersión:\n\nggplot(mpg, aes(displ, hwy, colour = factor(cyl))) + \n  geom_point() + \n  geom_smooth(method = \"lm\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n¿Cómo llamarías a esta gráfica? Una vez que haya dominado la gramática, descubrirá que muchas de las gráficas que produzca se adaptan exclusivamente a sus problemas y ya no tendrán nombres especiales. \nEscalado\nLos valores de la tabla anterior no tienen significado para la computadora. Necesitamos convertirlos de unidades de datos (por ejemplo, litros, millas por galón y número de cilindros) a unidades gráficas (por ejemplo, píxeles y colores) que la computadora pueda mostrar. Este proceso de conversión se llama escalado y se realiza mediante escalas. Ahora que estos valores son significativos para la computadora, es posible que no lo sean para nosotros: los colores se representan mediante una cadena hexadecimal de seis letras, los tamaños mediante un número y las formas mediante un número entero. Estas especificaciones estéticas que son significativas para R se describen en vignette(\"ggplot2-specs\"). \nEn este ejemplo, tenemos tres estéticas que deben escalarse: posición horizontal (x), posición vertical (y) y colour. Escalar la posición es fácil en este ejemplo porque estamos usando las escalas lineales predeterminadas. Solo necesitamos un mapeo lineal desde el rango de datos hasta \\([0, 1]\\). Usamos \\([0, 1]\\) en lugar de píxeles exactos porque el sistema de dibujo que usa ggplot2, grid, se encarga de esa conversión final por nosotros. Un paso final determina cómo se combinan las dos posiciones (x e y) para formar la ubicación final en el gráfico. Esto lo realiza el sistema de coordenadas o coord. En la mayoría de los casos, serán coordenadas cartesianas, pero podrían ser coordenadas polares o una proyección esférica utilizada para un mapa.\nEl proceso de mapeo del color es un poco más complicado, ya que tenemos un resultado no numérico: colores. Sin embargo, se puede considerar que los colores tienen tres componentes, correspondientes a los tres tipos de células que detectan el color en el ojo humano. Estos tres tipos de células dan lugar a un espacio de color tridimensional. Luego, el escalado implica asignar los valores de datos a puntos en este espacio. Hay muchas formas de hacer esto, pero aquí, dado que cyl es una variable categórica, asignamos valores a tonos espaciados uniformemente en la rueda de colores, como se muestra en la siguiente figura. Se utiliza un mapeo diferente cuando la variable es continua. \n\n\n\n\nUna rueda de colores que ilustra la elección de cinco colores equiespaciados. Esta es la escala predeterminada para variables discretas.\n\n\n\nEl resultado de estas conversiones se encuentra a continuación. Además de la estética que se ha asignado a variables, también incluimos estéticas que son constantes. Los necesitamos para que la estética de cada punto esté completamente especificada y R pueda dibujar la gráfica. Los puntos serán círculos rellenos (forma 19 en R) con un diámetro de 1 mm:\n\n\n\n\nx\ny\ncolour\nsize\nshape\n\n\n\n0.037\n0.531\n#F8766D\n1\n19\n\n\n0.037\n0.531\n#F8766D\n1\n19\n\n\n0.074\n0.594\n#F8766D\n1\n19\n\n\n0.074\n0.562\n#F8766D\n1\n19\n\n\n0.222\n0.438\n#00BFC4\n1\n19\n\n\n0.222\n0.438\n#00BFC4\n1\n19\n\n\n0.278\n0.469\n#00BFC4\n1\n19\n\n\n0.037\n0.438\n#F8766D\n1\n19\n\n\n\n\n\nFinalmente, necesitamos representar estos datos para crear los objetos gráficos que se muestran en la pantalla. Para crear un gráfico completo necesitamos combinar objetos gráficos de tres fuentes: los datos, representados por el punto geom; las escalas y sistema de coordenadas, que generan ejes y leyendas para que podamos leer valores del gráfico; y anotaciones de la gráfica, como el fondo y el título de la gráfica.",
    "crumbs": [
      "La Gramática"
    ]
  },
  {
    "objectID": "mastery.html#sec-complex-plot",
    "href": "mastery.html#sec-complex-plot",
    "title": "La Gramática",
    "section": "Añadiendo complejidad",
    "text": "Añadiendo complejidad\nCon un ejemplo simple en nuestro haber, veamos ahora este ejemplo un poco más complicado:\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() +\n  geom_smooth() + \n  facet_wrap(~year)\n\n\n\n\n\n\n\nEsta gráfica agrega tres nuevos componentes a la mezcla: facetas, múltiples capas y estadísticas. Las facetas y capas amplían la estructura de datos descrita anteriormente: cada panel de facetas en cada capa tiene su propio conjunto de datos. Puedes pensar en esto como una matriz tridimensional: los paneles de las facetas forman una cuadrícula bidimensional y las capas se extienden hacia arriba en la tercera dimensión. En este caso, los datos de las capas son los mismos, pero en general podemos trazar diferentes conjuntos de datos en diferentes capas.\nLa capa suave es diferente de la capa de puntos porque no muestra los datos sin procesar, sino que muestra una transformación estadística de los datos. Específicamente, la capa suave se ajusta a una línea suave que pasa por el centro de los datos. Esto requiere un paso adicional en el proceso descrito anteriormente: después de asignar los datos a la estética, los datos se pasan a una transformación estadística, o stat, que manipula los datos de alguna manera útil. En este ejemplo, la estadística ajusta los datos de manera más suave y luego devuelve predicciones desde puntos espaciados uniformemente dentro del rango de los datos. Otras estadísticas útiles incluyen agrupamiento 1 y 2D, medias de grupo, regresión por cuantiles y contorno.\nAdemás de agregar un paso adicional para resumir los datos, también necesitamos algunos pasos adicionales cuando lleguemos a las escalas. Esto se debe a que ahora tenemos múltiples conjuntos de datos (para las diferentes facetas y capas) y debemos asegurarnos de que las escalas sean las mismas en todos ellos. En realidad, el escalamiento se produce en tres partes: transformación, capacitación y mapeo. No hemos mencionado la transformación antes, pero probablemente la hayas visto antes en gráficos log-log. En un gráfico log-log, los valores de los datos no se asignan linealmente a su posición en el gráfico, sino que primero se transforman logarítmicamente.\n\nLa transformación de escala ocurre antes de la transformación estadística, de modo que las estadísticas se calculan sobre los datos transformados a escala. Esto garantiza que una gráfica de \\(\\log(x)\\) frente a \\(\\log(y)\\) en escalas lineales se vea igual que \\(x\\) frente a \\(y\\) en escalas logarítmicas. Hay muchas transformaciones diferentes que se pueden utilizar, incluida la extracción de raíces cuadradas, logaritmos y recíprocos. Consulte 10  Escalas de posición y ejes. para obtener más detalles.\nUna vez calculadas las estadísticas, cada escala se entrena en cada conjunto de datos de todas las capas y facetas. La operación de entrenamiento combina los rangos de los conjuntos de datos individuales para obtener el rango de los datos completos. Sin este paso, las escalas sólo podrían tener sentido localmente y no podríamos superponer diferentes capas porque sus posiciones no se alinearían. A veces queremos variar las escalas de posición entre facetas (pero nunca entre capas), y esto se describe con más detalle en Control de escalas.\nFinalmente, las escalas asignan los valores de los datos a valores estéticos. Esta es una operación local: las variables en cada conjunto de datos se asignan a sus valores estéticos, lo que produce un nuevo conjunto de datos que luego las geoms pueden representar.\n\nLa siguiente figura ilustra esquemáticamente el proceso completo.\n\n\n\n\nDescripción esquemática del proceso de generación de gráficas. Cada cuadrado representa una capa y este esquema representa una gráfica con tres capas y tres paneles. Todos los pasos funcionan transformando marcos de datos individuales, excepto las escalas de entrenamiento, que no afectan el marco de datos y operan en todos los conjuntos de datos simultáneamente.",
    "crumbs": [
      "La Gramática"
    ]
  },
  {
    "objectID": "mastery.html#sec-components",
    "href": "mastery.html#sec-components",
    "title": "La Gramática",
    "section": "Componentes de la gramática en capas.",
    "text": "Componentes de la gramática en capas.\nEn los ejemplos anteriores, hemos visto algunos de los componentes que componen una gráfica: datos y asignaciones estéticas, objetos geométricos (geoms), transformaciones estadísticas (stats), escalas y facetas. También hemos tocado el sistema de coordenadas. Una cosa que no mencionamos es el ajuste de posición, que se ocupa de la superposición de objetos gráficos. Juntos, los datos, asignaciones, estadísticas, geom y ajustes de posición forman una capa. Un gráfico puede tener varias capas, como en el ejemplo en el que superpusimos una línea suavizada en un diagrama de dispersión. En conjunto, la gramática en capas define una gráfica como la combinación de: \n\nUn conjunto de datos predeterminado y un conjunto de asignaciones de variables a estética.\nUna o más capas, cada una compuesta por un objeto geométrico, una transformación estadística, un ajuste de posición y, opcionalmente, un conjunto de datos y mapeos estéticos.\nUna escala para cada mapeo estético.\nUn sistema de coordenadas.\nLa especificación de facetado.\n\nLas siguientes secciones describen cada uno de los componentes de nivel superior con mayor precisión y le indican las partes del libro donde están documentados.\nCapas\nLas capas son las encargadas de crear los objetos que percibimos en la gráfica. Una capa se compone de cinco partes:\n\nDatos\nMapeos estéticos.\nUna transformación estadística (stat).\nUn objeto geométrico (geom).\nUn ajuste de posición.\n\nLas propiedades de una capa se describen en 13  Construya una gráfica capa por capa y sus usos para la visualización de datos se describen en 3  Geomas individuales a 8  Anotaciones.\nEscalas\nUna escala controla el mapeo de los datos a los atributos estéticos, y necesitamos una escala para cada estética utilizada en una gráfica. Cada escala opera en todos los datos del gráfico, lo que garantiza un mapeo consistente desde los datos hasta la estética. Algunos ejemplos se muestran a continuación.\n\n\n\n\nEjemplos de leyendas de cuatro escalas diferentes. De izquierda a derecha: variable continua asignada a tamaño y color, variable discreta asignada a forma y color. El orden de las escalas parece al revés, pero coincide con el etiquetado del eje \\(y\\): los valores pequeños aparecen en la parte inferior.\n\n\n\nUna escala es una función y su inversa, junto con un conjunto de parámetros. Por ejemplo, la escala de gradiente de color asigna un segmento de la línea real a una ruta a través de un espacio de color. Los parámetros de la función definen si la ruta es lineal o curva, qué espacio de color usar (por ejemplo, LUV o RGB) y los colores al principio y al final.\nLa función inversa se utiliza para dibujar una guía para que pueda leer los valores del gráfico. Las guías son ejes (para escalas de posición) o leyendas (para todo lo demás). La mayoría de las asignaciones tienen una inversa única (es decir, la función de asignación es uno a uno), pero muchas no la tienen. Un inverso único permite recuperar los datos originales, pero esto no siempre es deseable si queremos centrar la atención en un solo aspecto.\nPara más detalles, ver 11  Escalas de colores y leyendas..\nSistema coordinado\nUn sistema de coordenadas, o coord para abreviar, asigna la posición de los objetos al plano del gráfico. La posición a menudo se especifica mediante dos coordenadas \\((x, y)\\), pero potencialmente podrían ser tres o más (aunque esto no está implementado en ggplot2). El sistema de coordenadas cartesiano es el sistema de coordenadas más común para dos dimensiones, mientras que las coordenadas polares y varias proyecciones cartográficas se utilizan con menos frecuencia.\nLos sistemas de coordenadas afectan a todas las variables de posición simultáneamente y se diferencian de las escalas en que también cambian la apariencia de los objetos geométricos. Por ejemplo, en coordenadas polares, las geomas de barra parecen segmentos de un círculo. Además, el escalado se realiza antes de la transformación estadística, mientras que las transformaciones de coordenadas se producen después. Las consecuencias de esto se muestran en Sistemas de coordenadas no lineales.\nLos sistemas de coordenadas controlan cómo se dibujan los ejes y las líneas de la cuadrícula. La siguiente figura ilustra tres tipos diferentes de sistemas de coordenadas: cartesiano, semilogarítmico y polar. Hay muy pocos consejos disponibles para dibujarlos para sistemas de coordenadas no cartesianas, por lo que se necesita mucho trabajo por hacer para producir resultados pulidos. Consulte 15  Sistemas coordinados para obtener más detalles.\n\n\n\n\n\n\n\n\n\n\n\n\n\nEl sistema de coordenadas polares ilustra las dificultades asociadas con las coordenadas no cartesianas: es difícil dibujar bien los ejes.\nFacetado\nTambién hay otra cosa que resulta suficientemente útil como para incluirla en nuestro marco general: el facetado, un caso general de gráficas condicionadas o enrejadas. Esto facilita la creación de pequeños múltiplos, cada uno de los cuales muestra un subconjunto diferente de todo el conjunto de datos. Esta es una herramienta poderosa para investigar si los patrones se mantienen en todas las condiciones. La especificación de facetado describe qué variables deben usarse para dividir los datos y si las escalas de posición deben ser libres o restringidas. El facetado se describe en Ajustes de posición.",
    "crumbs": [
      "La Gramática"
    ]
  },
  {
    "objectID": "mastery.html#ejercicios",
    "href": "mastery.html#ejercicios",
    "title": "La Gramática",
    "section": "Ejercicios",
    "text": "Ejercicios\n\n\n\nUna de las mejores formas de comprender cómo funciona la gramática es aplicarla al análisis de gráficos existentes. Para cada uno de los gráficos enumerados a continuación, escriba los componentes del gráfico. No te preocupes si no sabes cómo se llaman las funciones correspondientes en ggplot2 (¡o si siquiera existen!), enfócate en registrar los elementos clave de una gráfica para poder comunicárselo a otra persona.\n\n“La marcha de Napoleón” de Charles John Minard: http://www.datavis.ca/gallery/re-minard.php\n“Donde el calor y el trueno acertaron”, por Jeremy White, Joe Ward y Matthew Ericson en The New York Times. http://nyti.ms/1duzTvY\n“Viajes de alquiler de bicicletas en Londres”, por James Cheshire. http://bit.ly/1S2cyRy\nLas visualizaciones de datos favoritas del Pew Research Center de 2014: http://pewrsr.ch/1KZSSN6\n“Los Tony nunca han estado tan dominados por las mujeres”, por Joanna Kao en FiveThirtyEight: http://53eig.ht/1cJRCyG\n“En Climbing Income Ladder, la ubicación importa”, de Mike Bostock, Shan Carter, Amanda Cox, Matthew Ericson, Josh Keller, Alicia Parlapiano, Kevin Quealy y Josh Williams en el New York Times: http://nyti.ms/1S2dJQT\n“Diseccionando un tráiler: las partes de la película que hacen el corte”, por Shan Carter, Amanda Cox y Mike Bostock en el New York Times: http://nyti.ms/1KTJQOE\n\n\n\n\n\n\n\nWickham, Hadley. 2008. «Practical tools for exploring data and models». Tesis doctoral, Iowa State University. http://had.co.nz/thesis.\n\n\nWilkinson, Leland. 2005. The Grammar of Graphics. 2nd ed. Statistics y Computing. Springer.",
    "crumbs": [
      "La Gramática"
    ]
  },
  {
    "objectID": "layers.html",
    "href": "layers.html",
    "title": "13  Construya una gráfica capa por capa",
    "section": "",
    "text": "13.1 Introducción\nUna de las ideas clave detrás de ggplot2 es que le permite iterar fácilmente, construyendo un gráfico complejo capa por capa. Cada capa puede provenir de un conjunto de datos diferente y tener un mapeo estético diferente, lo que permite crear gráficos sofisticados que muestran datos de múltiples fuentes.\nYa has creado capas con funciones como geom_point() y geom_histogram(). En este capítulo, profundizará en los detalles de una capa y en cómo puede controlar los cinco componentes: datos, asignaciones estéticas, geom, estadísticas y ajustes de posición. El objetivo aquí es brindarle las herramientas para crear gráficos sofisticados adaptados al problema en cuestión.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Construya una gráfica capa por capa</span>"
    ]
  },
  {
    "objectID": "layers.html#construyendo-una-gráfica",
    "href": "layers.html#construyendo-una-gráfica",
    "title": "13  Construya una gráfica capa por capa",
    "section": "\n13.2 Construyendo una gráfica",
    "text": "13.2 Construyendo una gráfica\nHasta ahora, cada vez que creamos un gráfico con ggplot(), inmediatamente agregamos una capa con una función geom. Pero es importante darse cuenta de que en realidad hay dos pasos distintos. Primero, creamos un gráfico con un conjunto de datos predeterminado y asignaciones estéticas:\n\np &lt;- ggplot(mpg, aes(displ, hwy))\np\n\n\n\n\n\n\n\nNo hay nada que ver todavía, así que necesitamos agregar una capa:\n\np + geom_point()\n\n\n\n\n\n\n\ngeom_point() es un atajo. Detrás de escena, llama a la función layer() para crear una nueva capa: \n\np + layer(\n  mapping = NULL, \n  data = NULL,\n  geom = \"point\", \n  stat = \"identity\",\n  position = \"identity\"\n)\n\nEsta llamada especifica completamente los cinco componentes de la capa: \n\nmapping: Un conjunto de asignaciones estéticas, especificadas mediante la función aes() y combinadas con los valores predeterminados de la gráfica como se describe en Sección 13.4. Si es NULL, utiliza la asignación predeterminada establecida en ggplot().\ndata: Un conjunto de datos que anula el conjunto de datos de trazado predeterminado. Generalmente se omite (establecido en NULL), en cuyo caso la capa utilizará los datos predeterminados especificados en ggplot(). Los requisitos de datos se explican con más detalle en Sección 13.3.\n\ngeom: El nombre del objeto geométrico que se utilizará para dibujar cada observación. Las geoms se analizan con más detalle en Sección 13.3, y Capítulo 3 y Capítulo 4 exploran su uso con más profundidad.\nLas geoms pueden tener argumentos adicionales. Todas las geoms toman la estética como parámetro. Si proporciona una estética (por ejemplo, color) como parámetro, no se escalará, lo que le permitirá controlar la apariencia del gráfico, como se describe en Sección 13.4.2. Puede pasar parámetros en ... (en cuyo caso los parámetros stat y geom se separan automáticamente), o en una lista pasada a geom_params.\n\n\nstat: El nombre de la transformación estadística a utilizar. Una transformación estadística realiza un resumen estadístico útil y es clave para histogramas y suavizadores. Para mantener los datos tal como están, utilice la estadística de “identidad”. Obtenga más información en Sección 13.6.\nSolo necesita configurar una estadística y una geom: cada geom tiene una estadística predeterminada y cada estadística una geom predeterminada.\nLa mayoría de las estadísticas toman parámetros adicionales para especificar los detalles de la transformación estadística. Puede proporcionar parámetros en ... (en cuyo caso los parámetros stat y geom se separan automáticamente) o en una lista llamada stat_params.\n\nposition: El método utilizado para ajustar objetos superpuestos, como vibrar, apilar o esquivar. Más detalles en Sección 13.7.\n\nEs útil comprender la función layer() para tener un mejor modelo mental del objeto de capa. Pero rara vez utilizarás la llamada layer() completa porque es muy detallada. En su lugar, usarás las funciones de acceso directo geom_: geom_point(mapping, data, ...) es exactamente equivalente a layer(mapping, data, geom = \"point\", ...).",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Construya una gráfica capa por capa</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-data",
    "href": "layers.html#sec-data",
    "title": "13  Construya una gráfica capa por capa",
    "section": "\n13.3 Datos",
    "text": "13.3 Datos\nCada capa debe tener algunos datos asociados y esos datos deben estar en un marco de datos ordenado. Los marcos de datos ordenados se describen con más detalle en R para ciencia de datos (https://r4ds.had.co.nz), pero por ahora, todo lo que necesita saber es que un marco de datos ordenado tiene variables en las columnas y observaciones en las filas. Esta es una restricción fuerte, pero hay buenas razones para ello: \n\nTus datos son muy importantes, por eso lo mejor es ser explícito al respecto.\nUn único marco de datos también es más fácil de guardar que una multitud de vectores, lo que significa que es más fácil reproducir los resultados o enviar los datos a otra persona.\nImpone una clara separación de preocupaciones: ggplot2 convierte los marcos de datos en visualizaciones. Otros paquetes pueden crear marcos de datos en el formato correcto.\n\nNo es necesario que los datos de cada capa sean los mismos y, a menudo, resulta útil combinar varios conjuntos de datos en un solo gráfico. Para ilustrar esa idea, generaremos dos nuevos conjuntos de datos relacionados con el conjunto de datos de mpg. Primero, ajustaremos un modelo loess y generaremos predicciones a partir de él. (Esto es lo que geom_smooth() hace detrás de escena)\n\nmod &lt;- loess(hwy ~ displ, data = mpg)\ngrid &lt;- tibble(displ = seq(min(mpg$displ), max(mpg$displ), length = 50))\ngrid$hwy &lt;- predict(mod, newdata = grid)\n\ngrid\n#&gt; # A tibble: 50 × 2\n#&gt;   displ   hwy\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  1.6   33.1\n#&gt; 2  1.71  32.2\n#&gt; 3  1.82  31.3\n#&gt; 4  1.93  30.4\n#&gt; 5  2.04  29.6\n#&gt; 6  2.15  28.8\n#&gt; # ℹ 44 more rows\n\nA continuación, aislaremos las observaciones que están particularmente alejadas de sus valores previstos:\n\nstd_resid &lt;- resid(mod) / mod$s\noutlier &lt;- filter(mpg, abs(std_resid) &gt; 2)\noutlier\n#&gt; # A tibble: 6 × 11\n#&gt;   manufacturer model      displ  year   cyl trans  drv     cty   hwy fl    class\n#&gt;   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 chevrolet    corvette     5.7  1999     8 manua… r        16    26 p     2sea…\n#&gt; 2 pontiac      grand prix   3.8  2008     6 auto(… f        18    28 r     mids…\n#&gt; 3 pontiac      grand prix   5.3  2008     8 auto(… f        16    25 p     mids…\n#&gt; 4 volkswagen   jetta        1.9  1999     4 manua… f        33    44 d     comp…\n#&gt; 5 volkswagen   new beetle   1.9  1999     4 manua… f        35    44 d     subc…\n#&gt; 6 volkswagen   new beetle   1.9  1999     4 auto(… f        29    41 d     subc…\n\nHemos generado estos conjuntos de datos porque es común mejorar la visualización de datos sin procesar con un resumen estadístico y algunas anotaciones. Con estos nuevos conjuntos de datos, podemos mejorar nuestro diagrama de dispersión inicial superponiendo una línea suavizada y etiquetando los puntos periféricos:\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  geom_line(data = grid, colour = \"blue\", linewidth = 1.5) +\n  geom_text(data = outlier, aes(label = model))\n\n\n\n\n\n\n\n(Las etiquetas no son particularmente fáciles de leer, pero puedes solucionarlo con algunos ajustes manuales).\nTenga en cuenta que necesita el data = explícito en las capas, pero no en la llamada a ggplot(). Esto se debe a que el orden de los argumentos es diferente. Esto es un poco inconsistente, pero reduce la escritura en el caso común en el que especificas los datos una vez en ggplot() y modificas la estética en cada capa.\nEn este ejemplo, cada capa utiliza un conjunto de datos diferente. Podríamos definir el mismo gráfico de otra manera, omitiendo el conjunto de datos predeterminado y especificando un conjunto de datos para cada capa:\n\nggplot(mapping = aes(displ, hwy)) + \n  geom_point(data = mpg) + \n  geom_line(data = grid) + \n  geom_text(data = outlier, aes(label = model))\n\nNo nos gusta particularmente este estilo en este ejemplo porque deja menos claro cuál es el conjunto de datos principal (y debido a la forma en que están ordenados los argumentos de ggplot(), en realidad requiere más pulsaciones de teclas). Sin embargo, es posible que lo prefiera en los casos en los que no haya un conjunto de datos primario claro o en los que la estética también varíe de una capa a otra.\n\n13.3.1 Ejercicios\n\nLos dos primeros argumentos de ggplot son “datos” y “mapeo”. Los dos primeros argumentos de todas las funciones de capa son “mapeo” y “datos”. ¿Por qué difiere el orden de los argumentos? (Sugerencia: piense en lo que configura con más frecuencia).\n\nEl siguiente código utiliza dplyr para generar algunas estadísticas resumidas sobre cada clase de automóvil.\n\nlibrary(dplyr)\nclass &lt;- mpg %&gt;% \n  group_by(class) %&gt;% \n  summarise(n = n(), hwy = mean(hwy))\n\nUtilice los datos para recrear esta gráfica:",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Construya una gráfica capa por capa</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-aes",
    "href": "layers.html#sec-aes",
    "title": "13  Construya una gráfica capa por capa",
    "section": "\n13.4 Mapeos estéticos",
    "text": "13.4 Mapeos estéticos\nLas asignaciones estéticas, definidas con aes(), describen cómo se asignan las variables a propiedades visuales o estética. aes() toma una secuencia de pares de variables estéticas como esta: \n\naes(x = displ, y = hwy, colour = class)\n\n(Si eres estadounidense, puedes usar color, y detrás de escena ggplot2 corregirá tu ortografía;)\nAquí asignamos la posición x a displ, la posición y a hwy y el color a class. Los nombres de los dos primeros argumentos se pueden omitir, en cuyo caso corresponden a las variables x e y. Eso hace que esta especificación sea equivalente a la anterior:\n\naes(displ, hwy, colour = class)\n\nSi bien puedes manipular datos en aes(), p. aes(log(carat), log(price)), es mejor hacer sólo cálculos simples. Es mejor mover transformaciones complejas fuera de la llamada aes() y llevarlas a una llamada explícita dplyr::mutate(). Esto hace que sea más fácil verificar tu trabajo y, a menudo, es más rápido porque solo necesitas hacer la transformación una vez, no cada vez que se dibuja la gráfica.\nNunca haga referencia a una variable con $ (por ejemplo, diamondss$carat) en aes(). Esto rompe la contención, de modo que el gráfico ya no contiene todo lo que necesita y causa problemas si ggplot2 cambia el orden de las filas, como lo hace al facetar. \n\n13.4.1 Especificando la estética en la gráfica versus en las capas.\nLos mapeos estéticos se pueden proporcionar en la llamada inicial a ggplot(), en capas individuales o en alguna combinación de ambas. Todas estas llamadas crean la misma especificación de gráfica: \n\nggplot(mpg, aes(displ, hwy, colour = class)) + \n  geom_point()\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(aes(colour = class))\nggplot(mpg, aes(displ)) + \n  geom_point(aes(y = hwy, colour = class))\nggplot(mpg) + \n  geom_point(aes(displ, hwy, colour = class))\n\nDentro de cada capa, puede agregar, anular o eliminar asignaciones. Por ejemplo, si tiene un gráfico que utiliza los datos mpg que tiene aes(displ, hwy) como punto de partida, la siguiente tabla ilustra las tres operaciones:\n  Operación | Estética de capas | Resultado |\n|:—’’’——-|:——————–|:——————————–| | Añadir | aes(colour = cyl) | aes(displ, hwy, colour = cyl) | | Sobreescribir| aes(y = cty) | aes(displ, cty) | | Remover | aes(y = NULL) | aes(displ) |\nSi solo tiene una capa en el trazado, la forma en que especifique la estética no hace ninguna diferencia. Sin embargo, la distinción es importante cuando empiezas a agregar capas adicionales. Estos dos gráficos son válidos e interesantes, pero se centran en bastantes aspectos diferentes de los datos:\nggplot(mpg, aes(displ, hwy, colour = class)) + \n  geom_point() + \n  geom_smooth(method = \"lm\", se = FALSE) +\n  theme(legend.position = \"none\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(aes(colour = class)) + \n  geom_smooth(method = \"lm\", se = FALSE) + \n  theme(legend.position = \"none\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\nGeneralmente, desea configurar las asignaciones para iluminar la estructura subyacente al gráfico y minimizar la escritura. Puede pasar algún tiempo antes de que el mejor enfoque sea inmediatamente obvio, por lo que si ha iterado hasta llegar a un gráfico complejo, puede que valga la pena reescribirlo para que la estructura sea más clara.\n\n13.4.2 Configuración versus mapeo\nEn lugar de asignar una propiedad estética a una variable, puede establecerla en un valor único especificándolo en los parámetros de la capa. Asignamos una estética a una variable (p. ej., aes(colour = cut)) o la establecemos en una constante (p. ej., colour = \"red\"). Si desea que la apariencia esté gobernada por una variable, coloque la especificación dentro de aes(); Si desea anular el tamaño o color predeterminado, coloque el valor fuera de aes(). \nLos siguientes gráficos se crean con código similar, pero tienen resultados bastante diferentes. El segundo gráfico asigna (no establece) el color al valor ‘darkblue’. Esto crea efectivamente una nueva variable que contiene solo el valor ‘darkblue’ y luego la escala con una escala de colores. Debido a que este valor es discreto, la escala de colores predeterminada utiliza colores espaciados uniformemente en la rueda de colores y, como solo hay un valor, este color es rosado.\nggplot(mpg, aes(cty, hwy)) + \n  geom_point(colour = \"darkblue\") \n\nggplot(mpg, aes(cty, hwy)) + \n  geom_point(aes(colour = \"darkblue\"))\n\n\n\n\n\n\n\n\n\n\nUn tercer enfoque consiste en asignar el valor, pero anular la escala predeterminada:\n\nggplot(mpg, aes(cty, hwy)) + \n  geom_point(aes(colour = \"darkblue\")) + \n  scale_colour_identity()\n\n\n\n\n\n\n\nEsto es más útil si siempre tienes una columna que ya contiene colores. Aprenderá más sobre eso en Sección 12.6.\nA veces resulta útil asignar la estética a constantes. Por ejemplo, si desea mostrar varias capas con diferentes parámetros, puede “name” cada capa:\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() +\n  geom_smooth(aes(colour = \"loess\"), method = \"loess\", se = FALSE) + \n  geom_smooth(aes(colour = \"lm\"), method = \"lm\", se = FALSE) +\n  labs(colour = \"Method\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n13.4.3 Ejercicios\n\n\nSimplifique las siguientes especificaciones de la gráfica:\n\nggplot(mpg) + \n  geom_point(aes(mpg$displ, mpg$hwy))\n\nggplot() + \n geom_point(mapping = aes(y = hwy, x = cty), data = mpg) +\n geom_smooth(data = mpg, mapping = aes(cty, hwy))\n\nggplot(diamonds, aes(carat, price)) + \n  geom_point(aes(log(brainwt), log(bodywt)), data = msleep)\n\n\n\n¿Qué hace el siguiente código? ¿Funciona? ¿Tiene sentido? ¿Por qué por qué no?\n\nggplot(mpg) +\n  geom_point(aes(class, cty)) + \n  geom_boxplot(aes(trans, hwy))\n\n\n¿Qué sucede si intenta utilizar una variable continua en el eje x en una capa y una variable categórica en otra capa? ¿Qué pasa si lo haces en el orden inverso?",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Construya una gráfica capa por capa</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-geom",
    "href": "layers.html#sec-geom",
    "title": "13  Construya una gráfica capa por capa",
    "section": "\n13.5 Geomas",
    "text": "13.5 Geomas\nLos objetos geométricos, o geoms para abreviar, realizan la representación real de la capa, controlando el tipo de trazado que crea. Por ejemplo, usar una geom de puntos creará un diagrama de dispersión, mientras que usar una geom de líneas creará un diagrama de líneas.\n\nPrimitivas gráficas:\n\n\ngeom_blank(): no mostrar nada. Más útil para ajustar los límites de los ejes utilizando datos.\n\ngeom_point(): puntos.\n\ngeom_path(): Conecta las observaciones en el orden en que aparecen en los datos.\n\ngeom_ribbon(): cintas, un camino con espesor vertical..\n\ngeom_segment(): un segmento de línea, especificado por la posición inicial y final.\n\ngeom_rect(): rectángulos.\n\ngeom_polygon(): polígonos rellenos.\n\ngeom_text(): texto.\n\n\nUna variable:\n\nDiscreta:\n\n\ngeom_bar(): mostrar la distribución de la variable discreta.\n\n\nContinua:\n\n\ngeom_histogram(): bin y contar variable continua, visualización con barras.\n\ngeom_density(): estimación de densidad suavizada.\n\ngeom_dotplot(): apila puntos individuales en un diagrama de puntos.\n\ngeom_freqpoly(): agrupa y cuenta variable continua, visualización con líneas.\n\n\n\n\nDos variables:\n\nAmbas continuas:\n\n\ngeom_point(): gráfico de dispersión.\n\ngeom_quantile(): regresión cuantil suavizada.\n\ngeom_rug(): gráficas marginales de alfombras.\n\ngeom_smooth(): línea suavizada de mejor ajuste.\n\ngeom_text(): etiquetas de texto.\n\n\nDistribución:\n\n\ngeom_bin2d(): agrupa en rectángulos y cuenta.\n\ngeom_density2d(): estimación de densidad 2d suavizada.\n\ngeom_hex(): agrupa en hexágonos y cuenta.\n\n\nAl menos una discreta:\n\n\ngeom_count(): contar el número de puntos en distintas ubicaciones\n\ngeom_jitter(): agitar aleatoriamente puntos superpuestos.\n\n\nUno continuo, uno discreto:\n\n\ngeom_bar(stat = \"identity\"): un gráfico de barras de resúmenes precalculados.\n\ngeom_boxplot(): diagramas de caja.\n\ngeom_violin(): mostrar la densidad de valores en cada grupo.\n\n\nUna vez, uno continuo:\n\n\ngeom_area(): gráfica de área.\n\ngeom_line(): diagrama de líneas.\n\ngeom_step(): gráfica escalonada.\n\n\nMostrar incertidumbre:\n\n\ngeom_crossbar(): barra vertical con centro.\n\ngeom_errorbar(): barras de error.\n\ngeom_linerange(): linea vertical.\n\ngeom_pointrange(): línea vertical con centro.\n\n\nEspacial:\n\n\ngeom_map(): versión rápida de geom_polygon() para datos de mapas.\n\n\n\n\nTres variables:\n\n\ngeom_contour(): contornos.\n\ngeom_tile(): mosaico el avión con rectángulos.\n\ngeom_raster(): versión rápida de geom_tile() para mosaicos del mismo tamaño.\n\n\n\nCada geom tiene un conjunto de estéticas que comprende, algunas de las cuales deben proporcionarse. Por ejemplo, las geoms puntuales requieren la posición x e y, y comprenden la estética del color, el tamaño y la forma. Una barra requiere altura (ymax) y comprende el ancho, el color del borde y el color de relleno. Cada geom enumera su estética en la documentación.\nAlgunas geoms se diferencian principalmente en la forma en que están parametrizadas. Por ejemplo, puedes dibujar un cuadrado de tres maneras: \n\nAl darle a geom_tile() la ubicación (x e y) y las dimensiones (width y height). \nDando a geom_rect() las posiciones superior (ymax), inferior (ymin), izquierda (xmin) y derecha (xmax). \nDándole a geom_polygon() un marco de datos de cuatro filas con las posiciones x e y de cada esquina.\n\nOtras geomas relacionadas son:\n\n\ngeom_segment() y geom_line()\n\n\ngeom_area() y geom_ribbon().\n\nSi hay parametrizaciones alternativas disponibles, elegir la adecuada para sus datos normalmente hará que sea mucho más fácil dibujar el gráfico que desea.\n\n13.5.1 Ejercicios\n\nDescargue e imprima la hoja de referencia de ggplot2 desde https://posit.co/resources/cheatsheets/ para tener una referencia visual útil para todas las geoms.\nMire la documentación para las geoms primitivas gráficas. ¿Qué estética utilizan? ¿Cómo puedes resumirlos en una forma compacta?\n¿Cuál es la mejor manera de dominar una geom desconocida? Enumere tres recursos que le ayudarán a empezar.\n\nPara cada uno de los gráficos siguientes, identifica la geom utilizada para dibujarlo.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara cada uno de los siguientes problemas, sugiera una geom útil:\n\nMuestra cómo una variable ha cambiado con el tiempo.\nMostrar la distribución detallada de una sola variable.\nCentrar la atención en la tendencia general en un gran conjunto de datos.\nDibujar un mapa.\nEtiquetar puntos periféricos.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Construya una gráfica capa por capa</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-stat",
    "href": "layers.html#sec-stat",
    "title": "13  Construya una gráfica capa por capa",
    "section": "\n13.6 Estadísticas",
    "text": "13.6 Estadísticas\nUna transformación estadística, o stat, transforma los datos, normalmente resumiéndolos de alguna manera. Por ejemplo, una estadística útil es la más suave, que calcula la media suavizada de y, condicionada a x. Ya has usado muchas de las estadísticas de ggplot2 porque se usan detrás de escena para generar muchas geoms importantes:\n\n\nstat_bin(): geom_bar(), geom_freqpoly(), geom_histogram()\n\n\nstat_bin2d(): geom_bin2d()\n\n\nstat_bindot(): geom_dotplot()\n\n\nstat_binhex(): geom_hex()\n\n\nstat_boxplot(): geom_boxplot()\n\n\nstat_contour(): geom_contour()\n\n\nstat_quantile(): geom_quantile()\n\n\nstat_smooth(): geom_smooth()\n\n\nstat_sum(): geom_count()\n\n\nRara vez llamará a estas funciones directamente, pero es útil conocerlas porque su documentación a menudo proporciona más detalles sobre la transformación estadística correspondiente.\nNo se pueden crear otras estadísticas con una función geom_:\n\n\nstat_ecdf(): calcular una gráfica de distribución acumulativa empírica.\n\nstat_function(): calcular los valores de y a partir de una función de los valores de x.\n\nstat_summary(): resumir los valores de y en distintos valores de x.\n\nstat_summary2d(), stat_summary_hex(): resumir los valores agrupados.\n\nstat_qq(): realizar cálculos para una gráfica cuantil-cuantil.\n\nstat_spoke(): convertir ángulo y radio en posición.\n\nstat_unique(): eliminar filas duplicadas.\n\nHay dos formas de utilizar estas funciones. Puede agregar una función stat_() y anular la estadística predeterminada, o agregar una función geom_() y anular la estadística predeterminada:\n\nggplot(mpg, aes(trans, cty)) + \n  geom_point() + \n  stat_summary(geom = \"point\", fun = \"mean\", colour = \"red\", size = 4)\n\nggplot(mpg, aes(trans, cty)) + \n  geom_point() + \n  geom_point(stat = \"summary\", fun = \"mean\", colour = \"red\", size = 4)\n\n\n\n\n\n\n\nCreemos que es mejor utilizar el segundo formulario porque deja más claro que se muestra un resumen, no los datos sin procesar.\n\n13.6.1 Variables generadas\nInternamente, una estadística toma un marco de datos como entrada y devuelve un marco de datos como salida, por lo que una estadística puede agregar nuevas variables al conjunto de datos original. Es posible asignar la estética a estas nuevas variables. Por ejemplo, stat_bin, la estadística utilizada para crear histogramas, produce las siguientes variables: \n\n\ncount, el número de observaciones en cada contenedor\n\ndensity, la densidad de observaciones en cada contenedor (porcentaje del total/ancho de barra)\n\nx, el centro del contenedor\n\nEstas variables generadas se pueden utilizar en lugar de las variables presentes en el conjunto de datos original. Por ejemplo, la geom de histograma predeterminada asigna la altura de las barras al número de observaciones (count), pero si prefieres un histograma más tradicional, puedes usar la densidad (density). Para hacer referencia a una variable generada como densidad, “after_stat()” debe ajustar el nombre. Esto evita confusiones en caso de que el conjunto de datos original incluya una variable con el mismo nombre que una variable generada y deja claro a cualquier lector posterior del código que esta variable fue generada por una estadística. Cada estadística enumera las variables que crea en su documentación. Compare los ejes y en estos dos gráficos:\nggplot(diamonds, aes(price)) + \n  geom_histogram(binwidth = 500)\n\nggplot(diamonds, aes(price)) + \n  geom_histogram(aes(y = after_stat(density)), binwidth = 500)\n\n\n\n\n\n\n\n\n\n\nEsta técnica es particularmente útil cuando desea comparar la distribución de múltiples grupos que tienen tamaños muy diferentes. Por ejemplo, es difícil comparar la distribución del price dentro del cut porque algunos grupos son bastante pequeños. Es más fácil comparar si estandarizamos cada grupo para que ocupe la misma área:\nggplot(diamonds, aes(price, colour = cut)) + \n  geom_freqpoly(binwidth = 500) +\n  theme(legend.position = \"none\")\n\nggplot(diamonds, aes(price, colour = cut)) + \n  geom_freqpoly(aes(y = after_stat(density)), binwidth = 500) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\nEl resultado de este complot es bastante sorprendente: los diamantes de baja calidad parecen ser más caros en promedio.\n\n13.6.2 Ejercicios\n\n\nEl siguiente código crea un conjunto de datos similar a stat_smooth(). Utilice las geoms apropiadas para imitar la visualización predeterminada geom_smooth().\n\nmod &lt;- loess(hwy ~ displ, data = mpg)\nsmoothed &lt;- data.frame(displ = seq(1.6, 7, length = 50))\npred &lt;- predict(mod, newdata = smoothed, se = TRUE) \nsmoothed$hwy &lt;- pred$fit\nsmoothed$hwy_lwr &lt;- pred$fit - (1.96 * pred$se.fit)\nsmoothed$hwy_upr &lt;- pred$fit + (1.96 * pred$se.fit)\n\n\n\n¿Qué estadísticas se utilizaron para crear las siguientes gráficas?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLea la ayuda para stat_sum() y luego use geom_count() para crear un gráfico que muestre la proporción de automóviles que tienen cada combinación de drv y trans.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Construya una gráfica capa por capa</span>"
    ]
  },
  {
    "objectID": "layers.html#sec-position",
    "href": "layers.html#sec-position",
    "title": "13  Construya una gráfica capa por capa",
    "section": "\n13.7 Ajustes de posición",
    "text": "13.7 Ajustes de posición\n\nLos ajustes de posición aplican ajustes menores a la posición de los elementos dentro de una capa. Tres ajustes se aplican principalmente a las barras:\n \n\n\nposition_stack(): apile barras (o áreas) superpuestas una encima de la otra.\n\nposition_fill(): apile barras superpuestas, escalando para que la parte superior esté siempre en 1.\n\nposition_dodge(): coloque barras superpuestas (o diagramas de caja) una al lado de la otra.\n\ndplot &lt;- ggplot(diamonds, aes(color, fill = cut)) + \n  xlab(NULL) + ylab(NULL) + theme(legend.position = \"none\")\n# La pila de posiciones es la predeterminada para las barras, por lo que `geom_bar()` \n# es equivalente a `geom_bar(position = \"stack\")`.\ndplot + geom_bar()\ndplot + geom_bar(position = \"fill\")\ndplot + geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nTambién hay un ajuste de posición que no hace nada: position_identity(). El ajuste de la posición de identidad no es útil para las barras, porque cada barra oscurece las barras detrás, pero hay muchas geoms que no necesitan ajuste, como las líneas:\ndplot + geom_bar(position = \"identity\", alpha = 1 / 2, colour = \"grey50\")\n\nggplot(diamonds, aes(color, colour = cut)) + \n  geom_line(aes(group = cut), stat = \"count\") + \n  xlab(NULL) + ylab(NULL) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\nHay tres ajustes de posición que son principalmente útiles para los puntos:\n\n\nposition_nudge(): mover puntos con un desplazamiento fijo.\n\nposition_jitter(): agregue un poco de ruido aleatorio a cada posición.\n\nposition_jitterdodge(): Esquiva puntos dentro de los grupos y luego agrega un poco de ruido aleatorio.\n\n \nTenga en cuenta que la forma en que pasa parámetros para posicionar ajustes difiere según las estadísticas y las geoms. En lugar de incluir argumentos adicionales en ..., construyes un objeto de ajuste de posición y proporcionas argumentos adicionales en la llamada:\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(position = \"jitter\")\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(position = position_jitter(width = 0.05, height = 0.5))\n\n\n\n\n\n\n\n\n\n\nEsto es bastante detallado, por lo que geom_jitter() proporciona un atajo conveniente:\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_jitter(width = 0.05, height = 0.5)\n\nLos datos continuos normalmente no se superponen exactamente y, cuando lo hacen (debido a la alta densidad de datos), los ajustes menores, como la fluctuación, a menudo son insuficientes para solucionar el problema. Por este motivo, los ajustes de posición suelen ser más útiles para datos discretos.\n\n13.7.1 Ejercicios\n\n¿Cuándo podrías usar position_nudge()? Lea la documentación.\nMuchos ajustes de posición sólo se pueden utilizar con unas pocas geoms. Por ejemplo, no puedes apilar diagramas de caja o barras de errores. ¿Por qué no? ¿Qué propiedades debe poseer una geom para ser apilable? ¿Qué propiedades debe poseer para ser esquivable?\n¿Por qué deberías usar geom_jitter() en lugar de geom_count()? ¿Cuáles son las ventajas y desventajas de cada técnica?\n¿Cuándo podrías utilizar un diagrama de áreas apiladas? ¿Cuáles son las ventajas y desventajas en comparación con un diagrama de líneas?",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Construya una gráfica capa por capa</span>"
    ]
  },
  {
    "objectID": "scales-guides.html",
    "href": "scales-guides.html",
    "title": "14  Escalas y guías",
    "section": "",
    "text": "14.1 Teoría de escalas y guías.\nLa caja de herramientas de escalas en Capítulo 10 a Capítulo 12 proporciona una guía extensa sobre cómo trabajar con escalas, enfocándose en resolver problemas comunes de visualización de datos. Los objetivos prácticos de la caja de herramientas significan que los temas se introducen cuando son más relevantes: por ejemplo, las transformaciones de escala se analizan en relación con las escalas de posición continua (Sección 10.1.7) porque esa es la situación más común en la que es posible que desee transformar una escala. Sin embargo, debido a que ggplot2 tiene como objetivo proporcionar una gramática de gráficos, no hay nada que le impida transformar otros tipos de escalas (consulte Sección 14.6). Este capítulo tiene como objetivo ilustrar estos conceptos: discutiremos la teoría que sustenta las escalas y guías, y daremos ejemplos que muestran cómo los conceptos que hemos discutido específicamente para las escalas de posición o color también se aplican en otros lugares.\nFormalmente, cada escala es una función desde una región en el espacio de datos (el dominio de la escala) hasta una región en el espacio estético (el rango de la escala). El eje o leyenda es la función inversa, conocida como guía: le permite convertir propiedades visuales nuevamente en datos. Puede que le sorprenda que los ejes y las leyendas sean el mismo tipo de cosas, pero si bien se ven muy diferentes, tienen el mismo propósito: permitirle leer las observaciones de la gráfica y mapearlas a sus valores originales. Los puntos en común entre los dos se ilustran a continuación:\nComponentes comunes de ejes y leyendas.\nSin embargo, las leyendas son más complicadas que los ejes y, en consecuencia, hay una serie de temas específicos de las leyendas:",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Escalas y guías</span>"
    ]
  },
  {
    "objectID": "scales-guides.html#sec-scales-guides-theory",
    "href": "scales-guides.html#sec-scales-guides-theory",
    "title": "14  Escalas y guías",
    "section": "",
    "text": "Nombre del argumento\nEje\nLeyenda\n\n\n\nname\nEtiqueta\nTítulo\n\n\nbreaks\nMarcas y líneas de cuadrícula\nEntrada\n\n\nlabels\nEtiqueta de marca\nEtiqueta de entrada\n\n\n\n\n\n\nUna leyenda puede mostrar múltiples estéticas (por ejemplo, color y forma), de múltiples capas (Sección 14.7.1), y el símbolo que se muestra en una leyenda varía según la geom utilizada en la capa (?sec-legend -glifo)\nLos ejes siempre aparecen en el mismo lugar. Las leyendas pueden aparecer en diferentes lugares, por lo que necesitas alguna forma global de posicionarlas.\nLas leyendas tienen más detalles que se pueden modificar: ¿deberían mostrarse vertical u horizontalmente? ¿Cuántas columnas? ¿Qué tamaño deben tener las llaves? Esto se comenta en (Sección 14.5)\n\n\n14.1.1 Especificación de escala\nUna propiedad importante de ggplot2 es el principio de que cada estética de su gráfica está asociada exactamente con una escala. Por ejemplo, cuando escribes esto\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(aes(colour = class))\n\nggplot2 agrega una escala predeterminada para cada estética utilizada en la gráfica:\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(aes(colour = class)) +\n  scale_x_continuous() + \n  scale_y_continuous() + \n  scale_colour_discrete()\n\nLa elección de la escala predeterminada depende de la estética y del tipo de variable. En este ejemplo, hwy es una variable continua asignada a la estética y, por lo que la escala predeterminada es scale_y_continuous(); de manera similar, class es discreta, por lo que cuando se asigna a la estética del color, la escala predeterminada se convierte en scale_colour_discrete(). Especificar estos valores predeterminados sería tedioso, por lo que ggplot2 lo hace por usted. Pero si desea anular los valores predeterminados, deberá agregar la escala usted mismo, de esta manera: \n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(aes(colour = class)) + \n  scale_x_continuous(name = \"Una etiqueta del eje x realmente impresionante.\") +\n  scale_y_continuous(name = \"Una etiqueta del eje Y increíblemente genial.\")\n\nEn la práctica, normalmente usarías labs() para esto, lo cual se analiza en Sección 8.1, pero conceptualmente es útil comprender que las etiquetas de los ejes y los títulos de las leyendas son ejemplos de nombres de escala: consulta Sección 14.2.\nEl uso de + para “agregar” escalas a una gráfica es un poco engañoso porque si proporcionas dos escalas para la misma estética, la última escala tiene prioridad. En otras palabras, cuando haces + en una escala, en realidad no la agregas al gráfico, sino que anulas la escala existente. Esto significa que las dos especificaciones siguientes son equivalentes: \nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  scale_x_continuous(name = \"Etiqueta 1\") +\n  scale_x_continuous(name = \"Etiqueta 2\")\n#&gt; Scale for x is already present.\n#&gt; Adding another scale for x, which will replace the existing scale.\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  scale_x_continuous(name = \"Etiqueta 2\")\n\n\n\nTenga en cuenta el mensaje cuando agrega varias escalas para la misma estética, lo que hace que sea más difícil sobrescribir accidentalmente una escala existente. Si ve esto en su propio código, debe asegurarse de agregar solo una escala a cada estética.\nSi está haciendo pequeños ajustes a las escalas, puede continuar usando las escalas predeterminadas, proporcionando algunos argumentos adicionales. Si desea realizar cambios más radicales, anulará las escalas predeterminadas con alternativas:\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(aes(colour = class)) +\n  scale_x_sqrt() + \n  scale_colour_brewer()\n\nAquí scale_x_sqrt() cambia la escala para la escala del eje x, y scale_colour_brewer() hace lo mismo para la escala de color.\n\n14.1.2 Esquema de nombres\nTodas las funciones de báscula destinadas a los usuarios siguen un esquema de nomenclatura común. Probablemente ya hayas descubierto el esquema, pero para ser concretos, se compone de tres piezas separadas por “_”:\n\nscale\nEl nombre de la estética primaria (e.g., colour, shape o x)\nEl nombre de la escala (e.g., continuous, discrete, brewer).\n\nLa estructura de nombres suele ser útil, pero a veces puede resultar ambigua. Por ejemplo, queda inmediatamente claro que las funciones scale_x_*() se aplican a la estética x, pero se necesita un poco más de reflexión para reconocer que también gobiernan el comportamiento de otras estéticas que describen una posición horizontal (por ejemplo, la función xmin, xmax y xend estética). De manera similar, si bien el nombre scale_colour_continuous() se refiere claramente a la escala de colores asociada con variables continuas, es menos obvio que scale_colour_distiller() es simplemente un método diferente para crear escalas de colores para variables continuas.\n\n14.1.3 Tipos de escalas fundamentales\nEs útil señalar que internamente todas las funciones de escala en ggplot2 pertenecen a uno de tres tipos fundamentales; escalas continuas, escalas discretas y escalas agrupadas. Cada tipo fundamental es manejado por una de las tres funciones constructoras de escala; continuous_scale(), discrete_scale() y binned_scale(). Aunque nunca debería necesitar llamar a estas funciones constructoras, proporcionan la estructura organizativa para las escalas y es útil conocerlas.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Escalas y guías</span>"
    ]
  },
  {
    "objectID": "scales-guides.html#sec-scale-names",
    "href": "scales-guides.html#sec-scale-names",
    "title": "14  Escalas y guías",
    "section": "\n14.2 Nombres de escala",
    "text": "14.2 Nombres de escala\nAmplíar la discusión sobre labs() en Sección 8.1.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Escalas y guías</span>"
    ]
  },
  {
    "objectID": "scales-guides.html#sec-scale-breaks",
    "href": "scales-guides.html#sec-scale-breaks",
    "title": "14  Escalas y guías",
    "section": "\n14.3 Saltos de escala",
    "text": "14.3 Saltos de escala\nDiscusión sobre lo que unifica el concepto de breaks en escalas continuas, discretas y agrupadas: son valores de datos específicos en los que la guía necesita mostrar algo. Incluya detalles adicionales sobre las funciones de descanso.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Escalas y guías</span>"
    ]
  },
  {
    "objectID": "scales-guides.html#sec-oob",
    "href": "scales-guides.html#sec-oob",
    "title": "14  Escalas y guías",
    "section": "\n14.4 Límites de escala",
    "text": "14.4 Límites de escala\nSección 14.1 introdujo el concepto de que una escala define un mapeo desde el espacio de datos al espacio estético. Los límites de escala son una extensión de esta idea: dictan la región del espacio de datos sobre la cual se define el mapeo. A nivel teórico esta región se define de forma diferente según el tipo de escala fundamental. Para escalas continuas y agrupadas, el espacio de datos es inherentemente continuo y unidimensional, por lo que los límites se pueden especificar mediante dos puntos finales. Sin embargo, para las escalas discretas, el espacio de datos no está estructurado y consta únicamente de un conjunto de categorías: como tal, los límites de una escala discreta sólo pueden especificarse enumerando el conjunto de categorías sobre las cuales se define el mapeo.\nLos capítulos de la caja de herramientas describen los objetivos prácticos comunes para especificar los límites: para escalas de posición, los límites se utilizan para establecer los puntos finales del eje, por ejemplo. Esto lleva naturalmente a la pregunta de qué debería hacer ggplot2 si el conjunto de datos contiene valores “fuera de límites” que quedan fuera de los límites.\n\n\nEl comportamiento predeterminado en ggplot2 es convertir valores fuera de límites a NA, la lógica para esto es que si un valor de datos no es parte de la región asignada, debe tratarse como faltante. En ocasiones, esto puede provocar un comportamiento inesperado, como se ilustra en Sección 10.1.2. Puede anular este valor predeterminado configurando el argumento oob de la escala, una función que se aplica a todas las observaciones fuera de los límites de la escala. El valor predeterminado es scales::oob_censor() que reemplaza cualquier valor fuera de los límites con NA. Otra opción es scales::oob_squish() que comprime todos los valores en el rango. A continuación se muestra un ejemplo que utiliza una escala de relleno:\ndf &lt;- data.frame(x = 1:6, y = 8:13)\nbase &lt;- ggplot(df, aes(x, y)) + \n  geom_col(aes(fill = x)) +                    # bar chart\n  geom_vline(xintercept = 3.5, colour = \"red\") # for visual clarity only\n\nbase\nbase + scale_fill_gradient(limits = c(1, 3))\nbase + scale_fill_gradient(limits = c(1, 3), oob = scales::squish)\n\n\n\n\n\n\n\n\n\n\n\n\n\nA la izquierda se muestran los colores de relleno predeterminados, que van del azul oscuro al azul claro. En el panel central, los límites de escala para la estética del relleno se reducen de modo que los valores de las tres barras más a la derecha se reemplazan con NA y se asignan a un tono gris. En algunos casos, este es el comportamiento deseado, pero a menudo no lo es: el panel derecho soluciona este problema modificando la función oob de forma adecuada.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Escalas y guías</span>"
    ]
  },
  {
    "objectID": "scales-guides.html#sec-scale-guide",
    "href": "scales-guides.html#sec-scale-guide",
    "title": "14  Escalas y guías",
    "section": "\n14.5 Guías de escala",
    "text": "14.5 Guías de escala\nLas guías de escala son más complejas que los nombres de escala: donde el argumento name (y labs() ) toma texto como entrada, el argumento guide (y guides()) requieren un objeto guía creado por un ** función de guía** como guide_colourbar() y guide_legend(). Estos argumentos para estas funciones ofrecen un control preciso adicional sobre la guía.\nLa siguiente tabla resume las funciones de guía predeterminadas asociadas con diferentes tipos de báscula:\n\n\n\n\n\n\nTipo de escala\nTipo de guía predeterminado\n\n\n\nescalas continuas para estética de color/relleno\nbarra de colores\n\n\nescalas agrupadas para estética de color/relleno\npasos de color\n\n\nescalas de posición (continua, agrupada y discreta)\nejes\n\n\nescalas discretas (excepto escalas de posición)\nleyenda\n\n\nescalas agrupadas (excepto escalas de posición/color/relleno)\ncontenedores\n\n\n\nCada uno de estos tipos de guía apareció anteriormente en la caja de herramientas:\n\n\nguide_colourbar() se discute en Sección 11.2.5\n\n\nguide_coloursteps() se discute en Sección 11.4.2\n\n\nguide_axis() se discute en Sección 10.3.2\n\n\nguide_legend() se discute en Sección 11.3.6\n\n\nguide_bins() se discute en Sección 12.1.2\n\n\nAdemás de la funcionalidad analizada en esas secciones, las funciones de la guía tienen muchos argumentos que son equivalentes a la configuración del tema, como el color del texto, el tamaño, la fuente, etc., pero solo se aplican a una única guía. Para obtener información sobre esas configuraciones, consulte ?sec-polish.\nCosas nuevas: muestra ejemplos en los que se utiliza algo distinto a la guía predeterminada…",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Escalas y guías</span>"
    ]
  },
  {
    "objectID": "scales-guides.html#sec-scale-transformation-extras",
    "href": "scales-guides.html#sec-scale-transformation-extras",
    "title": "14  Escalas y guías",
    "section": "\n14.6 Transformación de escala",
    "text": "14.6 Transformación de escala\nEl uso más común de las transformaciones de escala es ajustar una escala de posición continua, como se explica en Sección 10.1.7. Sin embargo, a veces pueden resultar útiles cuando se aplican a otras estéticas. A menudo esto es puramente una cuestión de énfasis visual. A continuación se muestra un ejemplo de esto para el gráfico de densidad de Old Faithful. La escala mapeada linealmente a la izquierda hace que sea fácil ver los picos de la distribución, mientras que la representación transformada a la derecha hace que sea más fácil ver las regiones de densidad no despreciable alrededor de esos picos: \nbase &lt;- ggplot(faithfuld, aes(waiting, eruptions)) + \n  geom_raster(aes(fill = density)) + \n  scale_x_continuous(NULL, NULL, expand = c(0, 0)) +\n  scale_y_continuous(NULL, NULL, expand = c(0, 0))\n  \nbase\nbase + scale_fill_continuous(trans = \"sqrt\")\n\n\n\n\n\n\n\n\n\n\nTransformar la estética del tamaño también es posible:\ndf &lt;- data.frame(x = runif(20), y = runif(20), z = sample(20))\nbase &lt;- ggplot(df, aes(x, y, size = z)) + geom_point()\n\nbase \nbase + scale_size(trans = \"reverse\")\n\n\n\n\n\n\n\n\n\n\nEn el gráfico de la izquierda, el valor z se interpreta naturalmente como un “peso”: si cada punto corresponde a un grupo, el valor z podría ser el tamaño del grupo. En el gráfico de la derecha, la escala de tamaño se invierte y z se interpreta de forma más natural como una medida de “distancia”: las entidades distantes se escalan para que parezcan más pequeñas en el gráfico.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Escalas y guías</span>"
    ]
  },
  {
    "objectID": "scales-guides.html#sec-legend-merge-split",
    "href": "scales-guides.html#sec-legend-merge-split",
    "title": "14  Escalas y guías",
    "section": "\n14.7 Leyenda fusionándose y dividiéndose",
    "text": "14.7 Leyenda fusionándose y dividiéndose\nSiempre existe una correspondencia uno a uno entre las escalas de posición y los ejes. Pero la conexión entre las escalas sin posición y la leyenda es más compleja: una leyenda puede necesitar dibujar símbolos de múltiples capas (“fusión”), o una estética puede necesitar múltiples leyendas (“división”).\n\n14.7.1 Fusionando leyendas\n\nLa fusión de leyendas ocurre con bastante frecuencia cuando se usa ggplot2. Por ejemplo, si ha asignado color tanto a puntos como a líneas, las claves mostrarán tanto los puntos como las líneas. Si has asignado el color de relleno, obtendrás un rectángulo. Tenga en cuenta la forma en que varía la leyenda en los gráficos siguientes:\n\n\n\n\n\n\n\n\n\n\n\n\n\nDe forma predeterminada, una capa solo aparecerá si la estética correspondiente se asigna a una variable con aes(). Puede anular si una capa aparece o no en la leyenda con show.legend: FALSE para evitar que una capa aparezca en la leyenda; TRUE lo obliga a aparecer cuando de otro modo no lo haría. Usar TRUE puede ser útil junto con el siguiente truco para resaltar los puntos:\nggplot(toy, aes(up, up)) + \n  geom_point(size = 4, colour = \"grey20\") +\n  geom_point(aes(colour = txt), size = 2) \n\nggplot(toy, aes(up, up)) + \n  geom_point(size = 4, colour = \"grey20\", show.legend = TRUE) +\n  geom_point(aes(colour = txt), size = 2) \n\n\n\n\n\n\n\n\n\n\nggplot2 intenta utilizar la menor cantidad de leyendas para transmitir con precisión la estética utilizada en la gráfica. Lo hace combinando leyendas donde la misma variable se asigna a diferentes estéticas. La siguiente figura muestra cómo funciona esto para puntos: si tanto el color como la forma se asignan a la misma variable, entonces solo es necesaria una única leyenda. \nbase &lt;- ggplot(toy, aes(const, up)) +\n  scale_x_continuous(NULL, breaks = NULL)\nbase + geom_point(aes(colour = txt))\nbase + geom_point(aes(shape = txt))\nbase + geom_point(aes(shape = txt, colour = txt))\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara que las leyendas se fusionen, deben tener el mismo “nombre”. Entonces, si cambia el nombre de una de las escalas, deberá cambiarlo para todas ellas. Una forma de hacer esto es usando la función auxiliar labs():\nbase &lt;- ggplot(toy, aes(const, up)) + \n  geom_point(aes(shape = txt, colour = txt)) + \n  scale_x_continuous(NULL, breaks = NULL)\n\nbase\nbase + labs(shape = \"Split legend\")\nbase + labs(shape = \"Merged legend\", colour = \"Merged legend\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n14.7.2 Dividiendo leyendas\nDividir una leyenda es una tarea de visualización de datos mucho menos común. En general, no es recomendable asignar una estética (por ejemplo, color) a múltiples variables y, por lo tanto, de forma predeterminada, ggplot2 no le permite “dividir” la estética del color en múltiples escalas con leyendas separadas. Sin embargo, existen excepciones a esta regla general y es posible anular este comportamiento utilizando el paquete ggnewscale (Campitelli 2020). El comando ggnewscale::new_scale_colour() actúa como una instrucción para ggplot2 para inicializar una nueva escala de color: los comandos de escala y guía que aparecen encima del comando new_scale_colour() se aplicarán a la primera escala de color, y los comandos que aparecen A continuación se aplican a la segunda escala de colores.\nPara ilustrar esto, el gráfico de la izquierda usa geom_point() para mostrar un marcador grande para cada marca de vehículo en los datos de mpg, con una escala de color única que se asigna al año. A la derecha, una segunda capa geom_point() se superpone en el gráfico mediante pequeños marcadores: esta capa está asociada a una escala de colores diferente, que se utiliza para indicar si el vehículo tiene un motor de 4 cilindros.\nbase &lt;- ggplot(mpg, aes(displ, hwy)) + \n  geom_point(aes(colour = factor(year)), size = 5) + \n  scale_colour_brewer(\"year\", type = \"qual\", palette = 5) \n\nbase\nbase + \n  ggnewscale::new_scale_colour() + \n  geom_point(aes(colour = cyl == 4), size = 1, fill = NA) + \n  scale_colour_manual(\"4 cylinder\", values = c(\"grey60\", \"black\"))\n\n\n\n\n\n\n\n\n\n\nDetalles adicionales, incluidas funciones que se aplican a otros tipos de básculas, están disponibles en el sitio web del paquete, https://github.com/eliocamp/ggnewscale.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Escalas y guías</span>"
    ]
  },
  {
    "objectID": "scales-guides.html#sec-legend-glyph",
    "href": "scales-guides.html#sec-legend-glyph",
    "title": "14  Escalas y guías",
    "section": "\n14.8 Glifos clave de leyenda",
    "text": "14.8 Glifos clave de leyenda\nEn la mayoría de los casos, los glifos predeterminados que se muestran en la clave de leyenda serán apropiados para la capa y la estética. Los diagramas de líneas de diferentes colores aparecerán como líneas de diferentes colores en la leyenda, los diagramas de caja aparecerán como diagramas de caja pequeños en la leyenda, y así sucesivamente. Si necesita anular este comportamiento, el argumento key_glyph se puede utilizar para asociar una capa particular con un tipo diferente de glifo. Por ejemplo:\nbase &lt;- ggplot(economics, aes(date, psavert, color = \"savings\"))\n\nbase + geom_line()\nbase + geom_line(key_glyph = \"timeseries\")\n\n\n\n\n\n\n\n\n\n\nMás precisamente, cada geom está asociada con una función como draw_key_boxplot() o draw_key_path() que es responsable de dibujar la clave cuando se crea la leyenda. Puede pasar directamente la función de dibujo clave deseada: por ejemplo, base + geom_line(key_glyph = draw_key_timeseries) también produciría el gráfico que se muestra arriba a la derecha.\n\n\n\n\n\n\n\n\nCampitelli, Elio. 2020. ggnewscale: Multiple Fill and Colour Scales in ’ggplot2’. https://CRAN.R-project.org/package=ggnewscale.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Escalas y guías</span>"
    ]
  },
  {
    "objectID": "coord.html",
    "href": "coord.html",
    "title": "15  Sistemas coordinados",
    "section": "",
    "text": "15.1 Sistemas de coordenadas lineales\nLos sistemas de coordenadas tienen dos funciones principales:\nHay dos tipos de sistemas de coordenadas. Los sistemas de coordenadas lineales preservan la forma de las geoms:\nPor otro lado, los sistemas de coordenadas no lineales pueden cambiar las formas: una línea recta puede dejar de ser recta. Es posible que la distancia más cercana entre dos puntos ya no sea una línea recta.\nCada sistema de coordenadas se describe con más detalle a continuación.\nHay tres sistemas de coordenadas lineales: coord_cartesian(), coord_flip(), coord_fixed().",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Sistemas coordinados</span>"
    ]
  },
  {
    "objectID": "coord.html#sec-cartesian",
    "href": "coord.html#sec-cartesian",
    "title": "15  Sistemas coordinados",
    "section": "",
    "text": "15.1.1 Acercándose a una gráfica con coord_cartesian()\n\ncoord_cartesian() tiene argumentos xlim y ylim. Si recuerda el capítulo de las escalas, se preguntará por qué las necesitamos. ¿El argumento de los límites de la balanza no nos permite ya controlar lo que aparece en la gráfica? La diferencia clave es cómo funcionan los límites: al establecer límites de escala, cualquier dato fuera de los límites se desecha; pero al establecer los límites del sistema de coordenadas, todavía usamos todos los datos, pero solo mostramos una pequeña región del gráfico. Establecer los límites del sistema de coordenadas es como mirar el gráfico con una lupa. \nbase &lt;- ggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  geom_smooth()\n\n# Conjunto de datos completo\nbase\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n# Escalar a 4-6 descarta datos fuera de ese rango\nbase + scale_x_continuous(limits = c(4, 6))\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n#&gt; Warning: Removed 153 rows containing non-finite outside the scale range\n#&gt; (`stat_smooth()`).\n#&gt; Warning: Removed 153 rows containing missing values or values outside the scale range\n#&gt; (`geom_point()`).\n# Hacer zoom a 4--6 mantiene todos los datos pero solo muestra algunos de ellos\nbase + coord_cartesian(xlim = c(4, 6))\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n15.1.2 Voltear los ejes con coord_flip()\n\nLa mayoría de las estadísticas y geoms asumen que usted está interesado en los valores de y condicionados a los valores de x (por ejemplo, suave, resumen, diagrama de caja, línea): en la mayoría de los modelos estadísticos, se supone que los valores de x se miden sin errores. Si está interesado en x condicional a y (o simplemente desea rotar el gráfico 90 grados), puede usar coord_flip() para intercambiar los ejes x e y. Compare esto con simplemente intercambiar las variables asignadas a x e y: \nggplot(mpg, aes(displ, cty)) + \n  geom_point() + \n  geom_smooth()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n# El intercambio de cty y displ gira la gráfica 90 grados, pero la fluidez\n# se ajusta a los datos rotados.\nggplot(mpg, aes(cty, displ)) + \n  geom_point() + \n  geom_smooth()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n# coord_flip() ajusta la suavidad a los datos originales y luego gira\n# la salida\nggplot(mpg, aes(displ, cty)) + \n  geom_point() + \n  geom_smooth() + \n  coord_flip()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n15.1.3 Escalas iguales con coord_fixed()\n\ncoord_fixed() Fija la relación de longitud en los ejes x e y. El ratio predeterminado garantiza que los ejes x e y tengan escalas iguales: es decir, 1 cm a lo largo del eje x representa el mismo rango de datos que 1 cm a lo largo del eje y. La relación de aspecto también se establecerá para garantizar que el mapeo se mantenga independientemente de la forma del dispositivo de salida. Consulte la documentación de coord_fixed() para obtener más detalles.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Sistemas coordinados</span>"
    ]
  },
  {
    "objectID": "coord.html#sec-coord-non-linear",
    "href": "coord.html#sec-coord-non-linear",
    "title": "15  Sistemas coordinados",
    "section": "\n15.2 Sistemas de coordenadas no lineales",
    "text": "15.2 Sistemas de coordenadas no lineales\nA diferencia de las coordenadas lineales, las coordenadas no lineales pueden cambiar la forma de las geoms. Por ejemplo, en coordenadas polares un rectángulo se convierte en un arco; En una proyección cartográfica, el camino más corto entre dos puntos no es necesariamente una línea recta. El siguiente código muestra cómo se representan una línea y un rectángulo en algunos sistemas de coordenadas diferentes. \nrect &lt;- data.frame(x = 50, y = 50)\nline &lt;- data.frame(x = c(1, 200), y = c(100, 1))\nbase &lt;- ggplot(mapping = aes(x, y)) + \n  geom_tile(data = rect, aes(width = 50, height = 50)) + \n  geom_line(data = line) + \n  xlab(NULL) + ylab(NULL)\nbase\nbase + coord_polar(\"x\")\nbase + coord_polar(\"y\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nbase + coord_flip()\nbase + coord_trans(y = \"log10\")\nbase + coord_fixed()\n\n\n\n\n\n\n\n\n\n\n\n\n\nLa transformación se produce en dos pasos. En primer lugar, la parametrización de cada geom se cambia para que se base puramente en la ubicación, en lugar de en la ubicación y las dimensiones. Por ejemplo, una barra se puede representar como una posición x (una ubicación), una altura y un ancho (dos dimensiones). Interpretar la altura y el ancho en un sistema de coordenadas no cartesiano es difícil porque es posible que un rectángulo ya no tenga una altura y un ancho constantes, por lo que lo convertimos a una representación puramente basada en la ubicación, un polígono definido por las cuatro esquinas. Esto convierte efectivamente todas las geoms en una combinación de puntos, líneas y polígonos. \nUna vez que todas las geoms tengan una representación basada en la ubicación, el siguiente paso es transformar cada ubicación en el nuevo sistema de coordenadas. Es fácil transformar puntos, porque un punto sigue siendo un punto sin importar en qué sistema de coordenadas se encuentre. Las líneas y los polígonos son más difíciles, porque es posible que una línea recta ya no lo sea en el nuevo sistema de coordenadas. Para que el problema sea manejable, asumimos que todas las transformaciones de coordenadas son suaves, en el sentido de que todas las líneas muy cortas seguirán siendo líneas rectas muy cortas en el nuevo sistema de coordenadas. Con esta suposición en la mano, podemos transformar líneas y polígonos dividiéndolos en muchos segmentos de línea pequeños y transformando cada segmento. Este proceso se llama masticar y se ilustra a continuación: \n\n\nEmpezamos con una línea parametrizada por sus dos extremos:\n\ndf &lt;- data.frame(r = c(0, 1), theta = c(0, 3 / 2 * pi))\nggplot(df, aes(r, theta)) + \n  geom_line() + \n  geom_point(size = 2, colour = \"red\")\n\n\n\n\n\n\n\n\n\nLo dividimos en varios segmentos de línea, cada uno con dos puntos finales.\n\ninterp &lt;- function(rng, n) {\n  seq(rng[1], rng[2], length = n)\n}\nmunched &lt;- data.frame(\n  r = interp(df$r, 15),\n  theta = interp(df$theta, 15)\n)\n\nggplot(munched, aes(r, theta)) + \n  geom_line() + \n  geom_point(size = 2, colour = \"red\")\n\n\n\n\n\n\n\n\n\nTransformamos las ubicaciones de cada pieza:\n\ntransformed &lt;- transform(munched,\n  x = r * sin(theta),\n  y = r * cos(theta)\n)\n\nggplot(transformed, aes(x, y)) + \n  geom_path() + \n  geom_point(size = 2, colour = \"red\") + \n  coord_fixed()\n\n\n\n\n\n\n\n\n\nInternamente, ggplot2 usa muchos más segmentos para que el resultado parezca fluido.\n\n15.2.1 Transformaciones con coord_trans()\n\nAl igual que los límites, también podemos transformar los datos en dos lugares: a nivel de escala o a nivel del sistema de coordenadas. coord_trans() tiene argumentos x e y que deberían ser cadenas que nombren el transformador o los objetos del transformador (ver Capítulo 10). La transformación a nivel de escala ocurre antes de que se calculen las estadísticas y no cambia la forma de la geom. La transformación a nivel del sistema de coordenadas ocurre después de que se han calculado las estadísticas y afecta la forma de la geom. Usar ambos juntos nos permite modelar los datos en una escala transformada y luego transformarlos para su interpretación: un patrón común en el análisis. \n# El modelo lineal en la escala original no se ajusta bien\nbase &lt;- ggplot(diamonds, aes(carat, price)) + \n  stat_bin2d() + \n  geom_smooth(method = \"lm\") + \n  xlab(NULL) + \n  ylab(NULL) + \n  theme(legend.position = \"none\")\nbase\n\n# Mejor ajuste en escala logarítmica, pero más difícil de interpretar\nbase +\n  scale_x_log10() + \n  scale_y_log10()\n\n# Ajustar a escala logarítmica y luego volver a transformar al original.\n# Destaca la falta de diamantes caros con grandes quilates\npow10 &lt;- scales::exp_trans(10)\nbase +\n  scale_x_log10() + \n  scale_y_log10() + \n  coord_trans(x = pow10, y = pow10)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n15.2.2 Coordenadas polares con coord_polar()\n\nEl uso de coordenadas polares da lugar a gráficos circulares y rosas de los vientos (de geomas de barras) y gráficos de radar (de geomas de líneas). Las coordenadas polares se utilizan a menudo para datos circulares, particularmente tiempo o dirección, pero las propiedades de percepción no son buenas porque el ángulo es más difícil de percibir para radios pequeños que para radios grandes. El argumento theta determina qué variable de posición se asigna al ángulo (por defecto, x) y cuál al radio.\nEl siguiente código muestra cómo podemos convertir una barra en un gráfico circular o en un gráfico de diana cambiando el sistema de coordenadas. La documentación incluye otros ejemplos. \nbase &lt;- ggplot(mtcars, aes(factor(1), fill = factor(cyl))) +\n  geom_bar(width = 1) + \n  theme(legend.position = \"none\") + \n  scale_x_discrete(NULL, expand = c(0, 0)) +\n  scale_y_continuous(NULL, expand = c(0, 0))\n\n# diagrama de barras apiladas\nbase\n\n# Gráfico circular\nbase + coord_polar(theta = \"y\")\n\n# El gráfico de diana\nbase + coord_polar()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n15.2.3 Proyecciones cartográficas con coord_map()\n\nLos mapas son intrínsecamente visualizaciones de datos esféricos. Simplemente trazar longitudes y latitudes sin procesar es engañoso, por lo que debemos proyectar los datos. Hay dos formas de hacer esto con ggplot2: \n\n\ncoord_quickmap() es una aproximación rápida y sucia que establece la relación de aspecto para garantizar que 1 m de latitud y 1 m de longitud estén a la misma distancia en el medio de la gráfica. Este es un punto de partida razonable para regiones más pequeñas y es muy rápido.\n# Preparar un mapa de Nueva Zelanda\nnzmap &lt;- ggplot(map_data(\"nz\"), aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\") +\n  xlab(NULL) + ylab(NULL)\n\n# Trazarlo en coordenadas cartesianas\nnzmap\n# Con la aproximación de la relación de aspecto\nnzmap + coord_quickmap()\n\n\n\n\n\n\n\n\n\n\n\n\ncoord_map() utiliza el paquete mapproj, https://cran.r-project.org/package=mapproj para hacer una proyección cartográfica formal. Toma los mismos argumentos que mapproj::mapproject() para controlar la proyección. Es mucho más lento que coord_quickmap() porque debe masticar los datos y transformar cada pieza.\nworld &lt;- map_data(\"world\")\nworldmap &lt;- ggplot(world, aes(long, lat, group = group)) +\n  geom_path() +\n  scale_y_continuous(NULL, breaks = (-2:3) * 30, labels = NULL) +\n  scale_x_continuous(NULL, breaks = (-4:4) * 45, labels = NULL)\n\nworldmap + coord_map()\n# Algunas proyecciones más locas\nworldmap + coord_map(\"ortho\")\nworldmap + coord_map(\"stereographic\")",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Sistemas coordinados</span>"
    ]
  },
  {
    "objectID": "facet.html",
    "href": "facet.html",
    "title": "16  Facetado",
    "section": "",
    "text": "16.1 Facetado agrupado\nLa primera vez que encontró facetado fue en Sección 2.5. El facetado genera pequeños múltiplos, cada uno de los cuales muestra un subconjunto diferente de datos. Los múltiplos pequeños son una herramienta poderosa para el análisis exploratorio de datos: puede comparar rápidamente patrones en diferentes partes de los datos y ver si son iguales o diferentes. Esta sección discutirá cómo puede ajustar las facetas, particularmente la forma en que interactúan con las escalas de posición.\nHay tres tipos de facetado:\nLas diferencias entre facet_wrap() y facet_grid() se ilustran en la siguiente figura.\nLos gráficos facetados tienen la capacidad de llenar una gran cantidad de espacio, por lo que para este capítulo usaremos un subconjunto del conjunto de datos de mpg que tiene una cantidad manejable de niveles: tres cilindros (4, 6, 8), dos tipos de tren motriz ( 4 y f), y seis clases.\nfacet_wrap() crea una cinta larga de paneles (generada por cualquier número de variables) y la envuelve en 2d. Esto es útil si tiene una única variable con muchos niveles y desea organizar los gráficos de una manera más eficiente en cuanto a espacio.\nPuede controlar cómo se envuelve la cinta en una cuadrícula con ncol, nrow, as.table y dir. ncol y nrow controlan cuántas columnas y filas (solo necesita configurar una). as.table controla si las facetas se presentan como una tabla (TRUE), con los valores más altos en la parte inferior derecha, o como un gráfico (FALSE), con los valores más altos en la parte superior derecha. dir controla la dirección de ajuste: horizontal o vertical.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facetado</span>"
    ]
  },
  {
    "objectID": "facet.html#sec-facet-wrap",
    "href": "facet.html#sec-facet-wrap",
    "title": "16  Facetado",
    "section": "",
    "text": "base &lt;- ggplot(mpg2, aes(displ, hwy)) + \n  geom_blank() + \n  xlab(NULL) + \n  ylab(NULL)\n\nbase + facet_wrap(~class, ncol = 3)\nbase + facet_wrap(~class, ncol = 3, as.table = FALSE)\n\nbase + facet_wrap(~class, nrow = 3)\nbase + facet_wrap(~class, nrow = 3, dir = \"v\")",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facetado</span>"
    ]
  },
  {
    "objectID": "facet.html#facetado-de-cuadrícula",
    "href": "facet.html#facetado-de-cuadrícula",
    "title": "16  Facetado",
    "section": "\n16.2 Facetado de cuadrícula",
    "text": "16.2 Facetado de cuadrícula\nfacet_grid() presenta gráficos en una cuadrícula 2D, según lo definido por una fórmula: \n\n\n. ~ a distribuye los valores de a entre las columnas. Esta dirección facilita las comparaciones de la posición y, porque las escalas verticales están alineadas.\n\nbase + facet_grid(. ~ cyl)\n\n\n\n\n\n\n\n\n\nb ~ . distribuye los valores de b por las filas. Esta dirección facilita la comparación de la posición x porque las escalas horizontales están alineadas. Esto lo hace particularmente útil para comparar distribuciones.\n\nbase + facet_grid(drv ~ .)\n\n\n\n\n\n\n\n\n\nb ~ a distribuye a en las columnas y b en las filas. Por lo general, querrás colocar la variable con la mayor cantidad de niveles en las columnas para aprovechar la relación de aspecto de tu pantalla.\n\nbase + facet_grid(drv ~ cyl)\n\n\n\n\n\n\n\n\n\nPuede utilizar varias variables en las filas o columnas, “sumándolas”, p. a + b ~ c + d. Las variables que aparecen juntas en las filas o columnas están anidadas en el sentido de que solo las combinaciones que aparecen en los datos aparecerán en el gráfico. Las variables que se especifican en filas y columnas se cruzarán: se mostrarán todas las combinaciones, incluidas aquellas que no aparecieron en el conjunto de datos original: esto puede dar como resultado paneles vacíos.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facetado</span>"
    ]
  },
  {
    "objectID": "facet.html#sec-controlling-scales",
    "href": "facet.html#sec-controlling-scales",
    "title": "16  Facetado",
    "section": "\n16.3 Control de escalas",
    "text": "16.3 Control de escalas\nTanto para facet_wrap() como para facet_grid() puedes controlar si las escalas de posición son las mismas en todos los paneles (fijas) o si se les permite variar entre paneles (gratis) con el parámetro scales: \n\n\nscales = \"fixed\": las escalas x e y están fijadas en todos los paneles.\n\nscales = \"free_x\": la escala x es libre y la escala y es fija.\n\nscales = \"free_y\": la escala y es libre y la escala x es fija.\n\nscales = \"free\": las escalas x e y varían según los paneles.\n\nfacet_grid() impone una restricción adicional a las escalas: todos los paneles de una columna deben tener la misma escala x y todos los paneles de una fila deben tener la misma escala y. Esto se debe a que cada columna comparte un eje x y cada fila comparte un eje y.\nLas escalas fijas facilitan la visualización de patrones entre paneles; Las escalas libres facilitan la visualización de patrones dentro de los paneles.\np &lt;- ggplot(mpg2, aes(cty, hwy)) + \n  geom_abline() +\n  geom_jitter(width = 0.1, height = 0.1)\n\np + facet_wrap(~cyl)\np + facet_wrap(~cyl, scales = \"free\")\n\n\n\n\n\n\n\n\n\n\nLas escalas libres también son útiles cuando queremos mostrar múltiples series de tiempo medidas en diferentes escalas. Para hacer esto, primero necesitamos cambiar de datos “anchos” a “largos”, apilando las variables separadas en una sola columna. A continuación se muestra un ejemplo de esto con la forma larga de los datos economics. \n\neconomics_long\n#&gt; # A tibble: 2,870 × 4\n#&gt;   date       variable value  value01\n#&gt;   &lt;date&gt;     &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 1967-07-01 pce       507. 0       \n#&gt; 2 1967-08-01 pce       510. 0.000265\n#&gt; 3 1967-09-01 pce       516. 0.000762\n#&gt; 4 1967-10-01 pce       512. 0.000471\n#&gt; 5 1967-11-01 pce       517. 0.000916\n#&gt; 6 1967-12-01 pce       525. 0.00157 \n#&gt; # ℹ 2,864 more rows\nggplot(economics_long, aes(date, value)) + \n  geom_line() + \n  facet_wrap(~variable, scales = \"free_y\", ncol = 1)\n\n\n\n\n\n\n\nfacet_grid() tiene un parámetro adicional llamado space, que toma los mismos valores que scales. Cuando el espacio está “free”, cada columna (o fila) tendrá un ancho (o alto) proporcional al rango de la escala para esa columna (o fila). Esto hace que la escala sea igual en todo el gráfico: 1 cm en cada panel se asigna al mismo rango de datos. (Esto es algo análogo a los límites del eje ‘cortado’ de la red). Por ejemplo, si el panel a tuviera un rango 2 y el panel b tuviera un rango 4, un tercio del espacio se le daría a a y dos tercios a b. . Esto es más útil para escalas categóricas, donde podemos asignar espacio proporcionalmente en función del número de niveles en cada faceta, como se ilustra a continuación.\n\nmpg2$model &lt;- reorder(mpg2$model, mpg2$cty)\nmpg2$manufacturer &lt;- reorder(mpg2$manufacturer, -mpg2$cty)\n\nggplot(mpg2, aes(cty, model)) + \n  geom_point() + \n  facet_grid(manufacturer ~ ., scales = \"free\", space = \"free\") +\n  theme(strip.text.y = element_text(angle = 0))",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facetado</span>"
    ]
  },
  {
    "objectID": "facet.html#sec-missing-faceting-columns",
    "href": "facet.html#sec-missing-faceting-columns",
    "title": "16  Facetado",
    "section": "\n16.4 Faltan variables de facetado",
    "text": "16.4 Faltan variables de facetado\nSi está utilizando facetado en un gráfico con múltiples conjuntos de datos, ¿qué sucede cuando a uno de esos conjuntos de datos le faltan las variables de facetado? Esta situación surge comúnmente cuando agrega información contextual que debería ser la misma en todos los paneles. Por ejemplo, imagine que tiene una visualización espacial de una enfermedad dividida por género. ¿Qué sucede cuando agrega una capa de mapa que no contiene la variable de género? Aquí ggplot hará lo que espera: mostrará el mapa en cada faceta: las variables de facetas faltantes se tratan como si tuvieran todos los valores. \nHe aquí un ejemplo sencillo. Observe cómo aparece el único punto rojo de df2 en ambos paneles.\n\ndf1 &lt;- data.frame(x = 1:3, y = 1:3, gender = c(\"f\", \"f\", \"m\"))\ndf2 &lt;- data.frame(x = 2, y = 2)\n\nggplot(df1, aes(x, y)) + \n  geom_point(data = df2, colour = \"red\", size = 2) + \n  geom_point() + \n  facet_wrap(~gender)\n\n\n\n\n\n\n\nEsta técnica es particularmente útil cuando agrega anotaciones para facilitar la comparación entre facetas, como se muestra en la siguiente sección.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facetado</span>"
    ]
  },
  {
    "objectID": "facet.html#sec-group-vs-facet",
    "href": "facet.html#sec-group-vs-facet",
    "title": "16  Facetado",
    "section": "\n16.5 Agrupación versus facetado",
    "text": "16.5 Agrupación versus facetado\nEl facetado es una alternativa al uso de la estética (como el color, la forma o el tamaño) para diferenciar grupos. Ambas técnicas tienen fortalezas y debilidades, basadas en las posiciones relativas de los subconjuntos. Con el facetado, cada grupo está bastante alejado en su propio panel y no hay superposición entre los grupos. Esto es bueno si los grupos se superponen mucho, pero hace que las pequeñas diferencias sean más difíciles de ver. Cuando se utiliza la estética para diferenciar grupos, los grupos están muy juntos y pueden superponerse, pero las pequeñas diferencias son más fáciles de ver.\n\ndf &lt;- data.frame(\n  x = rnorm(120, c(0, 2, 4)),\n  y = rnorm(120, c(1, 2, 1)),\n  z = letters[1:3]\n)\n\nggplot(df, aes(x, y)) + \n  geom_point(aes(colour = z))\n\n\n\n\n\n\n\n\nggplot(df, aes(x, y)) + \n  geom_point() + \n  facet_wrap(~z)\n\n\n\n\n\n\n\nLas comparaciones entre facetas a menudo se benefician de alguna anotación reflexiva. Por ejemplo, en este caso podríamos mostrar la media de cada grupo en cada panel. Para ello, agrupamos y resumimos los datos utilizando el paquete dplyr, que se trata en R para ciencia de datos en https://r4ds.had.co.nz. Tenga en cuenta que necesitamos dos variables “z”: una para las facetas y otra para los colores. \n\ndf_sum &lt;- df %&gt;% \n  group_by(z) %&gt;% \n  summarise(x = mean(x), y = mean(y)) %&gt;%\n  rename(z2 = z)\n\nggplot(df, aes(x, y)) + \n  geom_point() + \n  geom_point(data = df_sum, aes(colour = z2), size = 4) + \n  facet_wrap(~z)\n\n\n\n\n\n\n\nOtra técnica útil es poner todos los datos en el fondo de cada panel:\n\ndf2 &lt;- dplyr::select(df, -z)\n\nggplot(df, aes(x, y)) + \n  geom_point(data = df2, colour = \"grey70\") +\n  geom_point(aes(colour = z)) + \n  facet_wrap(~z)",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facetado</span>"
    ]
  },
  {
    "objectID": "facet.html#sec-continuous-variables",
    "href": "facet.html#sec-continuous-variables",
    "title": "16  Facetado",
    "section": "\n16.6 Variables continuas",
    "text": "16.6 Variables continuas\nPara facetar variables continuas, primero debe discretizarlas. ggplot2 proporciona tres funciones auxiliares para hacerlo: \n\nDivida los datos en n contenedores, cada uno de ellos de la misma longitud: cut_interval(x, n) \nDivida los datos en contenedores de ancho width: cut_width(x, width). \nDivida los datos en n contenedores, cada uno de los cuales contiene (aproximadamente) la misma cantidad de puntos: cut_number(x, n = 10). \n\nSe ilustran a continuación:\n# Contenedores de ancho 1\nmpg2$disp_w &lt;- cut_width(mpg2$displ, 1)\n# Seis contenedores de igual longitud\nmpg2$disp_i &lt;- cut_interval(mpg2$displ, 6)\n# Seis contenedores que contienen el mismo número de puntos\nmpg2$disp_n &lt;- cut_number(mpg2$displ, 6)\n\nplot &lt;- ggplot(mpg2, aes(cty, hwy)) +\n  geom_point() +\n  labs(x = NULL, y = NULL)\nplot + facet_wrap(~disp_w, nrow = 1)\nplot + facet_wrap(~disp_i, nrow = 1)\nplot + facet_wrap(~disp_n, nrow = 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta que la fórmula de facetado no evalúa funciones, por lo que primero debe crear una nueva variable que contenga los datos discretizados.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facetado</span>"
    ]
  },
  {
    "objectID": "facet.html#ejercicios",
    "href": "facet.html#ejercicios",
    "title": "16  Facetado",
    "section": "\n16.7 Ejercicios",
    "text": "16.7 Ejercicios\n\nDiamantes: muestra la distribución del precio condicionada a la talla y los quilates. Intente facetar por corte y agrupar por quilates. Intente facetar por quilates y agrupar por corte. ¿Cual prefieres?\nDiamantes: compara la relación entre precio y quilates de cada color. ¿Qué hace que sea difícil comparar los grupos? ¿Es mejor agrupar o facetar? Si utiliza facetado, ¿qué anotación podría agregar para que sea más fácil ver las diferencias entre los paneles?\n¿Por qué facet_wrap() generalmente es más útil que facet_grid()?\n\nRecrea la siguiente gráfica. Faceta mpg2 por clase, superponiendo una curva suave que se ajusta al conjunto de datos completo.\n\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Facetado</span>"
    ]
  },
  {
    "objectID": "themes.html",
    "href": "themes.html",
    "title": "17  Temas",
    "section": "",
    "text": "17.1 Introducción\nEn este capítulo aprenderá a utilizar el sistema de temas ggplot2, que le permite ejercer un control preciso sobre los elementos que no son datos de su gráfica. El sistema de temas no afecta la forma en que las geoms representan los datos ni cómo se transforman mediante las escalas. Los temas no cambian las propiedades de percepción de la gráfica, pero sí te ayudan a hacer que la gráfica sea estéticamente agradable o que coincida con una guía de estilo existente. Los temas te dan control sobre cosas como fuentes, ticks, franjas de paneles y fondos.\nEsta separación del control en partes de datos y partes que no son de datos es bastante diferente de los gráficos base y reticulares. En los gráficos base y reticular, la mayoría de las funciones toman una gran cantidad de argumentos que especifican la apariencia tanto de datos como de no datos, lo que hace que las funciones sean complicadas y difíciles de aprender. ggplot2 adopta un enfoque diferente: al crear el gráfico, usted determina cómo se muestran los datos, luego, después de haberlos creado, puede editar cada detalle de la representación, utilizando el sistema de temas.\nEl sistema de tematización se compone de cuatro componentes principales:\nPor ejemplo, imagina que has hecho el siguiente gráfico de tus datos.\nbase &lt;- ggplot(mpg, aes(cty, hwy, color = factor(cyl))) +\n  geom_jitter() + \n  geom_abline(colour = \"grey50\", size = 2)\n#&gt; Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#&gt; ℹ Please use `linewidth` instead.\nbase\nHa cumplido su propósito para usted: ha aprendido que cty y hwy están altamente correlacionados, ambos están estrechamente acoplados con cyl y que hwy siempre es mayor que cty (y la diferencia aumenta a medida que cty aumenta). Ahora quieres compartir la gráfica con otros, tal vez publicándola en un periódico. Eso requiere algunos cambios. Primero, debes asegurarte de que la gráfica pueda funcionar por sí sola mediante:\nAfortunadamente, ya sabes cómo hacerlo porque has leído Sección 8.1 y ?sec-scale-color:\nlabelled &lt;- base +\n  labs(\n    x = \"Kilometraje en ciudad/galón\",\n    y = \"Kilometraje en carretera/galón\",\n    colour = \"Cilindros\",\n    title = \"El kilometraje en carretera y en ciudad están altamente correlacionados\"\n  ) +\n  scale_colour_brewer(type = \"seq\", palette = \"Spectral\")\nlabelled\nA continuación, debes asegurarte de que la gráfica coincida con las pautas de estilo de tu revista:\nEn este capítulo, aprenderá cómo utilizar el sistema de temas para realizar esos cambios, como se muestra a continuación:\nstyled &lt;- labelled +\n  theme_bw() + \n  theme(\n    plot.title = element_text(face = \"bold\", size = 12),\n    legend.background = element_rect(\n      fill = \"white\", \n      linewidth = 4, \n      colour = \"white\"\n    ),\n    legend.justification = c(0, 1),\n    legend.position = c(0, 1),\n    axis.ticks = element_line(colour = \"grey70\", linewidth = 0.2),\n    panel.grid.major = element_line(colour = \"grey70\", linewidth = 0.2),\n    panel.grid.minor = element_blank()\n  )\n#&gt; Warning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2\n#&gt; 3.5.0.\n#&gt; ℹ Please use the `legend.position.inside` argument of `theme()` instead.\nstyled\nFinalmente, la revista quiere la figura en un archivo TIFF de 600 ppp. Aprenderá los detalles finos de ggsave() en ?sec-served.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Temas</span>"
    ]
  },
  {
    "objectID": "themes.html#introducción",
    "href": "themes.html#introducción",
    "title": "17  Temas",
    "section": "",
    "text": "Los elementos del tema especifican los elementos que no son datos que puedes controlar. Por ejemplo, el elemento plot.title controla la apariencia del título de la gráfica; axis.ticks.x, los ticks en el eje x; legend.key.height, la altura de las claves en la leyenda.\nCada elemento está asociado con una función del elemento, que describe las propiedades visuales del elemento. Por ejemplo, element_text() establece el tamaño de fuente, el color y el aspecto de elementos de texto como plot.title.\nLa función theme() que le permite anular los elementos predeterminados del tema llamando a funciones de elementos, como theme(plot.title = element_text(colour = \"red\")).\nTemas completos, como theme_grey(), configuran todos los elementos del tema con valores diseñados para trabajar juntos armoniosamente.\n\n\n\n\n\nMejora de los ejes y etiquetas de leyenda.\nAgregar un título para la gráfica.\nAjustar la escala de colores.\n\n\n\n\n\nEl fondo debe ser blanco, no gris pálido.\nLa leyenda debe colocarse dentro de la gráfica si hay espacio.\nLas líneas de división principales deben ser de color gris pálido y las líneas de división menores deben eliminarse.\nEl título de la gráfica debe ser texto en negrita de 12 puntos.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Temas</span>"
    ]
  },
  {
    "objectID": "themes.html#sec-themes",
    "href": "themes.html#sec-themes",
    "title": "17  Temas",
    "section": "\n17.2 Temas completos",
    "text": "17.2 Temas completos\nggplot2 viene con varios temas integrados. El más importante es theme_grey(), el tema característico de ggplot2 con un fondo gris claro y líneas de cuadrícula blancas. El tema está diseñado para presentar los datos y al mismo tiempo respaldar las comparaciones, siguiendo el consejo de (Tufte 2006; cervecero? 1994; Carr 2002, 1994; Carr y Sun 1999). Todavía podemos ver las líneas de la cuadrícula para ayudarnos a juzgar la posición (Cleveland 1993), pero tienen poco impacto visual y podemos “desconectarnos” fácilmente de ellas. El fondo gris le da a la gráfica un color tipográfico similar al del texto, asegurando que los gráficos encajen con el flujo de un documento sin saltar con un fondo blanco brillante. Finalmente, el fondo gris crea un campo continuo de color que asegura que la gráfica se perciba como una única entidad visual. \nHay otros siete temas integrados en ggplot2 1.1.0:\n\ntheme_bw(): una variación de theme_grey() que utiliza un fondo blanco y finas líneas de cuadrícula grises. \ntheme_linedraw(): un tema con sólo líneas negras de varios anchos sobre fondos blancos, que recuerda a un dibujo lineal. \ntheme_light(): similar a theme_linedraw() pero con líneas y ejes de color gris claro, para dirigir más atención hacia los datos. \ntheme_dark(): el primo oscuro de theme_light(), con tamaños de línea similares pero con un fondo oscuro. Útil para hacer resaltar líneas finas de colores. \ntheme_minimal(): un tema minimalista sin anotaciones de fondo. \ntheme_classic(): un tema de aspecto clásico, con líneas de eje x e y y sin líneas de cuadrícula. \ntheme_void(): un tema completamente vacío. \n\ndf &lt;- data.frame(x = 1:3, y = 1:3)\nbase &lt;- ggplot(df, aes(x, y)) + geom_point()\nbase + theme_grey() + ggtitle(\"theme_grey()\")\nbase + theme_bw() + ggtitle(\"theme_bw()\")\nbase + theme_linedraw() + ggtitle(\"theme_linedraw()\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nbase + theme_light() + ggtitle(\"theme_light()\")\nbase + theme_dark() + ggtitle(\"theme_dark()\")\nbase + theme_minimal()  + ggtitle(\"theme_minimal()\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nbase + theme_classic() + ggtitle(\"theme_classic()\")\nbase + theme_void() + ggtitle(\"theme_void()\")\n\n\n\n\n\n\n\n\n\n\nTodos los temas tienen un parámetro base_size que controla el tamaño de fuente base. El tamaño de fuente base es el tamaño que utilizan los títulos de los ejes: el título de la gráfica suele ser más grande (1,2x) y las etiquetas de marca y tira son más pequeñas (0,8x). Si desea controlar estos tamaños por separado, deberá modificar los elementos individuales como se describe a continuación.\nAdemás de aplicar temas en un argumento a la vez, puedes cambiar el tema predeterminado con theme_set(). Por ejemplo, si realmente odias el fondo gris predeterminado, ejecuta theme_set(theme_bw()) para usar un fondo blanco para todos los gráficos. \nNo estás limitado a los temas integrados en ggplot2. Otros paquetes, como ggthemes de Jeffrey Arnold, añaden aún más. Estos son algunos de mis favoritos de ggthemes: \nlibrary(ggthemes)\nbase + theme_tufte() + ggtitle(\"theme_tufte()\")\nbase + theme_solarized() + ggtitle(\"theme_solarized()\")\nbase + theme_excel() + ggtitle(\"theme_excel()\") # ;)\n\n\n\n\n\n\n\n\n\n\n\n\n\nLos temas completos son un excelente lugar para comenzar, pero no te dan mucho control. Para modificar elementos individuales, necesita usar theme() para anular la configuración predeterminada para un elemento con una función de elemento.\n\n17.2.1 Ejercicios\n\nPruebe todos los temas en ggthemes. ¿Cuál te gusta más?\n¿Qué aspectos del tema predeterminado te gustan? ¿Qué no te gusta?\n¿Qué cambiarías?\nMira los argumentos de tu revista científica favorita. ¿A qué tema se parecen más? ¿Cuáles son las principales diferencias?",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Temas</span>"
    ]
  },
  {
    "objectID": "themes.html#modificar-componentes-del-tema",
    "href": "themes.html#modificar-componentes-del-tema",
    "title": "17  Temas",
    "section": "\n17.3 Modificar componentes del tema",
    "text": "17.3 Modificar componentes del tema\nPara modificar un componente de tema individual, utiliza un código como plot + theme(element.name = element_function()). En esta sección aprenderá sobre las funciones básicas de los elementos y luego, en la siguiente sección, verá todos los elementos que puede modificar. \nHay cuatro tipos básicos de funciones de elementos integradas: texto, líneas, rectángulos y espacios en blanco. Cada elemento función tiene un conjunto de parámetros que controlan la apariencia:\n\n\nelement_text() Dibuja etiquetas y títulos. Puede controlar la fuente family, face, colour, size (en puntos), hjust, vjust, angle (en grados) y lineheight (como proporción de fontcase). Se pueden encontrar más detalles sobre los parámetros en vignette(\"ggplot2-specs\"). Configurar la fuente es particularmente desafiante. \nbase_t &lt;- base + labs(title = \"Este es un ggplot\") + xlab(NULL) + ylab(NULL)\nbase_t + theme(plot.title = element_text(size = 16))\nbase_t + theme(plot.title = element_text(face = \"bold\", colour = \"red\"))\nbase_t + theme(plot.title = element_text(hjust = 1))\n\n\n\n\n\n\n\n\n\n\n\n\n\nPuede controlar los márgenes alrededor del texto con el argumento margin y la función margin(). margin() tiene cuatro argumentos: la cantidad de espacio (en puntos) que se agregará a los lados superior, derecho, inferior e izquierdo del texto. Cualquier elemento no especificado tiene el valor predeterminado 0.\n# Los márgenes aquí parecen asimétricos porque también hay márgenes de gráfica.\nbase_t + theme(plot.title = element_text(margin = margin()))\nbase_t + theme(plot.title = element_text(margin = margin(t = 10, b = 10)))\nbase_t + theme(axis.title.y = element_text(margin = margin(r = 10)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelement_line() dibuja líneas parametrizadas por colour, linewidth y linetype: \nbase + theme(panel.grid.major = element_line(colour = \"black\"))\nbase + theme(panel.grid.major = element_line(linewidth = 2))\nbase + theme(panel.grid.major = element_line(linetype = \"dotted\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelement_rect() Dibuja rectángulos, utilizados principalmente para fondos, parametrizados por fill color y borde colour, linewidth y linetype.\nbase + theme(plot.background = element_rect(fill = \"grey80\", colour = NA))\nbase + theme(plot.background = element_rect(colour = \"red\", linewidth = 2))\nbase + theme(panel.background = element_rect(fill = \"linen\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelement_blank() no dibuja nada. Utilízalo si no quieres que se dibuje nada y que no se asigne espacio para ese elemento. El siguiente ejemplo utiliza element_blank() para suprimir progresivamente la apariencia de elementos que no nos interesan. Observe cómo la gráfica recupera automáticamente el espacio utilizado previamente por estos elementos: si no desea que esto suceda (tal vez porque necesita alinearse con otros gráficos en la página), use colour = NA, fill = NA para crear elementos invisibles que aún ocupan espacio. \nbase\nlast_plot() + theme(panel.grid.minor = element_blank())\nlast_plot() + theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\nlast_plot() + theme(panel.background = element_blank())\nlast_plot() + theme(\n  axis.title.x = element_blank(), \n  axis.title.y = element_blank()\n)\nlast_plot() + theme(axis.line = element_line(colour = \"grey50\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlgunas otras configuraciones toman unidades de cuadrícula. Créelos con unit(1, \"cm\") o unit(0.25, \"in\").\n\nPara modificar los elementos del tema para todas las gráficas futuras, use theme_update(). Devuelve la configuración del tema anterior, por lo que puedes restaurar fácilmente los parámetros originales una vez que hayas terminado. \nold_theme &lt;- theme_update(\n  plot.background = element_rect(fill = \"lightblue3\", colour = NA),\n  panel.background = element_rect(fill = \"lightblue\", colour = NA),\n  axis.text = element_text(colour = \"linen\"),\n  axis.title = element_text(colour = \"linen\")\n)\nbase\ntheme_set(old_theme)\nbase",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Temas</span>"
    ]
  },
  {
    "objectID": "themes.html#sec-theme-elements",
    "href": "themes.html#sec-theme-elements",
    "title": "17  Temas",
    "section": "\n17.4 Elementos temáticos",
    "text": "17.4 Elementos temáticos\nHay alrededor de 40 elementos únicos que controlan la apariencia de la gráfica. Se pueden agrupar a grandes rasgos en cinco categorías: gráfica, eje, leyenda, panel y faceta. Las siguientes secciones describen cada uno de ellos por separado. \n\n17.4.1 Elementos de la gráfica\n\nAlgunos elementos afectan la gráfica en su conjunto:\n\n\n\n\n\n\n\nElemento\nSetter\nDescripción\n\n\n\nplot.background\nelement_rect()\nfondo de la gráfica\n\n\nplot.title\nelement_text()\ntítulo de la gráfica\n\n\nplot.margin\nmargin()\nmárgenes alrededor de la gráfica\n\n\n\nplot.background dibuja un rectángulo que subyace a todo lo demás en el gráfico. De forma predeterminada, ggplot2 usa un fondo blanco que garantiza que el gráfico se pueda utilizar dondequiera que termine (por ejemplo, incluso si lo guarda como png y lo coloca en una diapositiva con un fondo negro). Al exportar gráficos para utilizarlos en otros sistemas, es posible que desee hacer que el fondo sea transparente con fill = NA. De manera similar, si está incrustando un gráfico en un sistema que ya tiene márgenes, es posible que desee eliminar los márgenes integrados. Tenga en cuenta que aún es necesario un pequeño margen si desea dibujar un borde alrededor del gráfico.\nbase + theme(plot.background = element_rect(colour = \"grey50\", linewidth = 2))\nbase + theme(\n  plot.background = element_rect(colour = \"grey50\", linewidth = 2),\n  plot.margin = margin(2, 2, 2, 2)\n)\nbase + theme(plot.background = element_rect(fill = \"lightblue\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n17.4.2 Elementos del eje\n \nLos elementos de eje controlan la apariencia de los ejes:\n\n\n\n\n\n\n\nElemento\nSetter\nDescripción\n\n\n\naxis.line\nelement_line()\nLínea paralela al eje (oculta en temas predeterminados)\n\n\naxis.text\nelement_text()\netiquetas de marca\n\n\naxis.text.x\nelement_text()\netiquetas de marca del eje x\n\n\naxis.text.y\nelement_text()\netiquetas de marca del eje y\n\n\naxis.title\nelement_text()\ntítulos de eje\n\n\naxis.title.x\nelement_text()\ntítulo del eje x\n\n\naxis.title.y\nelement_text()\ntítulo del eje y\n\n\naxis.ticks\nelement_line()\nmarcas de eje\n\n\naxis.ticks.length\nunit()\nlongitud de las marcas de graduación\n\n\n\nTenga en cuenta que axis.text (y axis.title) viene en tres formas: axis.text, axis.text.x y axis.text.y. Utilice la primera forma si desea modificar las propiedades de ambos ejes a la vez: cualquier propiedad que no establezca explícitamente en axis.text.x y axis.text.y se heredará de axis.text.\ndf &lt;- data.frame(x = 1:3, y = 1:3)\nbase &lt;- ggplot(df, aes(x, y)) + geom_point()\n\n# Acentuar los ejes\nbase + theme(axis.line = element_line(colour = \"grey50\", linewidth = 1))\n# Aplicar estilo a las etiquetas de los ejes x e y\nbase + theme(axis.text = element_text(color = \"blue\", size = 12))\n# Útil para etiquetas largas\nbase + theme(axis.text.x = element_text(angle = -90, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\nEl ajuste más común es rotar las etiquetas del eje x para evitar etiquetas superpuestas durante mucho tiempo. Si hace esto, tenga en cuenta que los ángulos negativos tienden a verse mejor y debe establecer hjust = 0 y vjust = 1:\ndf &lt;- data.frame(\n  x = c(\"label\", \"a long label\", \"an even longer label\"), \n  y = 1:3\n)\nbase &lt;- ggplot(df, aes(x, y)) + geom_point()\nbase\nbase + \n  theme(axis.text.x = element_text(angle = -30, vjust = 1, hjust = 0)) + \n  xlab(NULL) + \n  ylab(NULL)\n\n\n\n\n\n\n\n\n\n\n\n17.4.3 Elementos de leyenda\n \nLos elementos de leyenda controlan la apariencia de todas las leyendas. También puede modificar la apariencia de leyendas individuales modificando los mismos elementos en guide_legend() o guide_colourbar().\n\n\n\n\n\n\n\nElemento\nSetter\nDescripción\n\n\n\nlegend.background\nelement_rect()\nfondo de leyenda\n\n\nlegend.key\nelement_rect()\nfondo de claves de leyenda\n\n\nlegend.key.size\nunit()\ntamaño de clave de leyenda\n\n\nlegend.key.height\nunit()\naltura de la clave de leyenda\n\n\nlegend.key.width\nunit()\nancho de clave de leyenda\n\n\nlegend.margin\nunit()\nmargen de leyenda\n\n\nlegend.text\nelement_text()\netiquetas de leyenda\n\n\nlegend.text.align\n0–1\nalineación de la etiqueta de la leyenda (0 = right, 1 = left)\n\n\nlegend.title\nelement_text()\nnombre de la leyenda\n\n\nlegend.title.align\n0–1\nalineación del nombre de la leyenda (0 = right, 1 = left)\n\n\n\nEstas opciones se ilustran a continuación:\ndf &lt;- data.frame(x = 1:4, y = 1:4, z = rep(c(\"a\", \"b\"), each = 2))\nbase &lt;- ggplot(df, aes(x, y, colour = z)) + geom_point()\n\nbase + theme(\n  legend.background = element_rect(\n    fill = \"lemonchiffon\", \n    colour = \"grey50\", \n    linewidth = 1\n  )\n)\nbase + theme(\n  legend.key = element_rect(color = \"grey50\"),\n  legend.key.width = unit(0.9, \"cm\"),\n  legend.key.height = unit(0.75, \"cm\")\n)\nbase + theme(\n  legend.text = element_text(size = 15),\n  legend.title = element_text(size = 15, face = \"bold\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nHay otras cuatro propiedades que controlan cómo se disponen las leyendas en el contexto de la gráfica (legend.position, legend.direction, legend.justification, legend.box). Se describen en Sección 11.7.\n\n17.4.4 Elementos del panel\n \nLos elementos del panel controlan la apariencia de los paneles de trazado:\n\n\n\n\n\n\n\nElemento\nSetter\nDescripción\n\n\n\npanel.background\nelement_rect()\nfondo del panel (bajo datos)\n\n\npanel.border\nelement_rect()\nborde del panel (sobre datos)\n\n\npanel.grid.major\nelement_line()\nlíneas principales de la cuadrícula\n\n\npanel.grid.major.x\nelement_line()\nlíneas verticales principales de la cuadrícula\n\n\npanel.grid.major.y\nelement_line()\nlíneas de cuadrícula principales horizontales\n\n\npanel.grid.minor\nelement_line()\nlíneas de cuadrícula menores\n\n\npanel.grid.minor.x\nelement_line()\nlíneas de cuadrícula menores verticales\n\n\npanel.grid.minor.y\nelement_line()\nlíneas de cuadrícula menores horizontales\n\n\naspect.ratio\nnumeric\nrelación de aspecto de la gráfica\n\n\n\nLa principal diferencia entre panel.background y panel.border es que el fondo se dibuja debajo de los datos y el borde se dibuja encima. Por esa razón, siempre necesitarás asignar fill = NA al anular panel.border.\nbase &lt;- ggplot(df, aes(x, y)) + geom_point()\n# Modificar fondo\nbase + theme(panel.background = element_rect(fill = \"lightblue\"))\n\n# Modificar las principales líneas de la cuadrícula\nbase + theme(\n  panel.grid.major = element_line(color = \"gray60\", linewidth = 0.8)\n)\n# Solo en una dirección\nbase + theme(\n  panel.grid.major.x = element_line(color = \"gray60\", linewidth = 0.8)\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nTenga en cuenta que la relación de aspecto controla la relación de aspecto del panel, no la gráfica general:\nbase2 &lt;- base + theme(plot.background = element_rect(colour = \"grey50\"))\n# pantalla ancha\nbase2 + theme(aspect.ratio = 9 / 16)\n# Largo y flaco\nbase2 + theme(aspect.ratio = 2 / 1)\n# Cuadrado\nbase2 + theme(aspect.ratio = 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n17.4.5 Elementos facetados\n \nLos siguientes elementos temáticos están asociados con ggplots facetados:\n\n\n\n\n\n\n\nElement\nSetter\nDescripción\n\n\n\nstrip.background\nelement_rect()\nfondo de tiras de paneles\n\n\nstrip.text\nelement_text()\ntira de texto\n\n\nstrip.text.x\nelement_text()\ntexto de tira horizontal\n\n\nstrip.text.y\nelement_text()\ntexto de tira vertical\n\n\npanel.spacing\nunit()\nmargen entre facetas\n\n\npanel.spacing.x\nunit()\nmargen entre facetas (vertical)\n\n\npanel.spacing.y\nunit()\nmargen entre facetas (horizontal)\n\n\n\nEl elemento strip.text.x afecta tanto a facet_wrap() como a facet_grid(); strip.text.y solo afecta facet_grid().\ndf &lt;- data.frame(x = 1:4, y = 1:4, z = c(\"a\", \"a\", \"b\", \"b\"))\nbase_f &lt;- ggplot(df, aes(x, y)) + geom_point() + facet_wrap(~z)\n\nbase_f\nbase_f + theme(panel.spacing = unit(0.5, \"in\"))\nbase_f + theme(\n  strip.text = element_text(colour = \"white\"),\n  strip.background = element_rect(\n    fill = \"grey20\", \n    color = \"grey80\", \n    linewidth = 1\n  )\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n17.4.6 Ejercicios\n\n¡Crea la gráfica más fea posible! (Aportado por Andrew D. Steen, Universidad de Tennessee - Knoxville)\ntheme_dark() oscurece el interior de la gráfica, pero no el exterior. Cambie el fondo del trazado a negro y luego actualice la configuración del texto para que aún pueda leer las etiquetas.\nCrea un tema elegante que utilice lino como color de fondo y una fuente serif para el texto.\nExplora sistemáticamente los efectos de hjust cuando tienes un título de varias líneas. ¿Por qué vjust no hace nada?",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Temas</span>"
    ]
  },
  {
    "objectID": "themes.html#sec-saving",
    "href": "themes.html#sec-saving",
    "title": "17  Temas",
    "section": "\n17.5 Guardando su salida",
    "text": "17.5 Guardando su salida\nAl guardar un trazado para usarlo en otro programa, tiene dos opciones básicas de salida: ráster o vectorial: \n\nLos gráficos vectoriales describen una gráfica como una secuencia de operaciones: dibuje una línea desde \\((x_1, y_1)\\) hasta \\((x_2, y_2)\\), dibuje un círculo en \\((x_3, x_4)\\) con radio \\(r\\). Esto significa que efectivamente se pueden ampliar ‘infinitamente’; no hay pérdida de detalle. Los formatos de gráficos vectoriales más útiles son pdf y svg.\nLos gráficos rasterizados se almacenan como una variedad de colores de píxeles y tienen un tamaño de visualización óptimo fijo. El formato de gráfico rasterizado más útil es png.\n\nLa siguiente figura ilustra las diferencias básicas en estos formatos para un círculo.\n\n\n\n\nThe schematic difference between raster (left) and vector (right) graphics.\n\n\n\nA menos que haya una razón convincente para no hacerlo, utilice gráficos vectoriales: se ven mejor en más lugares. Hay dos razones principales para utilizar gráficos rasterizados:\n\nTiene un diagrama (por ejemplo, un diagrama de dispersión) con miles de objetos gráficos (es decir, puntos). Una versión vectorial será grande y lenta de renderizar.\nQuieres incrustar el gráfico en MS Office. MS tiene un soporte deficiente para gráficos vectoriales (a excepción de su propio formato DrawingXML, que actualmente no es fácil de crear desde R), por lo que los gráficos rasterizados son más fáciles.\n\nHay dos formas de guardar la salida de ggplot2. Puede utilizar el enfoque estándar de R en el que abre un dispositivo gráfico, genera el gráfico y luego cierra el dispositivo: \n\npdf(\"output.pdf\", width = 6, height = 6)\nggplot(mpg, aes(displ, cty)) + geom_point()\ndev.off()\n#&gt; png \n#&gt;   2\n\nEsto funciona para todos los paquetes, pero es detallado. ggplot2 proporciona una abreviatura conveniente con ggsave():\n\nggplot(mpg, aes(displ, cty)) + geom_point()\nggsave(\"output.pdf\")\n#&gt; Saving 7 x 5 in image\n\n\n\n\n\n\n\nggsave() está optimizado para uso interactivo: puedes usarlo después de haber dibujado un diagrama. Tiene los siguientes argumentos importantes: \n\nEl primer argumento, path, especifica la ruta donde se debe guardar la imagen. La extensión de archivo se utilizará para seleccionar automáticamente el dispositivo gráfico correcto. ggsave() puede producir .eps, .pdf, .svg, .wmf, .png, .jpg, .bmp, y .tiff.\nwidth y height controlar el tamaño de salida, especificado en pulgadas. Si se deja en blanco, utilizarán el tamaño del dispositivo gráfico en pantalla.\nPara gráficos rasterizados (es decir, .png, .jpg), el argumento dpi controla la resolución del gráfico. El valor predeterminado es 300, que es apropiado para la mayoría de las impresoras, pero es posible que desee utilizar 600 para resultados de resolución particularmente alta o 96 para visualización en pantalla (por ejemplo, web).\n\nConsulte ?ggsave para obtener más detalles.\n\n\n\n\nCarr, Dan. 1994. «Using Gray in Plots». ASA Statistical Computing and Graphics Newsletter 2 (5): 11-14. http://www.galaxy.gmu.edu/~dcarr/lib/v5n2.pdf.\n\n\n———. 2002. «Graphical displays». En Encyclopedia of Environmetrics, editado por Abdel H. El-Shaarawi y Walter W. Piegorsch, 2:933-60. John Wiley & Sons. http://www.galaxy.gmu.edu/~dcarr/lib/EnvironmentalGraphics.pdf.\n\n\nCarr, Dan, y Ru Sun. 1999. «Using Layering and Perceptual Grouping in Statistical Graphics». ASA Statistical Computing and Graphics Newsletter 10 (1): 25-31.\n\n\nCleveland, William. 1993. «A model for studying display methods of statistical graphics». Journal of Computational and Graphical Statistics 2: 323-64. http://stat.bell-labs.com/doc/93.4.ps.\n\n\nTufte, Edward R. 2006. Beautiful Evidence. Graphics Press.",
    "crumbs": [
      "La Gramática",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Temas</span>"
    ]
  },
  {
    "objectID": "extending.html",
    "href": "extending.html",
    "title": "Temas avanzados",
    "section": "",
    "text": "A medida que adquiera más fluidez en ggplot2, es posible que desee utilizarlo de formas más avanzadas. Es posible que desee escribir sus propias funciones que creen gráficos de forma reutilizable, o puede que desee escribir sus propios paquetes que extiendan ggplot2. Si esto lo describe a usted, entonces los capítulos de esta parte del libro están diseñados para ayudarlo a comenzar. En 18  Programar con ggplot2 analizamos técnicas de programación que puede utilizar para crear visualizaciones de ggplot2 flexibles y reutilizables. A esto le sigue 19  Internos de ggplot2, que profundiza en la mecánica de lo que hace ggplot2 al crear un gráfico, y 20  Extendiendo ggplot2, que se basa en esta discusión para hablar sobre cómo se escriben las extensiones de ggplot2. Finalmente, para concretar un poco más estas ideas, 21  Un caso de estudio presenta un ejemplo práctico del desarrollo de una extensión ggplot2.",
    "crumbs": [
      "Temas avanzados"
    ]
  },
  {
    "objectID": "programming.html",
    "href": "programming.html",
    "title": "18  Programar con ggplot2",
    "section": "",
    "text": "18.1 Introductción\nUn requisito importante para un buen análisis de datos es la flexibilidad. Si sus datos cambian o descubre algo que le hace reconsiderar sus suposiciones básicas, debe poder cambiar fácilmente muchos gráficos a la vez. El principal inhibidor de la flexibilidad es la duplicación de código. Si tienes la misma frase argumental repetida una y otra vez, tendrás que hacer el mismo cambio en muchos lugares diferentes. ¡A menudo la sola idea de hacer todos esos cambios es agotadora! Este capítulo le ayudará a superar ese problema mostrándole cómo programar con ggplot2.\nPara que su código sea más flexible, debe reducir el código duplicado escribiendo funciones. Cuando notes que estás haciendo lo mismo una y otra vez, piensa en cómo podrías generalizarlo y convertirlo en una función. Si no está muy familiarizado con cómo funcionan las funciones en R, es posible que desee mejorar sus conocimientos en https://adv-r.hadley.nz/functions.html.\nEn este capítulo mostraremos cómo escribir funciones que crean:\nY luego terminaremos con una breve ilustración de cómo se pueden aplicar técnicas de programación funcional a objetos ggplot2.\nTambién puede que le resulten útiles los paquetes cowplot y ggthemes. Además de proporcionar componentes reutilizables que le ayudarán directamente, también puede leer el código fuente de los paquetes para descubrir cómo funcionan.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programar con ggplot2</span>"
    ]
  },
  {
    "objectID": "programming.html#introductción",
    "href": "programming.html#introductción",
    "title": "18  Programar con ggplot2",
    "section": "",
    "text": "Un único componente ggplot2.\nMúltiples componentes de ggplot2.\nUna trama completa.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programar con ggplot2</span>"
    ]
  },
  {
    "objectID": "programming.html#componentes-individuales",
    "href": "programming.html#componentes-individuales",
    "title": "18  Programar con ggplot2",
    "section": "\n18.2 Componentes individuales",
    "text": "18.2 Componentes individuales\nCada componente de un gráfico ggplot es un objeto. La mayoría de las veces usted crea el componente y lo agrega inmediatamente a un gráfico, pero no es necesario. En su lugar, puede guardar cualquier componente en una variable (dándole un nombre) y luego agregarlo a varios gráficos:\nbestfit &lt;- geom_smooth(\n  method = \"lm\", \n  se = FALSE, \n  colour = alpha(\"steelblue\", 0.5),\n  linewidth = 2\n)\nggplot(mpg, aes(cty, hwy)) + \n  geom_point() + \n  bestfit\n#&gt; `geom_smooth()` using formula = 'y ~ x'\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  bestfit\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\nEsta es una excelente manera de reducir los tipos simples de duplicación (¡es mucho mejor que copiar y pegar!), pero requiere que el componente sea exactamente el mismo cada vez. Si necesita más flexibilidad, puede envolver estos fragmentos reutilizables en una función. Por ejemplo, podríamos extender nuestro objeto bestfit a una función más general para agregar líneas de mejor ajuste a un gráfico. El siguiente código crea un geom_lm() con tres parámetros: el modelo formula, la línea colour y el linewidth:\ngeom_lm &lt;- function(formula = y ~ x, colour = alpha(\"steelblue\", 0.5), \n                    linewidth = 2, ...)  {\n  geom_smooth(formula = formula, se = FALSE, method = \"lm\", colour = colour,\n    linewidth = linewidth, ...)\n}\nggplot(mpg, aes(displ, 1 / hwy)) + \n  geom_point() + \n  geom_lm()\nggplot(mpg, aes(displ, 1 / hwy)) + \n  geom_point() + \n  geom_lm(y ~ poly(x, 2), linewidth = 1, colour = \"red\")\n\n\n\n\n\n\n\n\n\n\nPreste mucha atención al uso de “...”. Cuando se incluye en la definición de función “...” permite que una función acepte argumentos adicionales arbitrarios. Dentro de la función, puedes usar “...” para pasar esos argumentos a otra función. Aquí pasamos “...” a geom_smooth() para que el usuario aún pueda modificar todos los demás argumentos que no hemos anulado explícitamente. Cuando escribes tus propias funciones de componentes, es una buena idea usar siempre “...” de esta manera. \nFinalmente, tenga en cuenta que sólo puede agregar componentes a un gráfico; no puede modificar ni eliminar objetos existentes.\n\n18.2.1 Ejercicios\n\nCree un objeto que represente un histograma rosa con 100 contenedores.\nCree un objeto que represente una escala de relleno con la paleta Blues ColorBrewer.\nLea el código fuente de theme_grey(). ¿Cuáles son sus argumentos? ¿Como funciona?\nCree scale_colour_wesanderson(). Debería tener un parámetro para elegir la paleta del paquete wesanderson y crear una escala continua o discreta.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programar con ggplot2</span>"
    ]
  },
  {
    "objectID": "programming.html#múltiples-componentes",
    "href": "programming.html#múltiples-componentes",
    "title": "18  Programar con ggplot2",
    "section": "\n18.3 Múltiples componentes",
    "text": "18.3 Múltiples componentes\nNo siempre es posible lograr tus objetivos con un solo componente. Afortunadamente, ggplot2 tiene una manera conveniente de agregar múltiples componentes a un gráfico en un solo paso con una lista. La siguiente función agrega dos capas: una para mostrar la media y otra para mostrar su intervalo de confianza del 95%:\ngeom_mean &lt;- function() {\n  list(\n    stat_summary(fun = \"mean\", geom = \"bar\", fill = \"grey70\"),\n    stat_summary(fun.data = \"mean_cl_normal\", geom = \"errorbar\", width = 0.4)\n  )\n}\nggplot(mpg, aes(class, cty)) + geom_mean()\nggplot(mpg, aes(drv, cty)) + geom_mean()\n\n\n\n\n\n\n\n\n\n\nSi la lista contiene elementos NULL, se ignoran. Esto facilita la adición condicional de componentes:\ngeom_mean &lt;- function(se = TRUE) {\n  list(\n    stat_summary(fun = \"mean\", geom = \"bar\", fill = \"grey70\"),\n    if (se) \n      stat_summary(fun.data = \"mean_cl_normal\", geom = \"errorbar\", width = 0.4)\n  )\n}\n\nggplot(mpg, aes(drv, cty)) + geom_mean()\nggplot(mpg, aes(drv, cty)) + geom_mean(se = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n18.3.1 Componentes de la trama\nNo estás limitado sólo a agregar capas de esta manera. También puede incluir cualquiera de los siguientes tipos de objetos en la lista:\n\nUn marco de datos, que anulará el conjunto de datos predeterminado asociado con el gráfico. (Si agrega un marco de datos por sí solo, necesitará usar %+%, pero esto no es necesario si el marco de datos está en una lista).\nUn objeto aes(), que se combinará con el mapeo estético predeterminado existente.\nEscalas, que anulan las escalas existentes, con una advertencia si ya han sido configuradas por el usuario.\nSistemas de coordenadas y especificación de facetas, que anulan la configuración existente.\nComponentes del tema, que anulan los componentes especificados.\n\n18.3.2 Anotación\nA menudo resulta útil agregar anotaciones estándar a un gráfico. En este caso, su función también establecerá los datos en la función de capa, en lugar de heredarlos del gráfico. Hay otras dos opciones que debes configurar al hacer esto. Estos garantizan que la capa sea autónoma: \n\ninherit.aes = FALSE evita que la capa herede la estética del trazado principal. Esto garantiza que su anotación funcione independientemente de lo que haya en el gráfico. \nshow.legend = FALSE garantiza que su anotación no aparecerá en la leyenda. \n\nUn ejemplo de esta técnica es la función borders() integrada en ggplot2. Está diseñado para agregar bordes de mapas desde uno de los conjuntos de datos del paquete de mapas: \n\nborders &lt;- function(database = \"world\", regions = \".\", fill = NA, \n                    colour = \"grey50\", ...) {\n  df &lt;- map_data(database, regions)\n  geom_polygon(\n    aes_(~long, ~lat, group = ~group), \n    data = df, fill = fill, colour = colour, ..., \n    inherit.aes = FALSE, show.legend = FALSE\n  )\n}\n\n\n18.3.3 Argumentos adicionales\nSi desea pasar argumentos adicionales a los componentes de su función, ... no sirve: no hay forma de dirigir diferentes argumentos a diferentes componentes. En su lugar, deberá pensar en cómo desea que funcione su función, equilibrando los beneficios de tener una función que lo haga todo con el costo de tener una función compleja que sea más difícil de entender. \nPara comenzar, aquí hay un enfoque que utiliza modifyList() y do.call(): \ngeom_mean &lt;- function(..., bar.params = list(), errorbar.params = list()) {\n  params &lt;- list(...)\n  bar.params &lt;- modifyList(params, bar.params)\n  errorbar.params  &lt;- modifyList(params, errorbar.params)\n  \n  bar &lt;- do.call(\"stat_summary\", modifyList(\n    list(fun = \"mean\", geom = \"bar\", fill = \"grey70\"),\n    bar.params)\n  )\n  errorbar &lt;- do.call(\"stat_summary\", modifyList(\n    list(fun.data = \"mean_cl_normal\", geom = \"errorbar\", width = 0.4),\n    errorbar.params)\n  )\n\n  list(bar, errorbar)\n}\n\nggplot(mpg, aes(class, cty)) + \n  geom_mean(\n    colour = \"steelblue\",\n    errorbar.params = list(width = 0.5, linewidth = 1)\n  )\nggplot(mpg, aes(class, cty)) + \n  geom_mean(\n    bar.params = list(fill = \"steelblue\"),\n    errorbar.params = list(colour = \"blue\")\n  )\n\n\n\n\n\n\n\n\n\n\nSi necesita un comportamiento más complejo, podría ser más fácil crear una geom o estadística personalizada. Puede obtener más información sobre esto en la viñeta extensible de ggplot2 incluida con el paquete. Léelo corriendo vignette(\"extending-ggplot2\").\n\n18.3.4 Ejercicios\n\nPara aprovechar al máximo el espacio, muchos ejemplos de este libro ocultan las etiquetas y la leyenda de los ejes. Acabamos de copiar y pegar el mismo código en varios lugares, pero tendría más sentido crear una función reutilizable. ¿Cómo sería esa función?\nExtienda la función borders() para agregar también coord_quickmap() al gráfico.\nRevise su propio código. ¿Qué combinaciones de geoms o escalas usas todo el tiempo? ¿Cómo podrías extraer el patrón en una función reutilizable?",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programar con ggplot2</span>"
    ]
  },
  {
    "objectID": "programming.html#sec-functions",
    "href": "programming.html#sec-functions",
    "title": "18  Programar con ggplot2",
    "section": "\n18.4 Funciones de trazado",
    "text": "18.4 Funciones de trazado\nLa creación de pequeños componentes reutilizables está más en línea con el espíritu de ggplot2: puedes recombinarlos de manera flexible para crear cualquier trama que desees. Pero a veces estás creando la misma trama una y otra vez y no necesitas esa flexibilidad. En lugar de crear componentes, es posible que desee escribir una función que tome datos y parámetros y devuelva un gráfico completo. \nPor ejemplo, podrías resumir el código completo necesario para hacer un gráfico circular:\n\npiechart &lt;- function(data, mapping) {\n  ggplot(data, mapping) +\n    geom_bar(width = 1) + \n    coord_polar(theta = \"y\") + \n    xlab(NULL) + \n    ylab(NULL)\n}\npiechart(mpg, aes(factor(1), fill = class))\n\n\n\n\n\n\n\nEsto es mucho menos flexible que el enfoque basado en componentes, pero igualmente es mucho más conciso. Tenga en cuenta que tuvimos cuidado de devolver el objeto de la trama, en lugar de imprimirlo. Eso hace posible agregar otros componentes de ggplot2.\nPuede adoptar un enfoque similar para dibujar gráficos de coordenadas paralelas (PCP). Los PCP requieren una transformación de los datos, por lo que recomendamos escribir dos funciones: una que haga la transformación y otra que genere el gráfico. Mantener estas dos piezas separadas hace la vida mucho más fácil si luego deseas reutilizar la misma transformación para una visualización diferente. \npcp_data &lt;- function(df) {\n  is_numeric &lt;- vapply(df, is.numeric, logical(1))\n\n  # Cambiar la escala de columnas numéricas\n  rescale01 &lt;- function(x) {\n    rng &lt;- range(x, na.rm = TRUE)\n    (x - rng[1]) / (rng[2] - rng[1])\n  }\n  df[is_numeric] &lt;- lapply(df[is_numeric], rescale01)\n  \n  # Agregar identificador de fila\n  df$.row &lt;- rownames(df)\n  \n  # Trate los números como variables de valor (como medidas)\n  # gather_ es la versión estadandar de evaluación de gather\n  # y es más fácil de utilizar para programar\n  tidyr::gather_(df, \"variable\", \"value\", names(df)[is_numeric])\n}\npcp &lt;- function(df, ...) {\n  df &lt;- pcp_data(df)\n  ggplot(df, aes(variable, value, group = .row)) + geom_line(...)\n}\npcp(mpg)\n#&gt; Warning: `gather_()` was deprecated in tidyr 1.2.0.\n#&gt; ℹ Please use `gather()` instead.\npcp(mpg, aes(colour = drv))\n#&gt; Warning: `gather_()` was deprecated in tidyr 1.2.0.\n#&gt; ℹ Please use `gather()` instead.\n\n\n\n\n\n\n\n\n\n\n\n18.4.1 Refiriéndose indirectamente a variables.\nLa función piechart() anterior es un poco poco atractiva porque requiere que el usuario conozca la especificación exacta aes() que genera un gráfico circular. Sería más conveniente si el usuario pudiera simplemente especificar el nombre de la variable a trazar. Para hacer eso necesitarás aprender un poco más sobre cómo funciona aes().\naes() usa evaluación ordenada: en lugar de mirar los valores de sus argumentos, mira sus expresiones. Esto dificulta la programación porque cuando desea que se refiera a una variable proporcionada en un argumento, utiliza el nombre del argumento:\n\nmy_function &lt;- function(x_var) {\n  aes(x = x_var)\n}\nmy_function(abc)\n#&gt; Aesthetic mapping: \n#&gt; * `x` -&gt; `x_var`\n\nEsto lo resolvemos utilizando la técnica estándar de programación con tidy-evaluación: abrazar. Abrazar le dice a gglot2 que mire “dentro” del argumento y use su valor, no su nombre literal:\n\nmy_function &lt;- function(x_var) {\n  aes(x = {{ x_var }})\n}\nmy_function(abc)\n#&gt; Aesthetic mapping: \n#&gt; * `x` -&gt; `abc`\n\nEsto facilita la actualización de nuestra función de gráfico circular:\n\npiechart &lt;- function(data, var) {\n  ggplot(data, aes(factor(1), fill = {{ var }})) +\n    geom_bar(width = 1) + \n    coord_polar(theta = \"y\") + \n    xlab(NULL) + \n    ylab(NULL)\n}\nmpg |&gt; piechart(class)\n\n\n\n\n\n\n\n\n18.4.2 Ejercicios\n\nCree una función distribution() especialmente diseñada para visualizar distribuciones continuas. Permita que el usuario proporcione un conjunto de datos y el nombre de una variable para visualizar. Permítales elegir entre histogramas, polígonos de frecuencia y gráficos de densidad. ¿Qué otros argumentos le gustaría incluir?\n¿Qué argumentos adicionales debería tomar pcp()? ¿Cuáles son las desventajas de cómo se usa ... en el código actual?",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programar con ggplot2</span>"
    ]
  },
  {
    "objectID": "programming.html#programación-funcional",
    "href": "programming.html#programación-funcional",
    "title": "18  Programar con ggplot2",
    "section": "\n18.5 Programación funcional",
    "text": "18.5 Programación funcional\nDado que los objetos ggplot2 son simplemente objetos R normales, puedes ponerlos en una lista. Esto significa que puede aplicar todas las excelentes herramientas de programación funcional de R. Por ejemplo, si quisieras agregar diferentes geoms al mismo gráfico base, podrías ponerlas en una lista y usar lapply(). \ngeoms &lt;- list(\n  geom_point(),\n  geom_boxplot(aes(group = cut_width(displ, 1))),\n  list(geom_point(), geom_smooth())\n)\n\np &lt;- ggplot(mpg, aes(displ, hwy))\nlapply(geoms, function(g) p + g)\n#&gt; [[1]]\n#&gt; \n#&gt; [[2]]\n#&gt; \n#&gt; [[3]]\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\nSi no está familiarizado con la programación funcional, lea https://adv-r.hadley.nz/fp.html y piense en cómo podría aplicar las técnicas a su código de trazado duplicado.\n\n18.5.1 Ejercicios\n\n\n¿Cómo podrías agregar una capa geom_point() a cada elemento de la siguiente lista?\n\nplots &lt;- list(\n  ggplot(mpg, aes(displ, hwy)),\n  ggplot(diamonds, aes(carat, price)),\n  ggplot(faithfuld, aes(waiting, eruptions, size = density))\n)\n\n\n\n¿Qué hace la siguiente función? ¿Cuál es un mejor nombre para ello?\n\nmystery &lt;- function(...) {\n  Reduce(`+`, list(...), accumulate = TRUE)\n}\n\nmystery(\n  ggplot(mpg, aes(displ, hwy)) + geom_point(), \n  geom_smooth(), \n  xlab(NULL), \n  ylab(NULL)\n)",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Programar con ggplot2</span>"
    ]
  },
  {
    "objectID": "internals.html",
    "href": "internals.html",
    "title": "19  Internos de ggplot2",
    "section": "",
    "text": "19.1 El método plot()\nA lo largo de este libro hemos descrito ggplot2 desde la perspectiva de un usuario más que de un desarrollador. Desde el punto de vista del usuario, lo importante es entender cómo funciona la interfaz de ggplot2. Para realizar una visualización de datos, el usuario necesita saber cómo se pueden usar funciones como ggplot() y geom_point() para especificar un gráfico, pero muy pocos usuarios necesitan comprender cómo ggplot2 traduce esta especificación del gráfico en una imagen. . Sin embargo, para un desarrollador de ggplot2 que espera diseñar extensiones, esta comprensión es primordial.\nAl dar el salto de usuario a desarrollador, es común encontrar frustraciones porque la naturaleza de la interfaz ggplot2 es muy diferente a la estructura de la maquinaria subyacente que la hace funcionar. A medida que extender ggplot2 se vuelve más común, también lo hace la frustración relacionada con comprender cómo encaja todo. Este capítulo está dedicado a proporcionar una descripción de cómo funciona ggplot2 “detrás de las cortinas”. Nos centramos en el diseño del sistema más que en los detalles técnicos de su implementación, y el objetivo es proporcionar una comprensión conceptual de cómo encajan las piezas. Comenzamos con una descripción general del proceso que se desarrolla cuando se traza un objeto ggplot y luego profundizamos en los detalles, describiendo cómo los datos fluyen a través de todo este proceso y terminan como elementos visuales en su trama.\nPara comprender la maquinaria que sustenta ggplot2, es importante reconocer que casi todo lo relacionado con el dibujo de la trama ocurre cuando imprimes el objeto ggplot, no cuando lo construyes. Por ejemplo, en el código siguiente, el objeto p es una especificación abstracta de los datos de la trama, las capas, etc. No construye la imagen en sí:\np &lt;- ggplot(mpg, aes(displ, hwy, color = drv)) + \n  geom_point(position = \"jitter\") +\n  geom_smooth(method = \"lm\", formula = y ~ x) + \n  facet_wrap(vars(year)) + \n  ggtitle(\"A plot for expository purposes\")\nggplot2 está diseñado de esta manera para permitir al usuario agregar nuevos elementos a un gráfico sin necesidad de volver a calcular nada. Una implicación de esto es que si quieres entender la mecánica de ggplot2, tienes que seguir tu trama a medida que avanza por la madriguera del conejo plot()1. Puede inspeccionar el método de impresión para objetos ggplot escribiendo ggplot2:::plot.ggplot en la consola, pero para este capítulo trabajaremos con una versión simplificada. Reducido a lo esencial, el método de trazado ggplot2 tiene la misma estructura que la siguiente función ggprint():\nggprint &lt;- function(x) {\n  data &lt;- ggplot_build(x)\n  gtable &lt;- ggplot_gtable(data)\n  grid::grid.newpage()\n  grid::grid.draw(gtable)\n  return(invisible(x))\n}\nEsta función no maneja todos los casos de uso posibles, pero es suficiente para dibujar el gráfico especificado anteriormente:\nggprint(p)\nEl código de nuestro método de impresión simplificado revela cuatro pasos distintos:\nUna cosa que este proceso revela es que ggplot2 no realiza ningún dibujo de bajo nivel: su responsabilidad termina cuando se ha creado el objeto gtable. El paquete gtable (que implementa la clase gtable) tampoco realiza ningún dibujo. Todo el dibujo lo realiza el paquete grid junto con el dispositivo gráfico activo. Este es un punto importante, ya que significa que ggplot2, o cualquier extensión de ggplot2, no se preocupa por el meollo de la creación de la salida visual. Más bien, su trabajo es convertir los datos del usuario a una o más primitivas gráficas como polígonos, líneas, puntos, etc. y luego entregar la responsabilidad al paquete grid.\nAunque no es estrictamente correcto hacerlo, nos referiremos a esta conversión a primitivas gráficas como proceso de renderizado. Las siguientes dos secciones siguen los datos a través de la madriguera del conejo de renderizado a través del paso de compilación (Sección 19.2) y el paso de gtable (Sección 19.3) después de lo cual, algo así como Alicia en la novela de Lewis Carroll, finalmente llega a la cuadrícula. El país de las maravillas como una colección de primitivos gráficos.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Internos de ggplot2</span>"
    ]
  },
  {
    "objectID": "internals.html#sec-plot-method",
    "href": "internals.html#sec-plot-method",
    "title": "19  Internos de ggplot2",
    "section": "",
    "text": "Primero, llama a ggplot_build() donde los datos de cada capa se preparan y organizan en un formato estandarizado adecuado para trazar.\nEn segundo lugar, los datos preparados se pasan a ggplot_gtable() y los convierte en elementos gráficos almacenados en una gtable (volveremos a eso más adelante).\nEn tercer lugar, el objeto gtable se convierte en una imagen con la ayuda del paquete grid.\nCuarto, el objeto ggplot original se devuelve de forma invisible al usuario.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Internos de ggplot2</span>"
    ]
  },
  {
    "objectID": "internals.html#sec-ggplotbuild",
    "href": "internals.html#sec-ggplotbuild",
    "title": "19  Internos de ggplot2",
    "section": "\n19.2 El paso de construcción",
    "text": "19.2 El paso de construcción\n\nggplot_build(), como se analizó anteriormente, toma la representación declarativa construida con la API pública y la aumenta preparando los datos para su conversión a primitivas gráficas.\n\n19.2.1 Preparación de datos\nLa primera parte del procesamiento es obtener los datos asociados con cada capa y ponerlos en un formato predecible. Una capa puede proporcionar datos de una de tres maneras: puede proporcionar los suyos propios (por ejemplo, si el argumento data de una geom es un marco de datos), puede heredar los datos globales proporcionados a ggplot(), o de lo contrario, podría proporcionar una función que devuelva un marco de datos cuando se aplica a los datos globales. En los tres casos, el resultado es un marco de datos que se pasa al diseño del trazado, que organiza sistemas de coordenadas y facetas. Cuando esto sucede, los datos se pasan primero al sistema de coordenadas de la trama, que puede cambiarlos (pero generalmente no lo hace), y luego a la faceta que inspecciona los datos para determinar cuántos paneles debe tener la trama y cómo deben organizarse. . Durante este proceso, los datos asociados con cada capa se aumentarán con una columna PANEL. Esta columna (debe) mantenerse durante todo el proceso de renderizado y se utiliza para vincular cada fila de datos a un panel de facetas específico en el gráfico final.\nLa última parte de la preparación de datos es convertir los datos de la capa en valores estéticos calculados. Esto implica evaluar todas las expresiones estéticas de aes() en los datos de la capa. Además, si no se da explícitamente, la estética group se calcula a partir de la interacción de todas las estéticas no continuas. La estética del group es, como PANEL, una columna especial que debe mantenerse durante todo el procesamiento. Como ejemplo, el gráfico p creado anteriormente contiene solo la capa especificada por geom_point() y al final del proceso de preparación de datos, las primeras 10 filas de los datos asociados con esta capa se ven así:\n\n#&gt;      x  y colour PANEL group\n#&gt; 1  1.8 29      f     1     2\n#&gt; 2  1.8 29      f     1     2\n#&gt; 3  2.0 31      f     2     2\n#&gt; 4  2.0 30      f     2     2\n#&gt; 5  2.8 26      f     1     2\n#&gt; 6  2.8 26      f     1     2\n#&gt; 7  3.1 27      f     2     2\n#&gt; 8  1.8 26      4     1     1\n#&gt; 9  1.8 25      4     1     1\n#&gt; 10 2.0 28      4     2     1\n\n\n19.2.2 Transformación de datos\nUna vez que los datos de la capa se han extraído y convertido a un formato predecible, se someten a una serie de transformaciones hasta que tienen el formato esperado por la geometría de la capa.\nEl primer paso es aplicar cualquier transformación de escala a las columnas de los datos. Es en esta etapa del proceso que cualquier argumento a favor de trans en una escala tiene efecto, y toda la representación posterior tendrá lugar en este espacio transformado. Esta es la razón por la que establecer una transformación de posición en la escala tiene un efecto diferente que establecerla en el sistema de coordenadas. Si la transformación se especifica en la escala, se aplica antes de cualquier otro cálculo, pero si se especifica en el sistema de coordenadas, la transformación se aplica después de esos cálculos. Por ejemplo, nuestro gráfico original p no implica transformaciones de escala, por lo que los datos de la capa permanecen intactos en esta etapa. Las primeras tres filas se muestran a continuación:\n\n#&gt;     x  y colour PANEL group\n#&gt; 1 1.8 29      f     1     2\n#&gt; 2 1.8 29      f     1     2\n#&gt; 3 2.0 31      f     2     2\n\nPor el contrario, si nuestro objeto de trazado es p + scale_x_log10() e inspeccionamos los datos de la capa en este punto del procesamiento, vemos que la variable x se ha transformado apropiadamente:\n\n#&gt;       x  y colour PANEL group\n#&gt; 1 0.255 29      f     1     2\n#&gt; 2 0.255 29      f     1     2\n#&gt; 3 0.301 31      f     2     2\n\nEl segundo paso del proceso es mapear la estética de la posición utilizando las escalas de posición, que se despliegan de manera diferente según el tipo de escala involucrada. Para escalas de posición continuas, como las utilizadas en nuestro ejemplo, la función fuera de límites especificada en el argumento oob (Sección 14.4) se aplica en este punto y los valores NA en los datos de la capa se eliminan. . Esto hace poca diferencia para p, pero si estuviéramos graficando p + xlim(2, 8) en lugar de ello, la función oob – scales::censor() en este caso – reemplazaría a x valores por debajo de 2 con NA como se ilustra a continuación:\n\n#&gt; Warning: Removed 22 rows containing non-finite outside the scale range\n#&gt; (`stat_smooth()`).\n#&gt;    x  y colour PANEL group\n#&gt; 1 NA 29      f     1     2\n#&gt; 2 NA 29      f     1     2\n#&gt; 3  2 31      f     2     2\n\nPara posiciones discretas, el cambio es más radical, porque los valores coinciden con los valores de llimits o la especificación de interrupciones con breaks proporcionada por el usuario y luego se convierten a posiciones con valores enteros. Finalmente, para escalas de posición agrupadas, los datos continuos primero se cortan en bins usando el argumento breaks, y la posición de cada bin se establece en el punto medio de su rango. La razón para realizar el mapeo en esta etapa del proceso es la coherencia: no importa qué tipo de escala de posición se utilice, parecerá continua para los cálculos de estadísticas y geom. Esto es importante porque, de lo contrario, los cálculos como la esquiva y la fluctuación fallarían en escalas discretas.\nEn la tercera etapa de esta transformación, los datos se entregan a la capa de estadísticas donde se lleva a cabo cualquier transformación estadística. El procedimiento es el siguiente: primero, la estadística puede inspeccionar los datos y modificar sus parámetros, luego realizar una preparación única de los datos. A continuación, los datos de la capa se dividen en PANEL y group, y las estadísticas se calculan antes de volver a ensamblar los datos.2 Una vez que los datos se han vuelto a ensamblar en su nueva forma, pasan por otro proceso de mapeo estético. Aquí es donde se agrega a los datos cualquier estética cuyo cálculo se haya retrasado usando stat() (o la antigua notación ..var..). Observe que esta es la razón por la cual las expresiones stat(), incluida la fórmula utilizada para especificar el modelo de regresión en la capa geom_smooth() de nuestro gráfico de ejemplo p, no pueden hacer referencia a los datos originales. Simplemente no existe en este momento.\nComo ejemplo, considere la segunda capa de nuestro gráfico, que produce las regresiones lineales. Antes de realizar los cálculos estadísticos, los datos de esta capa simplemente contienen las coordenadas y las columnas PANEL y group requeridas.\n\n#&gt;     x  y colour PANEL group\n#&gt; 1 1.8 29      f     1     2\n#&gt; 2 1.8 29      f     1     2\n#&gt; 3 2.0 31      f     2     2\n\nUna vez realizados los cálculos estadísticos, los datos de la capa cambian considerablemente:\n\n#&gt;      x    y ymin ymax    se flipped_aes colour PANEL group\n#&gt; 1 1.80 24.3 23.1 25.6 0.625       FALSE      4     1     1\n#&gt; 2 1.86 24.2 22.9 25.4 0.612       FALSE      4     1     1\n#&gt; 3 1.92 24.0 22.8 25.2 0.598       FALSE      4     1     1\n\nEn este punto, la geom reemplaza a la estadística (casi). La primera acción que toma es inspeccionar los datos, actualizar sus parámetros y posiblemente realizar una modificación de primer paso de los datos (la misma configuración que para las estadísticas). Posiblemente aquí es donde algunas de las columnas se reparametrizan, p. x+width se cambia a xmin+xmax. Después de esto se aplica el ajuste de posición, de modo que p.e. las barras superpuestas se apilan, etc. Para nuestro gráfico de ejemplo p, es en este paso que se aplica la fluctuación en la primera capa del gráfico y las coordenadas x e y se alteran:\n\n#&gt;      x    y colour PANEL group\n#&gt; 1 1.84 28.7      f     1     2\n#&gt; 2 1.77 29.1      f     1     2\n#&gt; 3 2.03 31.3      f     2     2\n\nA continuación, y quizás sorprendentemente, todas las escalas de posición se restablecen, se vuelven a entrenar y se aplican a los datos de la capa. Pensándolo bien, esto es absolutamente necesario porque, por ejemplo, el apilamiento puede cambiar drásticamente el rango de uno de los ejes. En algunos casos (por ejemplo, en el ejemplo de histograma anterior), es posible que una de las estéticas de posición ni siquiera esté disponible hasta después de los cálculos de estadísticas y, si las escalas no se volvieran a entrenar, nunca se entrenarían.\nLa última parte de la transformación de datos es entrenar y mapear todas las estéticas no posicionales, es decir, convertir cualquier entrada discreta o continua que esté asignada a parámetros gráficos como colores, tipos de línea, tamaños, etc. Además, se agrega cualquier estética predeterminada de geom. de modo que los datos ahora estén en un estado predecible para la geom. En el último paso, tanto la estadística como la faceta tienen una última oportunidad de modificar los datos en su forma asignada final con sus métodos finish_data() antes de finalizar el paso de compilación. Para el objeto de trazado p, las primeras filas del estado final de los datos de la capa se ven así:\n\n#&gt;    colour    x    y PANEL group shape size fill alpha stroke\n#&gt; 1 #00BA38 1.83 29.1     1     2    19  1.5   NA    NA    0.5\n#&gt; 2 #00BA38 1.79 29.2     1     2    19  1.5   NA    NA    0.5\n#&gt; 3 #00BA38 1.99 30.7     2     2    19  1.5   NA    NA    0.5\n\n\n19.2.3 Salida\nEl valor de retorno de ggplot_build() es una estructura de lista con la clase ggplot_built. Contiene los datos calculados, así como un objeto Layout que contiene información sobre el sistema de coordenadas entrenado y las facetas. Además, contiene una copia del objeto de la trama original, pero ahora con escalas entrenadas.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Internos de ggplot2</span>"
    ]
  },
  {
    "objectID": "internals.html#sec-ggplotgtable",
    "href": "internals.html#sec-ggplotgtable",
    "title": "19  Internos de ggplot2",
    "section": "\n19.3 El paso gtable",
    "text": "19.3 El paso gtable\nEl propósito de ggplot_gtable() es tomar el resultado del paso de compilación y, con la ayuda del paquete gtable, convertirlo en un objeto que se pueda trazar usando grid (hablaremos más sobre gtable en Sección 21.5.6). En este punto, los principales elementos responsables de cálculos adicionales son las geomas, el sistema de coordenadas, la faceta y el tema. Las estadísticas y los ajustes de posición ya han contribuido.\n\n19.3.1 Renderizando los paneles\nLo primero que sucede es que los datos se convierten en su representación gráfica. Esto sucede en dos pasos. Primero, cada capa se convierte en una lista de objetos gráficos (grobs). Al igual que con las estadísticas, la conversión se realiza dividiendo los datos, primero por PANEL y luego por group, con la posibilidad de que geom intercepte esta división por razones de rendimiento. Si bien ya se ha realizado gran parte de la preparación de datos, no es raro que geom realice alguna transformación adicional de los datos durante este paso. Una parte crucial es transformar y normalizar los datos de posición. Esto lo hace el sistema de coordenadas y, si bien a menudo significa simplemente que los datos se normalizan en función de los límites del sistema de coordenadas, también puede incluir transformaciones radicales, como convertir las posiciones en coordenadas polares. El resultado de esto es para cada capa una lista de objetos gList correspondientes a cada panel en el diseño de facetas. Después de esto, la faceta se hace cargo y ensambla los paneles. Para ello, primero recopila los grobs para cada panel de las capas, junto con franjas de renderizado, fondos, líneas de cuadrícula y ejes según el tema, y combina todo esto en una única gList para cada panel. Luego procede a organizar todos estos paneles en una tabla basada en el diseño del panel calculado. Para la mayoría de los gráficos, esto es simple ya que solo hay un panel, pero, por ejemplo, trazar usando facet_wrap() puede ser bastante complicado. La salida es la base del objeto gtable final. En esta etapa del proceso, nuestro gráfico de ejemplo p se ve así:\n\n\n\n\n\n\n\n\n\n19.3.2 Agregar guías\nHay dos tipos de guías en ggplot2: ejes y leyendas. Como ilustra nuestro gráfico p, en este punto los ejes ya se han renderizado y ensamblado junto con los paneles, pero aún faltan las leyendas. Representar las leyendas es un proceso complicado en el que primero se entrena una guía para cada escala. Luego, potencialmente se fusionan varias guías si su mapeo lo permite, antes de que a las capas que contribuyen a la leyenda se les soliciten claves para cada clave de la leyenda. Estos elementos clave luego se ensamblan en capas y se combinan hasta formar la leyenda final en un proceso que recuerda bastante a cómo se combinan las capas en la tabla de paneles. Al final, el resultado es una tabla g que contiene cada cuadro de leyenda organizado y diseñado de acuerdo con el tema y las especificaciones de la guía. Una vez creada, la gtable guía se agrega a la gtable principal de acuerdo con la configuración del tema legend.position. En esta etapa, nuestro argumento de ejemplo está completo en la mayoría de los aspectos: lo único que falta es el título.\n\n\n\n\n\n\n\n\n\n19.3.3 Añadiendo adorno\nLo único que queda es agregar título, subtítulo, leyenda y etiqueta, así como agregar fondo y márgenes, momento en el cual la tabla final estará lista.\n\n19.3.4 Salida\nEn este punto, ggplot2 está listo para entregarse a grid. Nuestro proceso de renderizado es más o menos equivalente al código siguiente y el resultado final es, como se describe anteriormente, una gtable:\n\np_built &lt;- ggplot_build(p)\np_gtable &lt;- ggplot_gtable(p_built)\n\nclass(p_gtable)\n#&gt; [1] \"gtable\" \"gTree\"  \"grob\"   \"gDesc\"\n\nLo que es menos obvio es que las dimensiones del objeto son impredecibles y dependerán tanto del facetado como de la ubicación de la leyenda y de los títulos que se dibujen. Por lo tanto, no se recomienda depender de la ubicación de las filas y columnas en su código, en caso de que desee modificar aún más la gtable. Sin embargo, todos los elementos de gtable tienen nombre, por lo que aún es posible recuperarlos de manera confiable, p. el grob sostiene el eje y superior izquierdo con un poco de trabajo. A modo de ilustración, la gtable para nuestro gráfico p se muestra en el siguiente código:\n\np_gtable\n#&gt; TableGrob (17 x 17) \"layout\": 25 grobs\n#&gt;     z         cells             name\n#&gt; 1   0 ( 1-17, 1-17)       background\n#&gt; 2   1 (10-10, 7- 7)        panel-1-1\n#&gt; 3   1 (10-10,11-11)        panel-2-1\n#&gt; 4   3 ( 8- 8, 7- 7)       axis-t-1-1\n#&gt; 5   3 ( 8- 8,11-11)       axis-t-2-1\n#&gt; 6   3 (11-11, 7- 7)       axis-b-1-1\n#&gt; 7   3 (11-11,11-11)       axis-b-2-1\n#&gt; 8   3 (10-10,10-10)       axis-l-1-2\n#&gt; 9   3 (10-10, 6- 6)       axis-l-1-1\n#&gt; 10  3 (10-10,12-12)       axis-r-1-2\n#&gt; 11  3 (10-10, 8- 8)       axis-r-1-1\n#&gt; 12  2 ( 9- 9, 7- 7)      strip-t-1-1\n#&gt; 13  2 ( 9- 9,11-11)      strip-t-2-1\n#&gt; 14  4 ( 7- 7, 7-11)           xlab-t\n#&gt; 15  5 (12-12, 7-11)           xlab-b\n#&gt; 16  6 (10-10, 5- 5)           ylab-l\n#&gt; 17  7 (10-10,13-13)           ylab-r\n#&gt; 18  8 (10-10,15-15)  guide-box-right\n#&gt; 19  9 (10-10, 3- 3)   guide-box-left\n#&gt; 20 10 (14-14, 7-11) guide-box-bottom\n#&gt; 21 11 ( 5- 5, 7-11)    guide-box-top\n#&gt; 22 12 (10-10, 7-11) guide-box-inside\n#&gt; 23 13 ( 4- 4, 7-11)         subtitle\n#&gt; 24 14 ( 3- 3, 7-11)            title\n#&gt; 25 15 (15-15, 7-11)          caption\n#&gt;                                             grob\n#&gt; 1                rect[plot.background..rect.707]\n#&gt; 2                       gTree[panel-1.gTree.587]\n#&gt; 3                       gTree[panel-2.gTree.602]\n#&gt; 4                                 zeroGrob[NULL]\n#&gt; 5                                 zeroGrob[NULL]\n#&gt; 6            absoluteGrob[GRID.absoluteGrob.606]\n#&gt; 7            absoluteGrob[GRID.absoluteGrob.606]\n#&gt; 8                                 zeroGrob[NULL]\n#&gt; 9            absoluteGrob[GRID.absoluteGrob.614]\n#&gt; 10                                zeroGrob[NULL]\n#&gt; 11                                zeroGrob[NULL]\n#&gt; 12                                 gtable[strip]\n#&gt; 13                                 gtable[strip]\n#&gt; 14                                zeroGrob[NULL]\n#&gt; 15 titleGrob[axis.title.x.bottom..titleGrob.669]\n#&gt; 16   titleGrob[axis.title.y.left..titleGrob.672]\n#&gt; 17                                zeroGrob[NULL]\n#&gt; 18                             gtable[guide-box]\n#&gt; 19                                zeroGrob[NULL]\n#&gt; 20                                zeroGrob[NULL]\n#&gt; 21                                zeroGrob[NULL]\n#&gt; 22                                zeroGrob[NULL]\n#&gt; 23         zeroGrob[plot.subtitle..zeroGrob.704]\n#&gt; 24          titleGrob[plot.title..titleGrob.703]\n#&gt; 25          zeroGrob[plot.caption..zeroGrob.705]\n\nLa trama final, como era de esperar, parece idéntica a la original:\n\ngrid::grid.newpage()\ngrid::grid.draw(p_gtable)",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Internos de ggplot2</span>"
    ]
  },
  {
    "objectID": "internals.html#sec-ggproto",
    "href": "internals.html#sec-ggproto",
    "title": "19  Internos de ggplot2",
    "section": "\n19.4 Presentando ggproto",
    "text": "19.4 Presentando ggproto\nSección 19.1 a Sección 19.3 se centran en la secuencia de eventos involucrados en la construcción de un ggplot, pero son intencionalmente vagos en cuanto a qué tipo de objetos de programación realizan este trabajo.\nTodos los objetos ggplot2 se crean utilizando el sistema ggproto para programación orientada a objetos, y es inusual que solo lo use ggplot2. Esto es una especie de accidente histórico: ggplot2 originalmente usaba proto (Grothendieck, Kates, y Petzoldt 2016) para programación orientada a objetos, lo que se convirtió en un problema una vez que surgió la necesidad de un mecanismo de extensión oficial debido a las limitaciones del sistema proto. Los intentos de cambiar ggplot2 a otros sistemas como R6 (Chang 2020) resultaron difíciles, y crear un sistema orientado a objetos específico para las necesidades de ggplot2 resultó ser la solución menos mala.\nComprender el sistema de programación orientado a objetos ggproto es importante si desea escribir extensiones de ggplot2. Encontraremos objetos ggproto tal como los usa ggplot2 en Capítulo 20 y Capítulo 21. Al igual que el sistema R6 más conocido, ggproto utiliza semántica de referencia y permite la herencia y el acceso a métodos de las clases principales. Va acompañado de un conjunto de principios de diseño que, si bien ggproto no aplica, son esenciales para comprender cómo se utiliza el sistema en ggplot2. Para ilustrar estos conceptos, esta sección presenta la mecánica central de ggproto en una forma simplificada.\n\n19.4.1 objetos ggproto\nLa creación de un nuevo objeto ggproto se realiza con la función ggproto(), que toma el nombre de la nueva clase como primer argumento, y otro objeto ggproto del cual heredará el nuevo como segundo argumento. Por ejemplo, podríamos crear un objeto ggproto (aunque no tenga ninguna funcionalidad útil) con el siguiente comando:\n\nNewObject &lt;- ggproto(\n  `_class` = NULL, \n  `_inherits` = NULL\n)\n\nPor convención, los objetos ggproto se denominan usando “UpperCamelCase”, en el que cada palabra comienza con una letra mayúscula. También es convencional omitir los nombres de los argumentos `_class` y `_inherits`, por lo que la forma convencional de este comando sería la siguiente:\n\nNewObject &lt;- ggproto(NULL, NULL)\n\nSi imprimimos este objeto vemos que efectivamente es un objeto ggproto, pero no aparece ninguna otra información.\n\nNewObject \n#&gt; &lt;ggproto object: Class gg&gt;\n\n\n19.4.2 Creando nuevas clases\nPara crear una nueva clase ggproto, lo único que es estrictamente necesario es proporcionar un nombre de clase como primer argumento de ggproto(). Un comando mínimo que define una nueva clase podría verse así:\n\nNewClass &lt;- ggproto(\"NewClass\", NULL)\n\nLa variable NewClass todavía hace referencia a un objeto ggproto, pero podemos verificar que tiene el nombre de clase deseado imprimiéndolo:\n\nNewClass\n#&gt; &lt;ggproto object: Class NewClass, gg&gt;\n\nSin embargo, hasta ahora lo único que hemos hecho es crear un objeto que especifica una clase. El objeto NewClass no hace nada. Para crear una clase ggproto que haga algo útil, debemos proporcionar una lista de campos y métodos cuando definimos la clase. En este contexto, los “campos” se utilizan para almacenar datos relevantes para el objeto y los “métodos” son funciones que pueden utilizar los datos almacenados en el objeto. Los campos y métodos se construyen de la misma manera y no se tratan de manera diferente desde la perspectiva del usuario.\nPara ilustrar esto, crearemos una nueva clase llamada Person que se usará para almacenar y manipular información sobre una persona. Podemos hacer esto proporcionando a la función ggproto() pares nombre/valor:\n\nPerson &lt;- ggproto(\"Person\", NULL,\n  \n  # campos                  \n  given_name = NA,\n  family_name = NA,\n  birth_date = NA,\n  \n  # métodos\n  full_name = function(self, family_last = TRUE) {\n    if(family_last == TRUE) {\n      return(paste(self$given_name, self$family_name))\n    }\n    return(paste(self$family_name, self$given_name))\n  },\n  age = function(self) {\n    days_old &lt;- Sys.Date() - self$birth_date\n    floor(as.integer(days_old) / 365.25)\n  },\n  description = function(self) {\n    paste(self$full_name(), \"is\", self$age(), \"years old\")\n  }\n)\n\nLa clase Person ahora está asociada con tres campos, correspondientes a given_name y family_name de una persona, así como su birth_date. También posee tres métodos: el método full_name() es una función que construye el nombre completo de la persona, usando la convención de colocar el nombre de pila primero y el apellido segundo, el método age() calcula la edad de la persona en años, y el método description() imprime una breve descripción de la persona.\nAl imprimir el objeto se muestran los campos y métodos a los que está asociado:\n\nPerson\n#&gt; &lt;ggproto object: Class Person, gg&gt;\n#&gt;     age: function\n#&gt;     birth_date: NA\n#&gt;     description: function\n#&gt;     family_name: NA\n#&gt;     full_name: function\n#&gt;     given_name: NA\n\nEl objeto ggproto Person es esencialmente una plantilla para la clase, y podemos usarlo para crear registros específicos de personas individuales (discutido en Sección 19.4.3). Si está familiarizado con otros sistemas de programación orientados a objetos, es posible que esperara algo un poco diferente: a menudo las nuevas clases se definen con una función constructora dedicada. Una peculiaridad de ggproto es que ggproto() no hace esto: más bien, el constructor de la clase es en sí mismo un objeto.\nOtra cosa a tener en cuenta al definir métodos es el uso de self como primer argumento. Este es un argumento especial que se utiliza para darle al método acceso a los campos y métodos asociados con el objeto ggproto (consulte Sección 19.4.4 para ver un ejemplo). El estatus especial de este argumento es evidente al imprimir un método ggproto:\n\nPerson$full_name\n#&gt; &lt;ggproto method&gt;\n#&gt;   &lt;Wrapper function&gt;\n#&gt;     function(...) !!call2(name, !!!args)\n#&gt; \n#&gt;   &lt;Inner function (f)&gt;\n#&gt;     function (self, family_last = TRUE) \n#&gt; {\n#&gt;     if (family_last == TRUE) {\n#&gt;         return(paste(self$given_name, self$family_name))\n#&gt;     }\n#&gt;     return(paste(self$family_name, self$given_name))\n#&gt; }\n\nEste resultado puede parecer un poco sorprendente: cuando definimos full_name() anteriormente solo proporcionamos el código listado como “función interna”. Lo que sucedió es que ggproto() automáticamente incluyó mi función dentro de una función contenedora que llama a mi código como función interna, al tiempo que garantiza que se use una definición apropiada de self. Cuando se imprime el método, la consola muestra tanto la función contenedora (normalmente de poco interés) como la función interna. La salida en este formato aparece en Capítulo 20 y Capítulo 21.\n\n19.4.3 Creando nuevas instancias\nAhora que hemos definido la clase Person, podemos crear instancias de la clase. Esto se hace pasando un objeto ggproto como segundo argumento a ggproto() y sin especificar un nuevo nombre de clase en el primer argumento. Por ejemplo, podemos crear nuevos objetos Thomas y Danielle que sean instancias de la clase Person de la siguiente manera:\n\nThomas &lt;- ggproto(NULL, Person,\n  given_name = \"Thomas Lin\",\n  family_name = \"Pedersen\",\n  birth_date = as.Date(\"1985/10/12\")\n)\n\nDanielle &lt;- ggproto(NULL, Person,\n  given_name = \"Danielle Jasmine\",\n  family_name = \"Navarro\",\n  birth_date = as.Date(\"1977/09/12\")\n)\n\nAl especificar NULL como primer argumento, se le indica a ggproto() que no defina una nueva clase, sino que cree una nueva instancia de la clase especificada en el segundo argumento. Debido a que Thomas y Danielle son instancias de la clase Person, heredan automáticamente sus métodos age(), full_name() y description():\n\nThomas$description()\n#&gt; [1] \"Thomas Lin Pedersen is 40 years old\"\n\nDanielle$description()\n#&gt; [1] \"Danielle Jasmine Navarro is 48 years old\"\n\n\n19.4.4 Creando subclases\nEn el ejemplo anterior creamos Person como una clase completamente nueva. En la práctica, casi nunca necesitarás hacer esto: en su lugar, probablemente crearás una subclase usando un objeto ggproto existente. Puede hacer esto especificando el nombre de la subclase y el objeto del cual debe heredar en la llamada a ggproto():\n\n# definir la subclase\nNewSubClass &lt;- ggproto(\"NewSubClass\", Person)\n\n# verificar que esto funcione\nNewSubClass\n#&gt; &lt;ggproto object: Class NewSubClass, Person, gg&gt;\n#&gt;     age: function\n#&gt;     birth_date: NA\n#&gt;     description: function\n#&gt;     family_name: NA\n#&gt;     full_name: function\n#&gt;     given_name: NA\n#&gt;     super:  &lt;ggproto object: Class Person, gg&gt;\n\nEl resultado que se muestra arriba ilustra que NewSubClass ahora proporciona su propia clase y que hereda todos los campos y métodos del objeto Persona que creamos anteriormente. Sin embargo, esta nueva subclase no agrega ninguna funcionalidad nueva.\nAl crear una subclase, a menudo queremos agregar nuevos campos o métodos y sobrescribir algunos de los existentes. Por ejemplo, supongamos que queremos definir Royalty como una subclase de Person y agregar campos correspondientes al rank de la realeza en cuestión y el territory sobre el que gobernaban. Debido a que a menudo se hace referencia a la realeza por título y territorio en lugar de en términos de nombre y apellido, también necesitaremos cambiar la forma en que se define el método full_name():\n\nRoyalty &lt;- ggproto(\"Royalty\", Person,\n  rank = NA,\n  territory = NA,\n  full_name = function(self) {\n    paste(self$rank, self$given_name, \"of\", self$territory)\n  }\n)\n\nEl objeto Royalty ahora define una subclase de persona que hereda algunos campos (given_name, family_name, birth_date) de la clase Person y proporciona otros campos (rank, territory). Hereda los métodos age() y description() de Person, pero sobrescribe el método full_name().\nAhora podemos crear una nueva instancia de la subclase Royalty:\n\nVictoria &lt;- ggproto(NULL, Royalty,\n  given_name = \"Victoria\",\n  family_name = \"Hanover\",\n  rank = \"Queen\",\n  territory = \"the United Kingdom\",\n  birth_date = as.Date(\"1819/05/24\")\n)\n\nEntonces, cuando llamamos al método full_name() para Victoria, la salida usa el método especificado en la clase Royalty en lugar del definido en la clase Persona:\n\nVictoria$full_name()\n#&gt; [1] \"Queen Victoria of the United Kingdom\"\n\nVale la pena señalar lo que sucede cuando llamamos al método description(). Este método se hereda de Person, pero la definición de este método invoca self$full_name(). Aunque description() está definida en Person, en este contexto self todavía se refiere a Victoria, que sigue siendo Royalty. Lo que esto significa es que la salida del método heredado description() utiliza el método full_name() definido para la subclase:\n\nVictoria$description()\n#&gt; [1] \"Queen Victoria of the United Kingdom is 206 years old\"\n\nLa creación de subclases a veces requiere que accedamos a la clase principal y sus métodos, lo que podemos hacer con la ayuda de la función ggproto_parent(). Por ejemplo, podemos definir una subclase Police que incluya un campo rank de la misma manera que lo hace la subclase Royalty, pero solo usa este rango como parte del método description():\n\nPolice &lt;- ggproto(\"Police\", Person,\n  rank = NA, \n  description = function(self) {\n    paste(\n      self$rank,\n      ggproto_parent(Person, self)$description()\n    )\n  }\n)\n\nEn este ejemplo, el método description() para la subclase Police se define de una manera que se refiere explícitamente al método description() para la clase principal Person. Al usar ggproto_parent(Person, self) de esta manera, podemos hacer referencia al método dentro de la clase principal, manteniendo la definición local apropiada de self. Como antes, crearemos una instancia específica y verificaremos que funcione como se esperaba:\n\nJohn &lt;- ggproto(NULL, Police,\n  given_name = \"John\",\n  family_name = \"McClane\",\n  rank = \"Detective\",\n  birth_date = as.Date(\"1955/03/19\")\n)\n\nJohn$full_name() \n#&gt; [1] \"John McClane\"\n\nJohn$description()\n#&gt; [1] \"Detective John McClane is 70 years old\"\n\nPor razones que discutiremos a continuación, el uso de ggproto_parent() no es tan frecuente en el código fuente de ggplot2.\n\n19.4.5 Guía de estilo para ggproto\nDebido a que ggproto es un sistema de clases mínimo diseñado para acomodar ggplot2 y nada más, es importante reconocer que ggproto se usa en ggplot2 de una manera muy específica. Existe para admitir el sistema de extensión ggplot2 y es poco probable que encuentre ggproto en cualquier otro contexto que no sea escribir la extensión ggplot2. Teniendo esto en cuenta, es útil comprender cómo ggplot2 usa ggproto:\n\nlas clases ggproto se usan selectivamente. El uso de ggproto en ggplot2 no lo abarca todo. Solo la funcionalidad seleccionada se basa en ggproto y no se espera ni se recomienda crear clases de ggproto completamente nuevas en sus extensiones. Como desarrollador de extensiones, nunca creará objetos ggproto completos, sino que creará una subclase de una de las clases principales de ggproto proporcionadas por ggplot2. Capítulo 20 y Capítulo 21 detallarán cómo hacer esto.\nlas clases ggproto no tienen estado. Excepto por unas pocas clases internas que se utilizan para orquestar la representación, se supone que las clases ggproto en ggplot2 son “sin estado”. Lo que esto significa es que ggplot2 espera que una vez construidos, no cambien. Esto rompe una expectativa común para las clases basadas en referencias (donde los métodos a menudo pueden cambiar de forma segura el estado del objeto), pero no es seguro hacerlo con ggplot2. Si su código viola este principio y cambia el estado de una Stat o Geom durante el renderizado, trazar un objeto ggplot guardado afectará todas las instancias de esa Stat o Geom (incluso aquellas utilizadas en otros gráficos) porque todas apuntan al mismo objeto padre ggproto. Teniendo esto en cuenta, sólo hay dos ocasiones en las que debes especificar el estado de un objeto ggproto en ggplot2. Primero, puede especificar el estado al crear el objeto: esto está bien porque este estado debe compartirse entre todas las instancias de todos modos. En segundo lugar, puede especificar el estado mediante un objeto de parámetros administrado en otro lugar. Como verá más adelante (ver Sección 20.2 y Sección 20.3), la mayoría de las clases de ggproto tienen un método setup_params() donde se pueden inspeccionar datos y calcular y almacenar propiedades específicas.\n\nlas clases ggproto tienen herencia simple. Debido a que las instancias de la clase ggproto no tienen estado, es relativamente seguro llamar a métodos definidos dentro de otras clases, en lugar de heredar explícitamente de la clase. Esta es la razón por la cual la función ggproto_parent() rara vez se llama dentro del código fuente de ggplot2. Como ejemplo, el método setup_params() en GeomErrorbar se define como:\n\nGeomErrorbar &lt;- ggproto(\n  # ...\n  setup_params = function(data, params) {\n    GeomLinerange$setup_params(data, params)\n  }\n  # ...\n)\n\nEste patrón suele ser más fácil de leer que usar ggproto_parent() y como los objetos ggproto no tienen estado, es igual de seguro.\n\n\n\n\n\n\nChang, Winston. 2020. R6: Encapsulated Classes with Reference Semantics. https://CRAN.R-project.org/package=R6.\n\n\nGrothendieck, Gabor, Louis Kates, y Thomas Petzoldt. 2016. proto: Prototype Object-Based Programming. https://CRAN.R-project.org/package=proto.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Internos de ggplot2</span>"
    ]
  },
  {
    "objectID": "internals.html#footnotes",
    "href": "internals.html#footnotes",
    "title": "19  Internos de ggplot2",
    "section": "",
    "text": "Por lo general, no se llama a este método plot() directamente, ya que lo invoca el método print y, por lo tanto, se llama cada vez que se imprime un objeto ggplot.↩︎\nEs posible que una estadística evite esta división sobrescribiendo métodos compute_*() específicos y así realizar cierta optimización.↩︎",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Internos de ggplot2</span>"
    ]
  },
  {
    "objectID": "extensions.html",
    "href": "extensions.html",
    "title": "20  Extendiendo ggplot2",
    "section": "",
    "text": "20.1 Nuevos temas\nEl paquete ggplot2 ha sido diseñado de una manera que hace que sea relativamente fácil ampliar la funcionalidad con nuevos tipos de componentes gramaticales comunes. El sistema de extensiones le permite distribuir estas extensiones como paquetes si así lo desea, pero la facilidad con la que se pueden crear extensiones significa que también es viable escribir extensiones únicas para resolver un desafío de trazado particular. Este capítulo analiza diferentes formas en que se puede ampliar ggplot2 y destaca cuestiones específicas a tener en cuenta. Presentaremos pequeños ejemplos a lo largo del capítulo, pero para ver un ejemplo trabajado de principio a fin, consulte Capítulo 21.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Extendiendo ggplot2</span>"
    ]
  },
  {
    "objectID": "extensions.html#nuevos-temas",
    "href": "extensions.html#nuevos-temas",
    "title": "20  Extendiendo ggplot2",
    "section": "",
    "text": "20.1.1 Modificando temas\nLos temas son probablemente la forma más sencilla de extensiones, ya que solo requieren que escribas el código que normalmente escribirías al crear gráficos con ggplot2. Si bien es posible crear un nuevo tema desde cero, normalmente es más fácil y menos propenso a errores modificar un tema existente. Este enfoque se adopta a menudo en la fuente ggplot2. Por ejemplo, aquí está el código fuente de theme_minimal():\n\ntheme_minimal &lt;- function(base_size = 11, \n                          base_family = \"\", \n                          base_line_size = base_size/22, \n                          base_rect_size = base_size/22) {\n    theme_bw(\n      base_size = base_size, \n      base_family = base_family, \n      base_line_size = base_line_size, \n      base_rect_size = base_rect_size\n    ) %+replace% \n    theme(\n      axis.ticks = element_blank(), \n      legend.background = element_blank(), \n      legend.key = element_blank(), \n      panel.background = element_blank(), \n      panel.border = element_blank(), \n      strip.background = element_blank(), \n      plot.background = element_blank(), \n      complete = TRUE\n    )\n}\n\nComo puede ver, el código no se ve muy diferente al código que normalmente escribe cuando diseña un gráfico (?sec-polish). La función theme_minimal() usa theme_bw() como tema base y luego reemplaza ciertas partes con su propio estilo usando el operador %+replace%. Al escribir temas nuevos, es una buena idea proporcionar algunos parámetros al usuario para definir aspectos generales del tema. Un aspecto importante es el tamaño del texto y las líneas, pero otros aspectos podrían ser, p.e. colores clave y de acento del tema. Por ejemplo, podríamos crear una variante de theme_minimal() que permita al usuario especificar el color de fondo de la trama:\ntheme_background &lt;- function(background = \"white\", ...) {\n  theme_minimal(...) %+replace%\n    theme(\n      plot.background = element_rect(\n        fill = background,\n        colour = background\n      ),\n      complete = TRUE\n    )\n}\n\nbase &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()\nbase + theme_minimal(base_size = 14)\nbase + theme_background(base_size = 14)\nbase + theme_background(base_size = 14, background = \"grey70\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n20.1.2 Temas completos\nUn punto importante a tener en cuenta es el uso de complete = TRUE en el código para theme_minimal() y theme_background(). Siempre es una buena práctica hacer esto al definir sus propios temas en un paquete de extensión ggplot2: esto asegurará que su tema se comporte de la misma manera que el tema predeterminado y, como consecuencia, será menos probable que sorprenda a los usuarios. Para ver por qué esto es necesario, compare estos dos temas:\n\n# Bueno \ntheme_predictable &lt;- function(...) {\n  theme_classic(...) %+replace% \n    theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\"),\n      complete = TRUE\n    )\n}\n\n# malo\ntheme_surprising &lt;- function(...) {\n  theme_classic(...) %+replace% \n    theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\")\n    )\n}\n\nAmbos temas están destinados a hacer lo mismo: cambiar los valores predeterminados a theme_classic() para que el eje x se dibuje con una línea azul y el eje y se dibuje con una línea naranja. A primera vista, parece que ambas versiones se comportan según las expectativas del usuario:\nbase + theme_classic()\nbase + theme_predictable()\nbase + theme_surprising()\n\n\n\n\n\n\n\n\n\n\n\n\n\nSin embargo, supongamos que el usuario de su tema quiere eliminar las líneas del eje:\nbase + theme_classic() + theme(axis.line = element_blank())\nbase + theme_predictable() + theme(axis.line = element_blank())\nbase + theme_surprising() + theme(axis.line = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\nEl comportamiento de theme_predictable() es el mismo que theme_classic() y las líneas del eje se eliminan, pero para theme_surprising() esto no sucede. La razón de esto es que ggplot2 trata los temas completos como una colección de valores “de respaldo”: cuando el usuario agrega theme(axis.line = element_blank()) a un tema completo, no hay necesidad de confiar en el valor de respaldo para axis.line.x o axis.line.y, porque se heredan de axis.line en el comando de usuario. Esto es una amabilidad para sus usuarios, ya que les permite sobrescribir todo lo que hereda de axis.line usando un comando como theme_predictable() + theme(axis.line = ...). Por el contrario, theme_surprising() no especifica un tema completo. Cuando el usuario llama a theme_surprising(), los valores alternativos se toman de theme_classic(), pero lo más importante es que ggplot2 trata el comando theme() que establece axis.line.x y axis.line.y exactamente como si el usuario lo hubiera escrito. En consecuencia, la especificación de la trama es equivalente a esto:\n\nbase + \n  theme_classic() +\n  theme(\n      axis.line.x = element_line(color = \"blue\"),\n      axis.line.y = element_line(color = \"orange\"),\n      axis.line = element_blank()\n  )\n\n\n\n\n\n\n\nEn este código, se aplica la regla de herencia específica primero y, como tal, la configuración axis.line no anula la regla más específica axis.line.x.\n\n20.1.3 Definición de elementos del tema\nEn ?sec-polising vimos que la estructura de un tema ggplot2 está definida por el árbol de elementos. El árbol de elementos especifica qué tipo tiene cada elemento del tema y de dónde hereda su valor (puede usar la función get_element_tree() para devolver este árbol como una lista). El sistema de extensión para ggplot2 hace posible definir nuevos elementos de tema registrándolos como parte del árbol de elementos usando la función register_theme_elements(). Digamos que estás escribiendo un nuevo paquete llamado “ggxyz” que incluye una anotación de panel como parte del sistema de coordenadas y quieres que esta anotación de panel sea un elemento del tema:\n\nregister_theme_elements(\n  ggxyz.panel.annotation = element_text(\n    color = \"blue\", \n    hjust = 0.95, \n    vjust = 0.05\n  ),\n  element_tree = list(\n    ggxyz.panel.annotation = el_def(\n      class = \"element_text\", \n      inherit = \"text\"\n    )\n  )\n)\n\nHay dos puntos a tener en cuenta aquí al definir nuevos elementos temáticos en un paquete:\n\nEs importante llamar a register_theme_elements() desde la función .onLoad() de tu paquete, para que los nuevos elementos del tema estén disponibles para cualquiera que use funciones de tu paquete, independientemente de si el paquete se ha adjuntado.\nSiempre es una buena idea incluir el nombre de su paquete como prefijo para cualquier elemento nuevo del tema. De esa manera, si alguien más escribe un paquete de anotaciones de panel ggabc, no habrá conflicto potencial entre los elementos del tema ggxyz.panel.annotation y ggabc.panel.annotation.\n\nUna vez que se haya actualizado el árbol de elementos, el paquete puede definir un nuevo sistema de coordenadas que utilice el nuevo elemento temático. Una forma sencilla de hacer esto es definir una función que cree una nueva instancia del objeto ggproto CoordCartesian. Hablaremos más sobre esto en Sección 20.4, pero por ahora basta con tener en cuenta que este código funcionará:\n\ncoord_annotate &lt;- function(label = \"panel annotation\") {\n  ggproto(NULL, CoordCartesian,\n          limits = list(x = NULL, y = NULL),\n          expand = TRUE,\n          default = FALSE,\n          clip = \"on\",\n          render_fg = function(panel_params, theme) {\n            element_render(\n              theme = theme, \n              element = \"ggxyz.panel.annotation\", \n              label = label\n            )\n          }\n  )\n}\n\nEntonces ahora esto funciona:\nbase + coord_annotate(\"annotation in blue\")\nbase + coord_annotate(\"annotation in blue\") + theme_dark()\n\n\n\n\n\n\n\n\n\n\n\n\n\nHabiendo modificado el árbol de elementos, vale la pena mencionar que la función reset_theme_settings() restaura el árbol de elementos predeterminado, descarta todas las definiciones de elementos nuevos y (a menos que esté desactivada) restablece el tema actualmente activo al valor predeterminado.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Extendiendo ggplot2</span>"
    ]
  },
  {
    "objectID": "extensions.html#sec-new-stats",
    "href": "extensions.html#sec-new-stats",
    "title": "20  Extendiendo ggplot2",
    "section": "\n20.2 Nuevas estadísticas",
    "text": "20.2 Nuevas estadísticas\nPuede parecer sorprendente, pero crear nuevas estadísticas es una de las formas más útiles de ampliar las capacidades de ggplot2. Cuando los usuarios agregan nuevas capas a un gráfico, con mayor frecuencia usan una función geom, por lo que es tentador como desarrollador pensar que su extensión ggplot2 debería encapsularse como una nueva geom. Hasta cierto punto, esto es cierto, ya que sus usuarios probablemente querrán usar una función de geom, pero en realidad la variedad entre diferentes geoms se debe principalmente a la variedad de diferentes estadísticas. Uno de los beneficios de trabajar con estadísticas es que se trata únicamente de transformaciones de datos. La mayoría de los usuarios y desarrolladores de R se sienten muy cómodos con la transformación de datos, lo que facilita la tarea de definir una nueva estadística. Siempre que el comportamiento deseado pueda encapsularse en una estadística, no hay necesidad de manipular ninguna llamada a la grilla.\n\n20.2.1 Creando estadísticas\nComo se analiza en Capítulo 19, el comportamiento principal de una estadística se captura mediante una sucesión escalonada de llamadas a compute_layer(), compute_panel() y compute_group(), todos los cuales son métodos asociados con el Objeto ggproto que define la estadística. De forma predeterminada, las dos funciones principales no hacen mucho, simplemente dividen los datos y luego los pasan a la siguiente función:\n\n\ncompute_layer() divide los datos establecidos por la columna PANEL, llama a compute_panel() y vuelve a ensamblar los resultados.\n\ncompute_panel() divide los datos del panel por la columna group, llama a compute_group() y vuelve a ensamblar los resultados.\n\nDebido a esto, el único método que normalmente necesitas especificar como desarrollador es la función compute_group(), cuyo trabajo es tomar los datos de un único grupo y transformarlos apropiadamente. Esto será suficiente para crear una estadística funcional, aunque es posible que no produzca el mejor rendimiento. Como consecuencia, a veces los desarrolladores encuentran valioso descargar parte del trabajo a compute_panel() siempre que sea posible: hacerlo permite vectorizar los cálculos y evitar un costoso paso de división-combinación (veremos un ejemplo de esto más adelante en (seg-primavera-estadística?)). Sin embargo, como regla general es mejor comenzar modificando compute_group() únicamente y ver si el rendimiento es el adecuado.\nPara ilustrar esto, comenzaremos creando una estadística que calcule el casco convexo de un conjunto de puntos, usando la función chull() incluida en grDevices. Como es de esperar, la mayor parte del trabajo lo realiza un nuevo objeto ggproto que crearemos:\n\nStatChull &lt;- ggproto(\"StatChull\", Stat,\n  compute_group = function(data, scales) {\n    data[chull(data$x, data$y), , drop = FALSE]\n  },\n  required_aes = c(\"x\", \"y\")\n)\n\nComo se describe en Sección 19.4, los dos primeros argumentos de ggproto() se usan para indicar que este objeto define una nueva clase (convenientemente llamada \"StatChull\") que hereda campos y métodos del objeto Stat. Luego especificamos solo aquellos campos y métodos que deben modificarse con respecto a los valores predeterminados proporcionados por Stat, en este caso compute_group() y required_aes. Nuestra función compute_group() toma dos entradas, data y scales—porque esto es lo que ggplot2 espera—pero el cálculo real depende sólo de los data. Tenga en cuenta que debido a que el cálculo necesariamente requiere que ambas estéticas de posición estén presentes, también hemos especificado el campo required_aes para asegurarnos de que ggplot2 sepa que estas estéticas son requeridas.\nAl crear este objeto ggproto tenemos una estadística funcional, pero aún no le hemos dado al usuario una forma de acceder a ella. Para solucionar esto escribimos una función de capa, stat_chull(). Todas las funciones de capa tienen la misma forma: usted especifica los valores predeterminados en los argumentos de la función y luego llama a layer(), enviando ... al argumento params. Los argumentos en ... serán argumentos para la geom (si estás creando un contenedor de estadísticas), argumentos para la estadística (si estás creando un contenedor de geom) o la estética que se establecerá. layer() se encarga de separar los diferentes parámetros y asegurarse de que estén almacenados en el lugar correcto. Entonces nuestra función stat_chull() se ve así\n\nstat_chull &lt;- function(mapping = NULL, data = NULL, \n                       geom = \"polygon\", position = \"identity\", \n                       na.rm = FALSE, show.legend = NA, \n                       inherit.aes = TRUE, ...) {\n  layer(\n    stat = StatChull, \n    data = data, \n    mapping = mapping, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\ny nuestra estadística ahora se puede utilizar en gráficos:\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  stat_chull(fill = NA, colour = \"black\")\n\nggplot(mpg, aes(displ, hwy, colour = drv)) + \n  geom_point() + \n  stat_chull(fill = NA)\n\n\n\n\n\n\n\n\n\n\nAl crear nuevas estadísticas, suele ser una buena idea proporcionar un constructor geom_*() adjunto, así como el constructor stat_*(), porque la mayoría de los usuarios están acostumbrados a agregar capas de trazado con geoms en lugar de estadísticas. Mostraremos cómo se vería una función geom_chull() en Sección 20.3.\nTenga en cuenta que no siempre es posible definir el constructor geom_*() de forma sensata. Esto puede suceder cuando no hay una geom predeterminada obvia para la nueva estadística, o si la estadística pretende ofrecer una ligera modificación a un par de geom/stat existente. En tales casos, puede ser aconsejable proporcionar sólo una función stat_*().\n\n20.2.2 Modificar parámetros y datos\nAl definir nuevas estadísticas, a menudo es necesario especificar las funciones setup_params() y/o setup_data(). Estos se llaman antes de las funciones compute_*() y permiten que la estadística reaccione y se modifique en respuesta a los parámetros y datos (especialmente los datos, ya que no están disponibles cuando se construye la estadística):\n\nPrimero se llama a la función setup_params(). Toma dos argumentos correspondientes a la capa data y una lista de parámetros (params) especificados durante la construcción, y devuelve una lista modificada de parámetros que se utilizarán en cálculos posteriores. Debido a que los parámetros son utilizados por las funciones compute_*(), los elementos de la lista deben corresponder a los nombres de los argumentos en las funciones compute_*() para que estén disponibles.\nA continuación se llama a la función setup_data(). También toma data y params como entrada, aunque los parámetros que recibe son los parámetros modificados devueltos desde setup_params(), y devuelve los datos de la capa modificada. Es importante que no importa qué modificaciones ocurran en setup_data() las columnas PANEL y group permanezcan intactas.\n\nEn el siguiente ejemplo, mostramos cómo utilizar el método setup_params() para definir una nueva estadística. Más adelante se incluye un ejemplo de modificación del método setup_data(), en Sección 20.3.2.\nSupongamos que queremos crear StatDensityCommon, una estadística que calcula una estimación de densidad de una variable después de estimar un ancho de banda predeterminado para aplicar a todos los grupos de los datos. Esto se puede hacer de muchas maneras diferentes, pero para simplificar, imaginemos que tenemos una función common_bandwidth() que estima el ancho de banda por separado para cada grupo usando la función bw.nrd0() y luego devuelve el promedio:\n\ncommon_bandwidth &lt;- function(data) {\n  split_data &lt;- split(data$x, data$group)\n  bandwidth &lt;- mean(vapply(split_data, bw.nrd0, numeric(1)))\n  return(bandwidth)\n}\n\nLo que queremos de StatDensityCommon es usar la función common_bandwith() para establecer un ancho de banda común antes de que los datos se separen por grupo y se pasen a la función compute_group(). Aquí es donde el método setup_params() resulta útil:\n\nStatDensityCommon &lt;- ggproto(\"StatDensityCommon\", Stat,\n  required_aes = \"x\",\n  \n  setup_params = function(data, params) {\n    if(is.null(params$bandwith)) {\n      params$bandwidth &lt;- common_bandwidth(data)\n      message(\"Picking bandwidth of \", signif(params$bandwidth, 3))\n    }\n    return(params)\n  },\n    \n  compute_group = function(data, scales, bandwidth = 1) {\n    d &lt;- density(data$x, bw = bandwidth)\n    return(data.frame(x = d$x, y = d$y))\n  }  \n)\n\nLuego definimos una función stat_*() de la forma habitual:\n\nstat_density_common &lt;- function(mapping = NULL, data = NULL, \n                                geom = \"line\", position = \"identity\", \n                                na.rm = FALSE, show.legend = NA, \n                                inherit.aes = TRUE, bandwidth = NULL, ...) {\n  layer(\n    stat = StatDensityCommon, \n    data = data, \n    mapping = mapping, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      bandwidth = bandwidth, \n      na.rm = na.rm,\n      ...\n    )\n  )\n}\n\nAhora podemos aplicar nuestra nueva estadística\n\nggplot(mpg, aes(displ, colour = drv)) + \n  stat_density_common()\n#&gt; Picking bandwidth of 0.345",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Extendiendo ggplot2</span>"
    ]
  },
  {
    "objectID": "extensions.html#sec-new-geoms",
    "href": "extensions.html#sec-new-geoms",
    "title": "20  Extendiendo ggplot2",
    "section": "\n20.3 Nuevos geoms",
    "text": "20.3 Nuevos geoms\nSi bien se pueden lograr muchas cosas creando nuevas estadísticas, hay situaciones en las que es necesario crear una nueva geom. Algunos de estos son\n\nNo tiene sentido devolver datos de la estadística en una forma que sea comprensible para cualquier geom actual.\nLa capa necesita combinar la salida de múltiples geoms.\nLa geom necesita devolver grobs que actualmente no están disponibles en las geoms existentes.\n\nCrear nuevas geoms puede resultar un poco más desalentador que crear nuevas estadísticas, ya que el resultado final es una colección de grobs en lugar de un marco de datos modificado y esto es algo fuera de la zona de confort de muchos desarrolladores. Aún así, aparte del último punto anterior, es posible arreglárselas sin tener que pensar demasiado en la cuadrícula y los grobs.\n\n20.3.1 Modificar los valores predeterminados de la geom\nEn muchas situaciones, su nueva geom puede ser simplemente una geom existente que espera entradas ligeramente diferentes o tiene valores de parámetros predeterminados diferentes. El ejemplo stat_chull() de la sección anterior es un buen ejemplo de esto. Tenga en cuenta que al crear gráficos usando stat_chull() teníamos que especificar manualmente los parámetros fill y color si no estaban asignados a la estética. La razón de esto es que GeomPolygon crea un polígono relleno sin bordes de forma predeterminada, y esto no se adapta bien a las necesidades de nuestra geom de casco convexo. Para hacernos la vida un poco más fácil, podemos crear una subclase de GeomPolygon que modifique los valores predeterminados para que produzca un polígono hueco de forma predeterminada. Podemos hacer esto de forma sencilla anulando el valor default_aes:\n\nGeomPolygonHollow &lt;- ggproto(\"GeomPolygonHollow\", GeomPolygon,\n  default_aes = aes(\n    colour = \"black\", \n    fill = NA, \n    linewidth = 0.5,\n    linetype = 1,\n    alpha = NA\n  )\n)\n\nAhora podemos definir nuestra función constructora geom_chull() usando GeomPolygonHollow como geom predeterminado:\n\ngeom_chull &lt;- function(mapping = NULL, data = NULL, stat = \"chull\",\n                       position = \"identity\", na.rm = FALSE, \n                       show.legend = NA, inherit.aes = TRUE, ...) {\n  layer(\n    geom = GeomPolygonHollow, \n    data = data, \n    mapping = mapping, \n    stat = stat, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes,\n    params = list(na.rm = na.rm, ...)\n  )\n} \n\nEn aras de la coherencia, también definiríamos stat_chull() para usarlo como valor predeterminado. En cualquier caso, ahora tenemos una nueva función geom_chull() que funciona bastante bien sin que el usuario necesite configurar parámetros:\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_chull() +\n  geom_point()\n\n\n\n\n\n\n\n\n20.3.2 Modificando datos de geom\nEn otros casos, es posible que desee definir una geom que sea visualmente equivalente a una geom existente, pero que acepte datos en un formato diferente. Un ejemplo de esto en el código fuente de ggplot2 es geom_spoke(), una variación de geom_segment() que acepta datos en coordenadas polares. Para que esto funcione, el objeto ggproto GeomSpoke tiene una subclase de GeomSegment y utiliza el método setup_data() para tomar datos de coordenadas polares del usuario y luego transformarlos al formato que espera GeomSegment. Para ilustrar esta técnica, crearemos geom_spike(), una geom que vuelve a implementar la funcionalidad de geom_spoke(). Esto requiere que sobrescribamos el campo required_aes así como el método setup_data():\n\nGeomSpike &lt;- ggproto(\"GeomSpike\", GeomSegment,\n  \n  # Especificar la estética requerida                   \n  required_aes = c(\"x\", \"y\", \"angle\", \"radius\"),\n  \n  # Transforme los datos antes de realizar cualquier dibujo\n  setup_data = function(data, params) {\n    transform(data,\n      xend = x + cos(angle) * radius,\n      yend = y + sin(angle) * radius\n    )\n  }\n)\n\nAhora escribimos la función geom_spike() frente al usuario:\n\ngeom_spike &lt;- function(mapping = NULL, data = NULL, \n                       stat = \"identity\", position = \"identity\", \n                       ..., na.rm = FALSE, show.legend = NA, \n                       inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    geom = GeomSpike, \n    stat = stat, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\nAhora podemos usar geom_spike() en los gráficos:\n\ndf &lt;- data.frame(\n  x = 1:10,\n  y = 0,\n  angle = seq(from = 0, to = 2 * pi, length.out = 10),\n  radius = seq(from = 0, to = 2, length.out = 10)\n)\nggplot(df, aes(x, y)) +\n  geom_spike(aes(angle = angle, radius = radius)) + \n  coord_equal()\n\n\n\n\n\n\n\nAl igual que con las estadísticas, las geoms tienen un método setup_params() además del método setup_data(), que se puede utilizar para modificar los parámetros antes de realizar cualquier dibujo (consulte Sección 20.2.2 para ver un ejemplo). Sin embargo, una cosa a tener en cuenta en el contexto geom es que se llama a setup_data() antes de realizar cualquier ajuste de posición.\n\n20.3.3 Combinando múltiples geoms\nUna técnica útil para definir nuevas geoms es combinar la funcionalidad de diferentes geoms. Por ejemplo, la función geom_smooth() para dibujar líneas de regresión no paramétricas usa la funcionalidad de geom_line() para dibujar la línea de regresión y geom_ribbon() para dibujar las bandas de error sombreadas. Para hacer esto dentro de su nueva geom, es útil considerar el proceso de dibujo. De la misma manera que una estadística funciona mediante una sucesión escalonada de llamadas a compute_layer(), luego a compute_panel() y finalmente a compute_group(), una geom se construye mediante llamadas a draw_layer(), draw_panel (), y draw_group().\nSi desea combinar la funcionalidad de varias geoms, generalmente puede lograrlo preparando los datos para cada una de las geoms dentro de la llamada draw_*() y enviándolos a las diferentes geoms, recopilando la salida usando grid:: gList() cuando se necesita una lista de grobs o grid::gTree() si se requiere un único grob con varios hijos. Como ejemplo relativamente mínimo, considere el objeto ggproto GeomBarbell que crea geoms que constan de dos puntos conectados por una barra:\n\nGeomBarbell &lt;- ggproto(\"GeomBarbell\", Geom,\n  \n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  \n  default_aes = aes(\n    colour = \"black\",\n    linewidth = .5,\n    size = 2,\n    linetype = 1,\n    shape = 19,\n    fill = NA,\n    alpha = NA,\n    stroke = 1\n  ),\n  \n  draw_panel = function(data, panel_params, coord, ...) {\n    \n    # Datos transformados para los puntos\n    point1 &lt;- transform(data) \n    point2 &lt;- transform(data, x = xend, y = yend)    \n    \n    # Devolver los tres componentes\n    grid::gList(\n      GeomSegment$draw_panel(data, panel_params, coord, ...),\n      GeomPoint$draw_panel(point1, panel_params, coord, ...),\n      GeomPoint$draw_panel(point2, panel_params, coord, ...)\n    )\n  }\n) \n\nEn este ejemplo, el método draw_panel() devuelve una lista de tres grobs, uno generado a partir de GeomSegment y dos de GeomPoint. Como es habitual, si queremos que la geom esté expuesta al usuario, agregamos una función contenedora:\n\ngeom_barbell &lt;- function(mapping = NULL, data = NULL, \n                         stat = \"identity\", position = \"identity\", \n                         ..., na.rm = FALSE, show.legend = NA, \n                         inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomBarbell, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(na.rm = na.rm, ...)\n  )\n}\n\nAhora podemos utilizar la geom compuesta:\ndf &lt;- data.frame(x = 1:10, xend = 0:9, y = 0, yend = 1:10)\nbase &lt;- ggplot(df, aes(x, y, xend = xend, yend = yend))\n\nbase + geom_barbell()\nbase + geom_barbell(shape = 4, linetype = \"dashed\")  \n\n\n\n\n\n\n\n\n\n\nSi no puede aprovechar ninguna implementación de geom existente para crear los grobs, tendrá que implementar el método draw_*() completo desde cero, lo que requiere un poco más de comprensión del paquete grid. Para obtener más información sobre la cuadrícula y un ejemplo que usa esto para construir una geom a partir de primitivas de cuadrícula, consulte Capítulo 21.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Extendiendo ggplot2</span>"
    ]
  },
  {
    "objectID": "extensions.html#sec-new-coords",
    "href": "extensions.html#sec-new-coords",
    "title": "20  Extendiendo ggplot2",
    "section": "\n20.4 Nuevas coordenadas",
    "text": "20.4 Nuevas coordenadas\nLa función principal de la coord es reescalar la estética de la posición en el rango [0, 1], transformándola potencialmente en el proceso. Definir nuevas coordenadas es relativamente raro: las coordenadas descritas en Capítulo 15 son adecuadas para la mayoría de los casos no cartográficos, y con la introducción de coord_sf() discutida en Capítulo 6, ggplot2 es capaz de capturar la mayoría de las proyecciones cartográficas. De la caja.\nLa situación más común en la que los desarrolladores pueden necesitar conocer los aspectos internos de los sistemas de coordenadas es al definir nuevas geoms. No es raro que uno de los métodos draw_*() en una geom llame al método transform() de la coord. Por ejemplo, el método transform() para CoordCartesian se usa para cambiar la escala de los datos de posición pero no los transforma de ninguna otra manera, y es posible que el geom necesite aplicar este cambio de escala para dibujar el grob correctamente. Un ejemplo de este uso aparece en Capítulo 21.\nAdemás de transformar los datos de posición, el coordinador tiene la responsabilidad de representar los ejes, las etiquetas de los ejes, el primer plano y el fondo del panel. Además, la coord puede interceptar y modificar los datos de la capa y el diseño de las facetas. Gran parte de esta funcionalidad está disponible para que los desarrolladores la aprovechen si es absolutamente necesaria (se muestra un ejemplo en Sección 20.1.3), pero en la mayoría de los casos es mejor dejar esta funcionalidad como está.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Extendiendo ggplot2</span>"
    ]
  },
  {
    "objectID": "extensions.html#sec-new-scales",
    "href": "extensions.html#sec-new-scales",
    "title": "20  Extendiendo ggplot2",
    "section": "\n20.5 Nuevas escalas",
    "text": "20.5 Nuevas escalas\nHay tres formas en las que uno podría querer extender ggplot2 con nuevas escalas. El caso más simple es cuando desea proporcionar un envoltorio conveniente para una nueva paleta, generalmente para una estética de color o relleno. Como ejemplo poco práctico, supongamos que desea tomar muestras de colores aleatorios para llenar un violín o un diagrama de caja, utilizando una función de paleta como esta:\n\nrandom_colours &lt;- function(n) {\n  sample(colours(distinct = TRUE), n, replace = TRUE)\n} \n\nLuego podemos escribir una función constructora scale_fill_random() que pase la paleta a discrete_scale() y luego usarla en los gráficos:\n\nscale_fill_random &lt;- function(..., aesthetics = \"fill\") {\n  discrete_scale(\n    aesthetics = aesthetics, \n    scale_name = \"random\", \n    palette = random_colours\n  )\n}\n\nggplot(mpg, aes(hwy, class, fill = class)) + \n  geom_violin(show.legend = FALSE) +\n  scale_fill_random()\n#&gt; Warning: The `scale_name` argument of `discrete_scale()` is deprecated as of ggplot2\n#&gt; 3.5.0.\n\n\n\n\n\n\n\nOtro caso relativamente simple es cuando proporcionas una geom que requiere un nuevo tipo de estética que necesita ser ampliada. Digamos que creaste una nueva línea geom y en lugar de la estética de size decidiste usar una estética de with. Para poder escalar el with de la misma manera que esperas la escala del size, debes proporcionar una escala predeterminada para la estética. Las escalas predeterminadas se encuentran según su nombre y el tipo de datos proporcionados a la estética. Si asigna valores continuos a la estética de with, ggplot2 buscará una función scale_width_continuous() y la usará si no se ha agregado otra escala de ancho al gráfico. Si no se encuentra dicha función (y no se agregó explícitamente ninguna escala de ancho), la estética no se escalará.\nUna última posibilidad que vale la pena mencionar, pero fuera del alcance de este libro, es la posibilidad de crear un nuevo tipo de escala primaria. Históricamente, ggplot2 ha tenido dos tipos de escala principales, continua y discreta. Recientemente se unió el tipo de escala agrupada que permite agrupar datos continuos en contenedores discretos. Es posible desarrollar más escalas primarias siguiendo el ejemplo de ScaleBinned. Requiere subclasificar Scale o una de las escalas primarias proporcionadas, y crear nuevos métodos train() y map(), entre otros.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Extendiendo ggplot2</span>"
    ]
  },
  {
    "objectID": "extensions.html#nuevas-posiciones",
    "href": "extensions.html#nuevas-posiciones",
    "title": "20  Extendiendo ggplot2",
    "section": "\n20.6 Nuevas posiciones",
    "text": "20.6 Nuevas posiciones\nLa clase ggproto Position es algo más simple que otras clases ggproto, lo que refleja el hecho de que las funciones position_*() tienen un alcance muy limitado. La función del puesto es recibir y modificar los datos inmediatamente antes de pasarlos a cualquier función de dibujo. Estrictamente hablando, la posición puede modificar los datos de cualquier forma, pero existe una expectativa implícita de que sólo modifica la estética de la posición. Una posición posee métodos compute_layer() y compute_panel() que se comportan de manera análoga a los métodos equivalentes para una estadística, pero no posee un método compute_group(). También contiene los métodos setup_params() y setup_data() que son similares a los métodos setup_*() para otras clases de ggproto, con una excepción notable: el método setup_params() solo recibe los datos como entrada, y no una lista de parámetros. La razón de esto es que las funciones position_*() nunca se usan solas en ggplot2: más bien, siempre se llaman dentro del comando principal geom_*() o stat_*() que especifica la capa y los parámetros del comando principal no se pasan a la llamada de función position_*().\nPara dar un ejemplo simple, implementaremos una versión ligeramente simplificada de la función position_jitternormal() del paquete ggforce, que se comporta de la misma manera que position_jitter() excepto que las perturbaciones se muestrean a partir de una distribución normal en lugar de que una distribución uniforme. Para mantener la exposición simple, asumiremos que tenemos definida la siguiente función de conveniencia:\n\nnormal_transformer &lt;- function(x, sd) {\n  function(x) {x + rnorm(length(x), sd = sd)}\n}\n\nCuando se llama, normal_transformer() devuelve una función que perturba el vector de entrada agregando ruido aleatorio con media cero y desviación estándar sd. El primer paso al crear nuestra nueva posición es crear una subclase del objeto Position:\n\nPositionJitterNormal &lt;- ggproto('PositionJitterNormal', Position,\n           \n  # Necesitamos una estética de posición xey                              \n  required_aes = c('x', 'y'),\n  \n  # Al usar el argumento \"self\" podemos acceder a los parámetros que el \n  # usuario ha pasado a la posición y agregarlos como parámetros de capa.\n  setup_params = function(self, data) {\n    list(\n      sd_x = self$sd_x, \n      sd_y = self$sd_y\n    )\n  },\n\n  # Al calcular la capa, podemos leer los parámetros de desviación estándar \n  # de la lista de parámetros y usarlos para transformar la estética de la \n  # posición.\n  compute_layer = function(data, params, panel) {\n    \n    # construir transformadores para las escalas de posición x e y \n    x_transformer &lt;- normal_transformer(x, params$sd_x)\n    y_transformer &lt;- normal_transformer(y, params$sd_y)\n    \n    # devolver los datos transformados\n    transform_position(\n      df = data,\n      trans_x = x_transformer,  \n      trans_y = y_transformer\n    )\n  }\n)\n\nEl método compute_layer() hace uso de transform_position(), una función conveniente proporcionada por ggplot2 cuya función es aplicar las funciones proporcionadas por el usuario a toda la estética asociada con la escala de posición relevante (por ejemplo, no solo x e y, pero también xend y yend).\nEn una implementación realista, el constructor position_jitternormal() aplicaría alguna validación de entrada para asegurarse de que el usuario no haya especificado desviaciones estándar negativas, pero en este contexto lo mantendremos simple:\n\nposition_jitternormal &lt;- function(sd_x = .15, sd_y = .15) {\n  ggproto(NULL, PositionJitterNormal, sd_x = sd_x, sd_y = sd_y)\n}\n\nAhora podemos utilizar nuestra nueva función de posición al crear gráficos. Para ver la diferencia entre position_jitter() y la función position_jitternormal() que acabamos de definir, compare los siguientes gráficos:\ndf &lt;- data.frame(\n  x = sample(1:3, 1500, TRUE),\n  y = sample(1:3, 1500, TRUE)\n)\n\nggplot(df, aes(x, y)) + geom_point(position = position_jitter())\nggplot(df, aes(x, y)) + geom_point(position = position_jitternormal())\n\n\n\n\n\n\n\n\n\n\nUna consideración práctica a tener en cuenta al diseñar nuevas posiciones es que los usuarios rara vez llaman directamente al constructor de posiciones. Es más probable que el comando que especifica la capa incluya una expresión como position = \"dodge\" en lugar de position = position_dodge(), y es incluso menos probable que anule los valores predeterminados, como ocurriría si el usuario especificara position = position_dodge (width = 0,9). Como consecuencia, es importante pensar detenidamente y, si es posible, hacer que los valores predeterminados funcionen en la mayoría de los casos. Esto puede ser bastante complicado: las posiciones tienen muy poco control sobre la forma y el formato de los datos de la capa, pero el usuario esperará que se comporten de manera predecible en todas las situaciones. Un ejemplo es el caso de esquivar, donde a los usuarios les gustaría esquivar un diagrama de caja y una nube de puntos, y esperarían que la nube de puntos apareciera en la misma área que su diagrama de caja respectivo. Esta es una expectativa perfectamente razonable a nivel de usuario, pero puede resultar complicada para el desarrollador. Un diagrama de caja tiene un ancho explícito que se puede usar para controlar la esquiva, mientras que no ocurre lo mismo con los puntos, pero el usuario esperará que se muevan de la misma manera. Estas consideraciones a menudo significan que las implementaciones de posiciones terminan siendo mucho más complejas que su solución más simple para atender una amplia gama de casos extremos.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Extendiendo ggplot2</span>"
    ]
  },
  {
    "objectID": "extensions.html#nuevas-facetas",
    "href": "extensions.html#nuevas-facetas",
    "title": "20  Extendiendo ggplot2",
    "section": "\n20.7 Nuevas facetas",
    "text": "20.7 Nuevas facetas\nLas facetas son uno de los conceptos más poderosos de ggplot2, y extenderlas es una de las formas más poderosas de modificar el funcionamiento de ggplot2. Este poder tiene un coste: las facetas se encargan de recibir todos los paneles, unirles los ejes y las tiras y luego disponerlos de la manera esperada. Crear un sistema de facetado completamente nuevo requiere un conocimiento profundo de grid y gtable, y puede ser un desafío desalentador. Afortunadamente, no siempre es necesario crear la faceta desde cero. Por ejemplo, si su nueva faceta producirá paneles que se encuentran en una cuadrícula, a menudo puede subclasificar FacetWrap o FacetGrid y modificar uno o dos métodos. En particular, es posible que desees definir nuevos métodos compute_layout() y/O map_data():\n\nEl método compute_layout() recibe el conjunto de datos original y crea una especificación de diseño, un marco de datos con una fila por panel que indica dónde cae cada panel en la cuadrícula, junto con información sobre qué límites de eje deben estar libres y cuáles deben estar libres. fijado.\nEl método map_data() recibe esta especificación de diseño y los datos originales como entrada, y le adjunta una columna PANEL, que se utiliza para asignar cada fila en el marco de datos a uno de los paneles en el diseño.\n\nPara ilustrar cómo se pueden crear nuevas facetas subclasificando una faceta existente, crearemos un sistema de facetas relativamente simple que “scatter” los paneles, colocándolos en ubicaciones aleatorias en una cuadrícula. Para hacer esto, crearemos un nuevo objeto ggproto llamado FacetScatter que es una subclase de FacetWrap y escribiremos un nuevo método compute_layout() que coloca cada panel en una celda elegida al azar de la cuadrícula de paneles:\n\nFacetScatter &lt;- ggproto(\"FacetScatter\", FacetWrap,\n  \n  # Esto no es importante para el ejemplo: todo lo que\n  # estamos haciendo es forzar a todos los paneles a usar\n  # una escala fija para que el resto del ejemplo se pueda\n  # mantener simple.\n  setup_params = function(data, params) {\n    params &lt;- FacetWrap$setup_params(data, params)\n    params$free &lt;- list(x = FALSE, y = FALSE)\n    return(params)\n  },                      \n  \n  # El método compute_layout() hace el trabajo.\n  compute_layout = function(data, params) {\n                  \n    # cree un marco de datos con una columna por variable \n    # de faceta y una fila para cada combinación posible \n    # de valores (es decir, una fila por panel)\n    panels &lt;- combine_vars(\n      data = data,\n      env = params$plot_env, \n      vars = params$facets, \n      drop = FALSE\n    )\n    \n    # Cree un marco de datos con columnas para ROW y COL,\n    # con una fila para cada celda posible en la cuadrícula\n    # del panel\n    locations &lt;- expand.grid(ROW = 1:params$nrow, COL = 1:params$ncol)\n    \n    # Muestrear aleatoriamente un subconjunto de las\n    # ubicaciones\n    shuffle &lt;- sample(nrow(locations), nrow(panels))\n    \n    # Asigne a cada panel una ubicación                     \n    layout &lt;- data.frame(\n      PANEL = 1:nrow(panels),       # identificador de panel\n      ROW = locations$ROW[shuffle], # número de fila para los paneles\n      COL = locations$COL[shuffle], # número de columna para los paneles\n      SCALE_X = 1L,                 # todas las escalas del eje x son fijas\n      SCALE_Y = 1L                  # todas las escalas del eje y son fijas\n    )\n    \n    # Vincule la información de diseño con la identificación del panel y \n    # devuelva la especificación resultante.\n    return(cbind(layout, panels))\n  }                      \n)\n\nPara darle una idea de cómo se ve este resultado, esta es la especificación de diseño que se crea al construir el gráfico que se muestra al final de esta sección:\n\n#&gt;    PANEL ROW COL SCALE_X SCALE_Y manufacturer\n#&gt; 1      1   4   1       1       1         audi\n#&gt; 2      2   5   5       1       1    chevrolet\n#&gt; 3      3   5   1       1       1        dodge\n#&gt; 4      4   5   3       1       1         ford\n#&gt; 5      5   1   5       1       1        honda\n#&gt; 6      6   4   4       1       1      hyundai\n#&gt; 7      7   3   5       1       1         jeep\n#&gt; 8      8   2   2       1       1   land rover\n#&gt; 9      9   5   2       1       1      lincoln\n#&gt; 10    10   4   5       1       1      mercury\n#&gt; 11    11   2   4       1       1       nissan\n#&gt; 12    12   5   4       1       1      pontiac\n#&gt; 13    13   3   2       1       1       subaru\n#&gt; 14    14   5   6       1       1       toyota\n#&gt; 15    15   4   6       1       1   volkswagen\n\nA continuación, escribiremos la función constructora facet_scatter() para exponer esta funcionalidad al usuario. Para las facetas, esto es tan simple como crear una nueva instancia del objeto ggproto relevante (FacetScatter en este caso) que pasa parámetros especificados por el usuario a la faceta:\n\nfacet_scatter &lt;- function(facets, nrow, ncol, \n                          strip.position = \"top\", \n                          labeller = \"label_value\") {\n  \n  ggproto(NULL, FacetScatter, \n    params = list(\n      facets = rlang::quos_auto_name(facets),\n      strip.position = strip.position,\n      labeller = labeller, \n      ncol = ncol, \n      nrow = nrow\n    )\n  )\n}\n\nHay un par de cosas a tener en cuenta sobre esta función constructora. Primero, para mantener el ejemplo simple, facet_scatter() contiene menos argumentos que facet_wrap(), y hemos creado argumentos obligatorios para nrow y ncol: el usuario necesita especificar el tamaño de la cuadrícula sobre la cual los paneles deben estar dispersos. En segundo lugar, la función facet_scatter() requiere que especifiques las facetas usando vars(). No funcionará si el usuario intenta proporcionar una fórmula. De manera relacionada, tenga en cuenta el uso de rlang::quos_auto_name(): la función vars() devuelve una lista de expresiones sin nombre (técnicamente, quosures), pero el código posterior requiere una lista con nombre. Mientras espere que el usuario use vars(), este es todo el preprocesamiento que necesita, pero si desea admitir otros formatos de entrada, deberá ser un poco más sofisticado (puede ver cómo hacerlo). mirando el código fuente de ggplot2).\nEn cualquier caso, ya tenemos un lado de trabajo:\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  facet_scatter(vars(manufacturer), nrow = 5, ncol = 6)",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Extendiendo ggplot2</span>"
    ]
  },
  {
    "objectID": "ext-springs.html",
    "href": "ext-springs.html",
    "title": "21  Un caso de estudio",
    "section": "",
    "text": "21.1 ¿Qué es un resorte?\nCapítulo 20 proporcionó una descripción general de alto nivel sobre la creación de extensiones de ggplot2, basándose en la discusión sobre los aspectos internos de ggplot2 en Capítulo 19. En este capítulo llevaremos ese conocimiento un paso más allá, brindando una inmersión más profunda en el proceso de desarrollo de extensiones con todas las funciones. Para hacer esto, tomaremos un solo ejemplo (construir una nueva geom que parece un resorte) y lo seguiremos durante todo el proceso de desarrollo.\nEste es un ejemplo cuidadosamente elaborado. Es poco probable que desee utilizar resortes para visualizar sus datos, por lo que ggplot2 aún no proporciona una geom de resorte. Sin embargo, los resortes son lo suficientemente complicados como para ilustrar las partes más importantes del proceso. ¡Esto los hace ideales para nuestros propósitos!\nDesarrollaremos la ampliación en cinco fases:\nUna vez que haya recorrido este capítulo, le recomendamos encarecidamente que explore el código fuente de ggplot2 para ver cómo se implementan otras estadísticas y geoms. A menudo serán más complicados de lo que necesitas, pero te darán una idea de lo que puedes hacer.\nEl desarrollo de una extensión generalmente comienza con una idea de lo que quieres dibujar. En este caso, queremos dibujar un resorte entre dos puntos, por lo que necesitamos algún código que dibuje un resorte que parezca plausible. Probablemente haya muchas formas de hacer esto, pero una sencilla es dibujar un círculo mientras se mueve el “bolígrafo” en una dirección. Aquí hay un conjunto de datos que define un círculo usando 100 puntos:\ncircle &lt;- tibble(\n  radians = seq(0, 2 * pi, length.out = 100),\n  x = cos(radians),\n  y = sin(radians),\n  index = 1:100,\n  type = \"circle\"\n)\n\nggplot(circle, aes(x = x, y = y, alpha = -index)) + \n  geom_path(show.legend = FALSE) + \n  coord_equal()\nPara transformar este círculo en un resorte que se extiende a lo largo del eje x usando dplyr, podríamos hacer algo como esto:\nspring &lt;- circle %&gt;% \n  mutate(\n    motion = seq(0, 1, length.out = 100),\n    x = x + motion,\n    type = \"spring\"\n  )\n\nggplot(spring, aes(x = x, y = y, alpha = -index)) + \n  geom_path(show.legend = FALSE) + \n  coord_equal()\nEn este caso, nuestro “resorte” sólo ha dado vueltas una vez, y no se parece mucho a un resorte real, pero si siguiéramos trazando el círculo mientras nos movemos a lo largo del eje x, terminaríamos con un resorte con múltiples bucles. Cuanto más rápido movamos el “bolígrafo”, más estiraremos el resorte. Esto nos da una idea de los dos parámetros que caracterizan nuestros resortes:\nAunque probablemente esta no sea una parametrización físicamente correcta de los resortes en el mundo real, es lo suficientemente buena para nuestros propósitos.\nAhora que tenemos un método para dibujar resortes, vale la pena dedicar un poco de tiempo a pensar en lo que requerirá una geom basada en este método. El código que hemos escrito hasta este punto está perfectamente bien para un solo gráfico, pero hay nuevas preguntas a considerar al crear una extensión:\nConsideraremos estas preguntas a medida que avancemos en el capítulo.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Un caso de estudio</span>"
    ]
  },
  {
    "objectID": "ext-springs.html#sec-intuitive-spring",
    "href": "ext-springs.html#sec-intuitive-spring",
    "title": "21  Un caso de estudio",
    "section": "",
    "text": "El diameter del resorte, definido por el tamaño del círculo.\nLa tension del resorte, definida por la rapidez con la que nos movemos a lo largo de x.\n\n\n\n\n¿Cómo especificaremos el diámetro de un resorte?\n¿Cómo mantenemos los círculos circulares incluso cuando cambiamos la relación de aspecto de la gráfica?\n¿Podemos asignar diámetro y tensión a variables en los datos?\n¿El diámetro y la tensión deberían ser parámetros que deben ser los mismos para todos los resortes en una capa o deberían ser una estética escalada que pueda variar de un resorte a otro?\nSi planeamos distribuir nuestro spring geom a otros usuarios de R, ¿queremos depender del paquete dplyr?",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Un caso de estudio</span>"
    ]
  },
  {
    "objectID": "ext-springs.html#sec-spring-stat",
    "href": "ext-springs.html#sec-spring-stat",
    "title": "21  Un caso de estudio",
    "section": "\n21.2 Parte 1: una estadística",
    "text": "21.2 Parte 1: una estadística\nComencemos a convertir esta idea en una extensión de ggplot2. Debido a que estamos creando una extensión que dibuja una nueva capa ggplot2, debemos decidir si el objeto ggproto que creamos debe ser Stat o Geom. Quizás sea sorprendente que esta decisión no esté guiada por si queremos terminar con geom_spring() o stat_spring(): hay muchas extensiones Stat que se usan a través de un constructor geom_*() . Una mejor manera de pensar en esta decisión es considerar si podemos usar una geom existente con datos transformados. En ese caso, podemos usar una Stat que suele ser más sencilla de codificar que una Geom.\nEl código que escribimos en la última sección se ajusta muy bien a esta descripción. Lo único que hacemos es dibujar un camino, pero damos vueltas en lugar de ir en línea recta. Eso sugiere que podemos usar una Stat que transforma los datos y luego usa GeomPath para encargarse del dibujo real.\n\n21.2.1 Funcionalidad del edificio\nSiempre que esté desarrollando una nueva Stat, una estrategia sensata es comenzar escribiendo la función de transformación de datos y luego, una vez que esté funcionando, incorporarla a un ggproto Stat. En este caso, vamos a necesitar una función create_spring() que tome un punto inicial, un punto final, un diámetro y una tensión. Más precisamente:\n\nNuestro punto de partida estará definido por los argumentos x e y.\nNuestro punto final estará definido por los argumentos xend y yend.\nEl argumento diameter se utilizará para escalar el tamaño de nuestro círculo.\nDefinir tension es un poco más complicado. La cantidad que realmente queremos expresar es “qué tan lejos se mueve el resorte en relación con el tamaño de los círculos”. Entonces definiremos tension para referirnos a la distancia total movida desde el punto inicial hasta el punto final, dividida por el tamaño de los círculos.1\n\nTambién tendremos un parámetro n para dar el número de puntos utilizados por revolución, definiendo la fidelidad visual del resorte.\n\nAhora podemos escribir código para nuestra función create_spring():\n\ncreate_spring &lt;- function(x, \n                          y, \n                          xend, \n                          yend, \n                          diameter = 1, \n                          tension = 0.75, \n                          n = 50) {\n  \n  # Validar los argumentos de entrada.\n  if (tension &lt;= 0) {\n    rlang::abort(\"`tension` debe ser mayor que cero.\")\n  }\n  if (diameter == 0) {\n    rlang::abort(\"`diameter` no puede ser cero.\")\n  }\n  if (n == 0) {\n    rlang::abort(\"`n` debe ser mayor que cero.\")\n  }\n  \n  # Calcule la longitud directa de la trayectoria del resorte\n  length &lt;- sqrt((x - xend)^2 + (y - yend)^2)\n  \n  # Calcular el número de revoluciones y puntos que necesitamos\n  n_revolutions &lt;- length / (diameter * tension)\n  n_points &lt;- n * n_revolutions\n  \n  # Calcule la secuencia de radianes y los valores de compensación de x e y\n  radians &lt;- seq(0, n_revolutions * 2 * pi, length.out = n_points)\n  x &lt;- seq(x, xend, length.out = n_points)\n  y &lt;- seq(y, yend, length.out = n_points)\n  \n  # Crear y devolver el marco de datos transformado.\n  data.frame(\n    x = cos(radians) * diameter/2 + x,\n    y = sin(radians) * diameter/2 + y\n  )\n}\n\nEsta función conserva la lógica del código Spring que escribimos en Sección 21.1, pero hace algunas cosas nuevas que son muy importantes al escribir extensiones:\n\nEs preciso al especificar los parámetros que definen el resorte.\nComprueba explícitamente la entrada y utiliza rlang::abort() para generar un error si el usuario pasa un valor no válido a la función.\nUtiliza funciones base R para hacer el trabajo: no hay código dplyr en esta función porque no queremos que nuestra Stat dependa de dplyr.2\n\n\nLo bueno de escribir create_spring() como función es que podemos probarla3 para convencernos de que la lógica funciona:\n\nspring &lt;- create_spring(\n  x = 4, y = 2, xend = 10, yend = 6,\n  diameter = 2, tension = 0.6, n = 50\n)\n\nggplot(spring) + \n  geom_path(aes(x = x, y = y)) + \n  coord_equal()\n\n\n\n\n\n\n\n\n21.2.2 Creando la estadística\nAhora que tenemos nuestra función de transformación, nuestra siguiente tarea es encapsularla en una Stat. Para hacer esto, tomaremos lo que aprendimos sobre la creación de objetos Stat en Sección 20.2 y lo ampliaremos un poco. Nuestro primer paso es escribir un código que cree una subclase de Stat a la que llamaremos StatSpring:\n\nStatSpring &lt;- ggproto(\"StatSpring\", Stat)\n\nEsto crea una nueva subclase Stat llamada StatSpring. Esta clase no hace nada interesante en este momento: lo único que hace este código hasta ahora es darle un nombre a la clase.4 Para que esto sea útil, necesitaremos especificar los métodos que incorporar la funcionalidad que deseamos. En Sección 20.2 creamos una Stat anulando el método predeterminado compute_group() y el campo predeterminado para required_aes,5 pero los objetos Stat tienen muchas propiedades que puedes modificar. Si imprimimos el objeto Stat, podemos ver una lista de esas propiedades:\n\nStat\n#&gt; &lt;ggproto object: Class Stat, gg&gt;\n#&gt;     aesthetics: function\n#&gt;     compute_group: function\n#&gt;     compute_layer: function\n#&gt;     compute_panel: function\n#&gt;     default_aes: uneval\n#&gt;     dropped_aes: \n#&gt;     extra_params: na.rm\n#&gt;     finish_layer: function\n#&gt;     non_missing_aes: \n#&gt;     optional_aes: \n#&gt;     parameters: function\n#&gt;     required_aes: \n#&gt;     retransform: TRUE\n#&gt;     setup_data: function\n#&gt;     setup_params: function\n\nPuedes modificar casi cualquiera de estos: los únicos que no debes tocar son aesthetics y parameters, que están destinados únicamente para uso interno.\nPara nuestro ejemplo de StatSpring, los tres métodos/campos que necesitaremos especificar son setup_data(), compute_panel() y required_aes. Analizaremos esto con más detalle en la siguiente sección, pero para ayudarlo a ver a qué apuntamos, aquí está el código completo de nuestra estadística:\n\nStatSpring &lt;- ggproto(\"StatSpring\", Stat, \n  \n  # Edite los datos de entrada para garantizar que los identificadores de grupo sean únicos\n  setup_data = function(data, params) {\n    if (anyDuplicated(data$group)) {\n      data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n    }\n    data\n  },\n  \n  # Construya datos para este panel llamando a create_spring()\n  compute_panel = function(data, \n                           scales, \n                           diameter = 1, \n                           tension = 0.75, \n                           n = 50) {\n    cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n    springs &lt;- lapply(\n      seq_len(nrow(data)), \n      function(i) {\n        spring_path &lt;- create_spring(\n          data$x[i], \n          data$y[i], \n          data$xend[i], \n          data$yend[i], \n          diameter = diameter, \n          tension = tension, \n          n = n\n        )\n        cbind(spring_path, unclass(data[i, cols_to_keep]))\n      }\n    )\n    do.call(rbind, springs)\n  },\n  \n  # Especificar qué estética se requiere entrada\n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\")\n)\n\nWPodemos imprimir cualquiera de estos métodos con un comando como StatSpring$compute_panel o StatSpring$setup_data.\n\n21.2.3 Métodos\nEchemos un vistazo más de cerca a los métodos definidos para nuestro StatSpring. Como se analiza en Sección 20.2, los métodos más importantes para una estadística son los tres métodos compute_*. Siempre se debe definir uno de estos, generalmente compute_group() o compute_panel(). Como regla general, si la estadística opera en varias filas, comenzamos implementando un método compute_group(), y si la estadística opera en filas individuales, implementamos un método compute_panel(). Nuestra estadística de resorte es del último tipo: cada resorte está definido por una sola fila de datos originales, por lo que usaremos el método compute_panel() que recibe todos los datos de un solo panel.\nComo puedes ver al mirar el código fuente de nuestro método compute_panel(), estamos haciendo un poco más que simplemente llamar a nuestra función create_spring():\n\nfunction(data, scales, diameter = 1, tension = 0.75, n = 50) {\n  cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n  springs &lt;- lapply(\n    seq_len(nrow(data)), \n    function(i) {\n      spring_path &lt;- create_spring(\n        data$x[i], \n        data$y[i], \n        data$xend[i], \n        data$yend[i], \n        diameter = diameter, \n        tension = tension, \n        n = n\n      )\n      cbind(spring_path, unclass(data[i, cols_to_keep]))\n    }\n  )\n  do.call(rbind, springs)\n}\n\nUsamos lapply() para recorrer cada fila de datos y crear los puntos necesarios para dibujar el resorte correspondiente. Para cada uno de estos resortes, usamos cbind() para combinar los datos del resorte con todas las columnas que no son de posición de la fila de entrada. Esto es muy importante, ya que de lo contrario las asignaciones estéticas a p.e. El color y el tamaño se perderían. Finalmente, debido a que la salida de lapply() es una lista de marcos de datos (uno por primavera), usamos rbind() para combinarlos en un único marco de datos que se devuelve.\nAl definir una nueva estadística, es muy común especificar uno o ambos métodos setup_data() y setup_params(). Estos métodos se invocan al principio del proceso de construcción de la gráfica, por lo que puede utilizarlos para realizar comprobaciones y modificaciones tempranas de los parámetros y datos.\nPara nuestro ejemplo StatSpring, utilizamos el método setup_data() para garantizar que cada fila de entrada tenga una estética de grupo única. Esto es importante porque vamos a dibujar nuestros resortes con GeomPath y debemos asegurarnos de que el marco de datos generado por la estadística tenga un identificador único para cada resorte. Al hacerlo, se garantiza que la geom dibuje cada resorte como un camino distinto y no dibuje ninguna línea de conexión entre diferentes resortes. Nuevamente, hay algunos detalles sutiles sobre los que llamar la atención en la implementación:\n\nfunction(data, params) {\n  if (anyDuplicated(data$group)) {\n    data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n  }\n  data\n}\n\nTenga en cuenta que esta implementación conserva el valor original de data$group y agrega una identificación única si es necesario. Esto es importante porque la estética del grupo a veces se utiliza para transportar metadatos y no queremos perder esa información.\nLa parte final de nuestra nueva clase es el campo required_aes. Este es un vector de caracteres que proporciona los nombres de la estética que el usuario debe proporcionar a la estadística. En este caso, debemos asegurarnos de que el usuario especifique cuatro posiciones estéticas: x e y definen dónde comienza el resorte, mientras que xend y yend definen dónde termina. El campo required_aes, junto con default_aes y non_missing_aes, también define la estética que comprende esta estadística. Cualquier estética que no aparezca en estos campos (o en los campos del geom correspondiente) generará una advertencia y el mapeo será ignorado.\n\n21.2.4 Constructores\nAhora que tenemos nuestro objeto ggproto StatSpring, es hora de escribir funciones constructoras con las que el usuario interactuará. Estrictamente hablando, no necesitamos hacer esto, porque geom_path(stat = \"spring\") ya funcionará, pero es una buena práctica escribir funciones constructoras para comodidad de los usuarios. Además, la función constructora proporciona un buen lugar para documentar la nueva funcionalidad.\nQuizás sea sorprendente que los objetos de estadísticas casi siempre estén emparejados con un constructor geom_*() porque la mayoría de los usuarios de ggplot2 están acostumbrados a agregar geoms, no estadísticas, cuando construyen una gráfica. El constructor en sí es principalmente código repetitivo que envuelve una llamada a layer(); solo tenga cuidado de hacer coincidir el orden de los argumentos y los nombres utilizados en los constructores de ggplot2 para no sorprender a sus usuarios.\n\ngeom_spring &lt;- function(mapping = NULL,\n                        data = NULL, \n                        stat = \"spring\",\n                        position = \"identity\", \n                        ..., \n                        diameter = 1, \n                        tension = 0.75,\n                        n = 50, \n                        arrow = NULL, \n                        lineend = \"butt\", \n                        linejoin = \"round\",\n                        na.rm = FALSE, \n                        show.legend = NA, \n                        inherit.aes = TRUE\n                        ) {\n  layer(\n    data = data,\n    mapping = mapping,\n    stat = stat,\n    geom = GeomPath,\n    position = position,\n    show.legend = show.legend,\n    inherit.aes = inherit.aes,\n    params = list(\n      diameter = diameter,\n      tension = tension,\n      n = n,\n      arrow = arrow,\n      lineend = lineend,\n      linejoin = linejoin,\n      na.rm = na.rm,\n      ...\n    )\n  )\n}\n\nPara que esté completo, también debes crear una función constructora stat_*(). No hay sorpresas aquí: stat_spring() es muy similar a geom_spring() excepto que proporciona una geom predeterminada en lugar de una estadística predeterminada.\n\nstat_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        geom = \"path\", \n                        position = \"identity\", \n                        ..., \n                        diameter = 1, \n                        tension = 0.75, \n                        n = 50, \n                        na.rm = FALSE, \n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = StatSpring, \n    geom = geom, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      diameter = diameter, \n      tension = tension, \n      n = n, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\n\n21.2.5 Probando la estadística\nAhora que todo está en su lugar, podemos probar nuestra nueva capa:\n\ndf &lt;- tibble(\n  x = runif(5, max = 10),\n  y = runif(5, max = 10),\n  xend = runif(5, max = 10),\n  yend = runif(5, max = 10),\n  class = sample(letters[1:2], 5, replace = TRUE)\n)\n\nggplot(df) + \n  geom_spring(aes(x = x, y = y, xend = xend, yend = yend)) +\n  coord_equal()\n\n\n\n\n\n\n\nEsto se ve bastante bien. Los usuarios pueden llamar a nuestra función constructora geom_spring() y obtener resultados sensatos. Mejor aún, debido a que hemos escrito una nueva estadística, obtenemos una serie de funciones de forma gratuita, como escalado y facetado:\n\nggplot(df) + \n  geom_spring(\n    aes(x, y, xend = xend, yend = yend, colour = class),\n    linewidth = 1\n  ) +\n  coord_equal() + \n  facet_wrap(~ class)\n\n\n\n\n\n\n\nLos usuarios también tienen la opción de llamar al constructor stat_spring(), lo que puede ser útil si por alguna razón quieren dibujar los resortes con puntos en lugar de rutas:\n\nggplot(df) + \n  stat_spring(\n    aes(x, y, xend = xend, yend = yend, colour = class),\n    geom = \"point\", \n    n = 15\n  ) +\n  coord_equal() + \n  facet_wrap(~ class)\n\n\n\n\n\n\n\n\n21.2.6 Post mortem\nAhora hemos creado con éxito nuestra primera extensión. Funciona, pero tiene algunas limitaciones en las que ahora debemos pensar.\nUna desventaja de nuestra implementación es que el diámetro y la tensión son constantes que sólo se pueden establecer para la capa completa. Estas configuraciones se parecen más a la estética y sería bueno si sus valores pudieran asignarse a una variable en los datos. Discutiremos soluciones a este problema en Sección 21.3 y Sección 21.4.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Un caso de estudio</span>"
    ]
  },
  {
    "objectID": "ext-springs.html#sec-spring2",
    "href": "ext-springs.html#sec-spring2",
    "title": "21  Un caso de estudio",
    "section": "\n21.3 Part 2: Añadiendo estética",
    "text": "21.3 Part 2: Añadiendo estética\nLa estadística que creamos en la última sección trata el diameter y la tension como argumentos constantes: no son estéticos y el usuario no puede asignarlos a una variable en los datos. Podemos solucionar este problema realizando algunos pequeños cambios en el código StatSpring:\n\nStatSpring &lt;- ggproto(\"StatSpring\", Stat,\n                      \n  setup_data = function(data, params) {\n    if (anyDuplicated(data$group)) {\n      data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n    }\n    data\n  },\n  \n  compute_panel = function(data, scales, n = 50) {\n    cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n    springs &lt;- lapply(seq_len(nrow(data)), function(i) {\n      spring_path &lt;- create_spring(\n        data$x[i], \n        data$y[i], \n        data$xend[i], \n        data$yend[i], \n        data$diameter[i],\n        data$tension[i], \n        n\n      )\n      cbind(spring_path, unclass(data[i, cols_to_keep]))\n    })\n    do.call(rbind, springs)\n  },\n  \n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  optional_aes = c(\"diameter\", \"tension\")\n)\n\nLa principal diferencia con nuestro intento anterior es que los argumentos diameter y tension de compute_panel() han desaparecido y ahora se toman de los datos (al igual que x, y, etc.) . Esto tiene un inconveniente que solucionaremos en Sección 21.4: ya no podemos establecer una estética fija. Debido a esto, necesitaremos eliminar esos argumentos de la función constructora:\n\ngeom_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        stat = \"spring\", \n                        position = \"identity\", \n                        ..., \n                        n = 50, \n                        arrow = NULL, \n                        lineend = \"butt\", \n                        linejoin = \"round\", \n                        na.rm = FALSE,\n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomPath, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      n = n, \n      arrow = arrow, \n      lineend = lineend, \n      linejoin = linejoin, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\nEl constructor stat_spring() requeriría el mismo tipo de cambio.\nTodo lo que queda es probar nuestra nueva implementación:\n\ndf &lt;- tibble(\n  x = runif(5, max = 10),\n  y = runif(5, max = 10),\n  xend = runif(5, max = 10),\n  yend = runif(5, max = 10),\n  class = sample(letters[1:2], 5, replace = TRUE),\n  tension = runif(5),\n  diameter = runif(5, 0.5, 1.5)\n)\n\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(aes(tension = tension, diameter = diameter))\n\n\n\n\n\n\n\nParece funcionar. Sin embargo, como esperábamos, ya no es posible establecer diameter y tension como parámetros:\n\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(diameter = 0.5)\n#&gt; Warning in geom_spring(diameter = 0.5): Ignoring unknown parameters: `diameter`\n#&gt; Warning: Computation failed in `stat_spring()`.\n#&gt; Caused by error in `if (tension &lt;= 0) ...`:\n#&gt; ! argument is of length zero\n\n\n\n\n\n\n\n\n21.3.1 Post mortem\nEn esta sección desarrollamos aún más nuestra estadística de resortes para que el diameter y la tension puedan usarse como estética, variando entre resortes. Desafortunadamente, existe un gran inconveniente: estas funciones ya no se pueden configurar globalmente. También nos falta una forma de controlar la escala de las dos estéticas. Solucionar ambos problemas requiere el mismo siguiente paso: alejar nuestra implementación de Stat y acercarla a una adecuada Geom.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Un caso de estudio</span>"
    ]
  },
  {
    "objectID": "ext-springs.html#sec-spring3",
    "href": "ext-springs.html#sec-spring3",
    "title": "21  Un caso de estudio",
    "section": "\n21.4 Parte 3: Una geoma",
    "text": "21.4 Parte 3: Una geoma\nEn muchos casos, un enfoque centrado en las estadísticas es suficiente; por ejemplo, muchas de las primitivas gráficas proporcionadas por el paquete ggforce son estadísticas. Pero necesitamos ir más allá con la geom del resorte porque la estética de la tension y el diameter deben especificarse en unidades que no están relacionadas con el sistema de coordenadas. En consecuencia, reescribiremos nuestra geom para que sea una extensión Geom adecuada.\n\n21.4.1 Extensiones de geom\nComo se analizó en Capítulo 20, existen muchas similitudes entre las extensiones Stat y Geom. La mayor diferencia es que las extensiones Stat devuelven una versión modificada de los datos de entrada, mientras que las extensiones Geom devuelven objetos gráficos. En algunos casos, crear una nueva geom requiere que uses el paquete grid (cubriremos esto en Sección 21.6), pero a menudo no es necesario.\nAl igual que los objetos de estadísticas, los objetos geom en ggproto tienen varios métodos y campos que puedes modificar. Puedes ver la lista imprimiendo el objeto:\n\nGeom\n#&gt; &lt;ggproto object: Class Geom, gg&gt;\n#&gt;     aesthetics: function\n#&gt;     default_aes: uneval\n#&gt;     draw_group: function\n#&gt;     draw_key: function\n#&gt;     draw_layer: function\n#&gt;     draw_panel: function\n#&gt;     extra_params: na.rm\n#&gt;     handle_na: function\n#&gt;     non_missing_aes: \n#&gt;     optional_aes: \n#&gt;     parameters: function\n#&gt;     rename_size: FALSE\n#&gt;     required_aes: \n#&gt;     setup_data: function\n#&gt;     setup_params: function\n#&gt;     use_defaults: function\n\n\n21.4.2 Creando la geom\nDe la misma manera que una estadística usa los métodos compute_layer(), compute_panel() y compute_group() para transformar los datos, una geom usa draw_layer(), draw_panel() y draw_group() para crear representaciones gráficas de los datos. De la misma manera que creamos StatSpring escribiendo un método compute_panel() para hacer el trabajo pesado, crearemos GeomSpring escribiendo un método draw_panel():\n\nGeomSpring &lt;- ggproto(\"GeomSpring\", Geom,\n  \n  # Asegúrese de que cada fila tenga una identificación de grupo única\n  setup_data = function(data, params) {\n    if (is.null(data$group)) {\n      data$group &lt;- seq_len(nrow(data))\n    }\n    if (anyDuplicated(data$group)) {\n      data$group &lt;- paste(data$group, seq_len(nrow(data)), sep = \"-\")\n    }\n    data\n  },\n  \n  # Transforma los datos dentro del método draw_panel()\n  draw_panel = function(data, \n                        panel_params, \n                        coord, \n                        n = 50, \n                        arrow = NULL,\n                        lineend = \"butt\", \n                        linejoin = \"round\", \n                        linemitre = 10,\n                        na.rm = FALSE) {\n    \n    # Transforme los datos de entrada para especificar las rutas del resorte.\n    cols_to_keep &lt;- setdiff(names(data), c(\"x\", \"y\", \"xend\", \"yend\"))\n    springs &lt;- lapply(seq_len(nrow(data)), function(i) {\n      spring_path &lt;- create_spring(\n        data$x[i], \n        data$y[i], \n        data$xend[i], \n        data$yend[i], \n        data$diameter[i],\n        data$tension[i], \n        n\n      )\n      cbind(spring_path, unclass(data[i, cols_to_keep]))\n    })\n    springs &lt;- do.call(rbind, springs)\n    \n    # Utilice el método draw_panel() de GeomPath para hacer el dibujo\n    GeomPath$draw_panel(\n      data = springs, \n      panel_params = panel_params, \n      coord = coord, \n      arrow = arrow, \n      lineend = lineend, \n      linejoin = linejoin, \n      linemitre = linemitre, \n      na.rm = na.rm\n    )\n  },\n  \n  # Especificar la estética predeterminada y requerida\n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  default_aes = aes(\n    colour = \"black\", \n    linewidth = 0.5, \n    linetype = 1L, \n    alpha = NA, \n    diameter = 1, \n    tension = 0.75\n  )\n)\n\nA pesar de la extensión de este código, la mayor parte resulta familiar:\n\nLos métodos setup_data() son esencialmente los mismos: en ambos casos garantizan que cada fila de los datos de entrada tenga un identificador de grupo único.\nEl método draw_panel() para nuestro objeto GeomSpring es muy similar al método compute_panel(). La principal diferencia es que nuestro método draw_panel() tiene un paso adicional: pasa las coordenadas del resorte calculadas a GeomPath$draw_panel(). Debido a que los manantiales son simplemente caminos elegantes, el método GeomPath$draw_panel() funciona perfectamente bien aquí.\nA diferencia del código StatSpring que escribimos anteriormente, el código GeomSpring usa el campo default_aes para proporcionar valores predeterminados para cualquier estética que el usuario no especifique.\n\nUn aspecto de este código puede sorprender a los desarrolladores que están acostumbrados al diseño orientado a objetos en otros lenguajes. Llamar directamente al método de un objeto afín, como lo hacemos cuando invocamos GeomPath$draw_panel() desde GeomSpring$draw_panel(), no se considera una buena práctica en otros sistemas orientados a objetos. Sin embargo, debido a que los objetos ggproto no tienen estado (Sección 19.4.5), esto es exactamente tan seguro como subclasificar GeomPath y llamar al método principal. Puede ver este enfoque en todas partes del código fuente de ggplot2.\n\n21.4.3 un constructor\nAl igual que en nuestros intentos anteriores, el paso final es escribir una función constructora geom_spring(). El código no es muy diferente a las versiones anteriores: usamos GeomSpring en lugar de GeomPath, y usamos la estadística de identidad en lugar de StatSpring.\n\ngeom_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        stat = \"identity\", \n                        position = \"identity\", \n                        ..., \n                        n = 50, \n                        arrow = NULL, \n                        lineend = \"butt\", \n                        linejoin = \"round\", \n                        na.rm = FALSE,\n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomSpring, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      n = n, \n      arrow = arrow, \n      lineend = lineend, \n      linejoin = linejoin, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\n\n21.4.4 Probando la geom\nAhora tenemos una geom adecuada con una estética predeterminada funcional y la capacidad de establecer la estética como parámetros:\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(aes(tension = tension, diameter = diameter))\nggplot(df, aes(x, y, xend = xend, yend = yend)) + \n  geom_spring(diameter = 0.5)\n\n\n\n\n\n\n\n\n\n\nTodavía tiene algunas limitaciones, porque las unidades de diameter y tension se expresan en relación con la escala de los datos sin procesar. El diámetro real de un resorte con diameter = 0.5 será diferente dependiendo de los límites del eje, y si los ejes x e y no están en la misma escala, la forma del resorte se distorsionará. Puedes ver esto en el siguiente ejemplo:\n\nggplot() + \n  geom_spring(aes(x = 0, y = 0, xend = 3, yend = 20))\n\n\n\n\n\n\n\nEl mismo problema subyacente significa que el diámetro del resorte se expresa en el espacio de coordenadas. Esto hace que sea difícil definir un valor predeterminado significativo porque el tamaño absoluto del diámetro del resorte cambia cuando cambia la escala de los datos:\n\nggplot() + \n  geom_spring(aes(x = 0, y = 0, xend = 100, yend = 80))\n\n\n\n\n\n\n\nAbordaremos este problema en Sección 21.6.\n\n21.4.5 Post mortem\nEn esta sección finalmente creamos nuestra propia extensión Geom. Esta suele ser la conclusión natural del desarrollo de una nueva capa, pero no siempre. A veces encontrarás que el enfoque Stat funciona perfectamente para tus propósitos y tiene la ventaja de que puedes usar la estadística con múltiples geoms. La elección final depende de usted como desarrollador y debe guiarse por cómo espera que la gente use la capa.\nQuizás sea sorprendente que aún no hayamos hablado sobre lo que sucede dentro de los métodos draw_*(). Nuestro objeto GeomSpring se basa en el método draw_panel() de GeomPath para realizar el trabajo de crear la salida gráfica. Esto es bastante común. Por ejemplo, incluso el relativamente complejo GeomBoxplot simplemente usa los métodos de dibujo de GeomPoint(), GeomSegment y GeomCrossbar.\nSi necesita profundizar más, necesitará aprender un poco sobre la cuadrícula. La creación de grid grobs es una técnica avanzada, necesaria para relativamente pocas geoms. Pero crear un grob de cuadrícula le brinda el poder de usar unidades absolutas para el diámetro (por ejemplo, 1 cm) y ajustar la visualización del geom según el tamaño del dispositivo de salida. Nos ocuparemos de eso a continuación.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Un caso de estudio</span>"
    ]
  },
  {
    "objectID": "ext-springs.html#una-introducción-a-la-cuadrícula",
    "href": "ext-springs.html#una-introducción-a-la-cuadrícula",
    "title": "21  Un caso de estudio",
    "section": "\n21.5 Una introducción a la cuadrícula",
    "text": "21.5 Una introducción a la cuadrícula\nEl paquete grid proporciona el sistema de gráficos subyacente sobre el que se construye ggplot2. Es uno de los dos sistemas de dibujo bastante diferentes que se incluyen en base R: gráficos base y cuadrícula. Los gráficos básicos tienen un modelo imperativo de “lápiz sobre papel”: cada función dibuja inmediatamente algo en el dispositivo gráfico. Al igual que el propio ggplot2, grid adopta un enfoque más declarativo en el que se construye una descripción del gráfico como un objeto, que luego se representa. Este enfoque declarativo nos permite crear objetos que existen independientemente del dispositivo gráfico y que pueden transmitirse, analizarse y modificarse. Es importante destacar que partes de un objeto gráfico pueden hacer referencia a otras partes, lo que le permite hacer cosas como definir este rectángulo para que tenga un ancho igual a la longitud de esa cadena de texto, etc.\nComo desarrollador de ggplot2, descubrirá que puede lograr mucho sin necesidad de interactuar directamente con la cuadrícula, pero hay situaciones en las que es imposible lograr lo que desea sin bajar al nivel de la cuadrícula. Las dos situaciones más comunes son:\n\nNecesita crear objetos gráficos que estén ubicados correctamente en el sistema de coordenadas, pero donde alguna parte de su apariencia tenga un tamaño absoluto fijo. En nuestro caso, este sería el resorte yendo correctamente entre dos puntos en el gráfico, pero el diámetro definido en cm en lugar de en relación con el sistema de coordenadas.\nNecesita objetos gráficos que se actualicen durante el cambio de tamaño. Esto podría, por ejemplo. ser la posición de etiquetas como en el paquete ggrepel o los geoms geom_mark_*() en ggforce.\n\nUna introducción completa a grid es mucho más de lo que podemos cubrir en este libro, pero para ayudarlo a comenzar, le brindaremos el vocabulario mínimo absoluto para comprender cómo ggplot2 usa grid. Presentaremos conceptos básicos como grobs, ventanas gráficas, parámetros gráficos y unidades, pero lea R Graphics de Murrell (2018) para obtener todos los detalles.\n\n21.5.1 Grobs\nPara entender cómo funciona grid, lo primero que debemos hablar son grobs. Grobs (objetosgr**aficos) son representaciones atómicas de elementos gráficos en una cuadrícula e incluyen tipos como puntos, líneas, círculos, rectángulos y texto. El paquete grid proporciona funciones como pointsGrob(), linesGrob(), circleGrob(), rectGrob() y textGrob() que crean objetos gráficos sin dibujar nada en el dispositivo gráfico. Estas funciones están vectorizadas, lo que permite que un solo punto represente múltiples puntos, por ejemplo:\n\nlibrary(grid)\ncircles &lt;- circleGrob(\n  x = c(0.1, 0.4, 0.7), \n  y = c(0.5, 0.3, 0.6),\n  r = c(0.1, 0.2, 0.3)\n)\ncircles\n#&gt; circle[GRID.circle.582]\n\nTenga en cuenta que este código no dibuja nada: es sólo una descripción de un conjunto de círculos. Para dibujarlo, primero llamamos a grid.newpage() para borrar el dispositivo gráfico actual y luego grid.draw():\n\ngrid.newpage()\ngrid.draw(circles)\n\n\n\n\n\n\n\ngrid también proporciona grobTree(), que construye objetos compuestos a partir de múltiples grobs atómicos. Aquí hay una ilustración:\n\nlabels &lt;- textGrob(\n  label = c(\"small\", \"medium\", \"large\"),\n  x = c(0.1, 0.4, 0.7), \n  y = c(0.5, 0.3, 0.6),\n)\n\ncomposite &lt;- grobTree(circles, labels)\ngrid.newpage()\ngrid.draw(composite)\n\n\n\n\n\n\n\nTambién es posible definir sus propios grobs. Puede definir una nueva clase grob primitiva usando grob() o una nueva clase compuesta usando gTree(), luego especificar un comportamiento especial para su nueva clase. Veremos un ejemplo de esto en un momento.\n\n21.5.2 Ventanas gráficas\nEl segundo concepto clave en grid es la idea de una ventana gráfica. Una ventana gráfica es una región de trazado rectangular que proporciona su propio sistema de coordenadas para los objetos que se dibujan dentro de ella y también puede proporcionar una cuadrícula tabular en la que se pueden anidar otras ventanas gráficas. Un grob individual puede tener su propia ventana gráfica o, si no se proporciona ninguna, heredará una. Si bien no necesitaremos considerar las ventanas gráficas al construir el grob para nuestros resortes, son un concepto importante que impulsa gran parte del diseño de alto nivel de los gráficos ggplot2, por lo que los presentaremos aquí muy brevemente. En el siguiente ejemplo usamos viewport() para definir dos ventanas gráficas diferentes, una con parámetros predeterminados y la segunda que gira alrededor del punto medio 15 grados:\n\nvp_default &lt;- viewport()\nvp_rotated &lt;- viewport(angle = 15)\n\nEsta vez, cuando creemos nuestros grobs compuestos, los asignaremos explícitamente a ventanas gráficas específicas estableciendo el argumento vp:\n\ncomposite_default &lt;- grobTree(circles, labels, vp = vp_default)\ncomposite_rotated &lt;- grobTree(circles, labels, vp = vp_rotated)\n\nCuando trazamos estos dos grobs, podemos ver el efecto de la ventana gráfica: aunque composite_default y composite_rotated se componen de los mismos dos grobs primitivos (es decir, circles y labels), pertenecen a ventanas gráficas diferentes, por lo que se ven diferentes cuando se dibuja la gráfica:\n\ngrid.newpage()\ngrid.draw(composite_default)\ngrid.draw(composite_rotated)\n\n\n\n\n\n\n\nggplot2 genera automáticamente la mayoría de las ventanas gráficas que necesitará para trazar, pero es importante comprender la idea básica.\n\n21.5.3 Parámetros gráficos\nEl siguiente concepto que debemos comprender es la idea de parámetros gráficos. Cuando definimos los grobs circles y labels, solo especificamos algunas de sus propiedades. Por ejemplo, no dijimos nada sobre el color o la transparencia, por lo que todas estas propiedades están configuradas en sus valores predeterminados. La función gpar() en grid le permite especificar parámetros gráficos como objetos distintos:\n\ngp_blue &lt;- gpar(col = \"blue\", fill = NA)\ngp_orange &lt;- gpar(col = \"orange\", fill = NA)\n\nLos objetos gp_blue y gp_orange proporcionan listas de configuraciones gráficas que ahora se pueden aplicar a cualquier grob que queramos usando el argumento gp:\n\ngrob1 &lt;- grobTree(circles, labels, vp = vp_default, gp = gp_blue)\ngrob2 &lt;- grobTree(circles, labels, vp = vp_rotated, gp = gp_orange)\n\nCuando trazamos estos dos grobs, heredan la configuración proporcionada por los parámetros gráficos así como las ventanas gráficas a las que están asignados:\n\ngrid.newpage()\ngrid.draw(grob1)\ngrid.draw(grob2)\n\n\n\n\n\n\n\n\n21.5.4 Unidades\nEl último concepto central que debemos discutir es el sistema de unidades. El paquete grid le permite especificar las posiciones (por ejemplo, x e y) y las dimensiones (por ejemplo, length y width) de grobs y ventanas gráficas utilizando una especificación flexible. En el sistema de unidades de cuadrícula existen tres estilos de unidades cualitativamente diferentes:\n\nUnidades absolutas, p.e. centímetros, pulgadas y puntos se refieren a tamaños físicos.\nUnidades relativas, p. npc que representa una proporción del tamaño de la ventana gráfica actual.\nUnidades definidas por cadenas u otros grobs, p.e. strwidth, grobwidth.\n\nLa función unit() es la función principal que utilizamos al especificar unidades: unit(1, \"cm\") es 1 centímetro, mientras que unit(0.5, \"npc\") es la mitad del tamaño de la ventana gráfica correspondiente. . El sistema de unidades admite operaciones aritméticas que sólo se resuelven en el momento del sorteo, lo que permite combinar diferentes tipos de unidades: unidad(0.5, \"npc\") + unidad(1, \"cm\") define un punto a un centímetro de a la derecha del centro de la ventana gráfica actual.\n\n21.5.5 Construyendo clases grob\nAhora que tenemos una comprensión básica de la cuadrícula, intentemos crear nuestra propia clase grob “sorpresa”: objetos que son círculos si miden menos de 3 cm, pero se transforman en cuadrados cuando miden más de 3 cm. Este no es el tipo de objeto gráfico más útil, pero es útil para ilustrar la flexibilidad del sistema de cuadrícula. El primer paso es escribir nuestra propia función constructora usando grob() o gTree(), dependiendo de si estamos creando un objeto primitivo o compuesto. Comenzamos creando una función constructora “delgada”:\n\nsurpriseGrob &lt;- function(x, \n                         y, \n                         size, \n                         default.units = \"npc\", \n                         name = NULL, \n                         gp = gpar(), \n                         vp = NULL) {\n  \n  # Asegúrese de que los argumentos de entrada sean unidades\n  if (!is.unit(x)) x &lt;- unit(x, default.units)\n  if (!is.unit(y)) y &lt;- unit(y, default.units)\n  if (!is.unit(size)) size &lt;- unit(size, default.units)\n  \n  # Construya la subclase grob sorpresa como un gTree\n  gTree(\n    x = x, \n    y = y, \n    size = size, \n    name = name, \n    gp = gp, \n    vp = vp, \n    cl = \"surprise\"\n  )\n}\n\nEsta función no hace mucho. Todo lo que hace es garantizar que los argumentos x, y y size sean unidades de cuadrícula y establece que el nombre de la clase sea “sorpresa”. Para definir el comportamiento de nuestro grob, necesitamos especificar métodos para una o ambas funciones genéricas makeContext() y makeContent():\n\nmakeContext() se llama cuando se representa el grob principal y le permite controlar la ventana gráfica del grob. No necesitaremos usar eso para nuestra sorpresa.\nmakeContent() se llama cada vez que se cambia el tamaño de la región de dibujo y le permite personalizar el aspecto del grob según el tamaño u otro aspecto.\n\nDebido a que estas funciones genéricas utilizan el sistema de programación orientada a objetos S3, podemos definir nuestro método simplemente agregando el nombre de la clase al final del nombre de la función. Es decir, el método makeContent() para nuestro grob sorpresa se define creando una función llamada makeContent.surprise() que toma un grob como entrada y devuelve un grob modificado como salida:\n\nmakeContent.surprise &lt;- function(x) {\n  x_pos &lt;- x$x\n  y_pos &lt;- x$y\n  size &lt;- convertWidth(x$size, unitTo = \"cm\", valueOnly = TRUE)\n  \n  # Averigua si los tamaños dados son mayores o menores de 3 cm.\n  circles &lt;- size &lt; 3\n  \n  # Crea un círculo para los más pequeños.\n  if (any(circles)) {\n    circle_grob &lt;- circleGrob(\n      x = x_pos[circles], \n      y = y_pos[circles], \n      r = unit(size[circles] / 2, \"cm\")\n    )\n  } else {\n    circle_grob &lt;- NULL\n  }\n  \n  # Crea un grob recto para los grandes.\n  if (any(!circles)) {\n    square_grob &lt;- rectGrob(\n      x = x_pos[!circles], \n      y = y_pos[!circles], \n      width = unit(size[!circles], \"cm\"),\n      height = unit(size[!circles], \"cm\")\n    )\n  } else {\n    square_grob &lt;- NULL\n  }\n  \n  # Agregue el círculo y rectifique grob como hijos de nuestro grob de entrada\n  setChildren(x, gList(circle_grob, square_grob))\n}\n\nAlgunas de las funciones que hemos llamado aquí son nuevas, pero todas reutilizan los conceptos centrales que analizamos anteriormente. Específicamente:\n\n\nconvertWidth() se utiliza para convertir unidades de cuadrícula de un tipo a otro.\n\ngList() crea una lista de grobs.\n\nsetChildren() especifica los grobs que pertenecen a un grob compuesto de gTree.\n\nEl efecto de esta función es garantizar que cada vez que se renderiza el grob se recalcule el tamaño absoluto de cada forma. Todas las formas menores de 3 cm se convierten en círculos y todas las formas mayores de 3 cm se convierten en cuadrados. Para ver cómo se desarrolla esto, llamemos a nuestra nueva función:\n\nsurprises &lt;- surpriseGrob(\n  x = c(0.25, 0.45, 0.75), \n  y = c(0.5, 0.5, 0.5), \n  size = c(0.05, 0.15, 0.25)\n)\n\nEl grob surprises contiene tres formas cuyas ubicaciones y tamaños se han especificado en relación con el tamaño de la ventana gráfica. En este momento no tenemos idea de cuáles de estas formas serán círculos y cuáles serán cuadrados: eso depende del tamaño de la ventana gráfica en la que se dibujará el grob surprises. Ahora podemos dibujar el grob de la forma habitual:\n\ngrid.newpage()\ngrid.draw(surprises)\n\n\n\n\n\n\n\nSi ejecuta este código de forma interactiva y cambia el tamaño de la ventana de trazado, verá que los tres objetos cambian de forma según el tamaño de la ventana de trazado. Esta no es la forma más útil de emplear grid, por supuesto, pero esperamos que puedas ver cómo se puede utilizar esta técnica para realizar un trabajo real.\n\n21.5.6 Cuadrícula tabular\nEl último aspecto de grid que discutiremos aquí es el motor de diseño proporcionado por el paquete gtable. No es necesario saber acerca de gtable para construir nuestro spring grob, pero hay otros tipos de extensiones ggplot2 que sí requieren este conocimiento, por lo que brindaremos una breve descripción aquí.\nComo se discutió en Sección 19.3, cuando ggplot2 pasa el gráfico a la cuadrícula para renderizarlo, lo hace creando un objeto gtable con ggplot_gtable(). Podemos extraer este objeto usando la función ggplotGrob():\n\np &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()\ngrob_table &lt;- ggplotGrob(p)\ngrob_table\n#&gt; TableGrob (16 x 13) \"layout\": 22 grobs\n#&gt;     z         cells             name\n#&gt; 1   0 ( 1-16, 1-13)       background\n#&gt; 2   5 ( 8- 8, 6- 6)           spacer\n#&gt; 3   7 ( 9- 9, 6- 6)           axis-l\n#&gt; 4   3 (10-10, 6- 6)           spacer\n#&gt; 5   6 ( 8- 8, 7- 7)           axis-t\n#&gt; 6   1 ( 9- 9, 7- 7)            panel\n#&gt; 7   9 (10-10, 7- 7)           axis-b\n#&gt; 8   4 ( 8- 8, 8- 8)           spacer\n#&gt; 9   8 ( 9- 9, 8- 8)           axis-r\n#&gt; 10  2 (10-10, 8- 8)           spacer\n#&gt; 11 10 ( 7- 7, 7- 7)           xlab-t\n#&gt; 12 11 (11-11, 7- 7)           xlab-b\n#&gt; 13 12 ( 9- 9, 5- 5)           ylab-l\n#&gt; 14 13 ( 9- 9, 9- 9)           ylab-r\n#&gt; 15 14 ( 9- 9,11-11)  guide-box-right\n#&gt; 16 15 ( 9- 9, 3- 3)   guide-box-left\n#&gt; 17 16 (13-13, 7- 7) guide-box-bottom\n#&gt; 18 17 ( 5- 5, 7- 7)    guide-box-top\n#&gt; 19 18 ( 9- 9, 7- 7) guide-box-inside\n#&gt; 20 19 ( 4- 4, 7- 7)         subtitle\n#&gt; 21 20 ( 3- 3, 7- 7)            title\n#&gt; 22 21 (14-14, 7- 7)          caption\n#&gt;                                             grob\n#&gt; 1                rect[plot.background..rect.629]\n#&gt; 2                                 zeroGrob[NULL]\n#&gt; 3            absoluteGrob[GRID.absoluteGrob.618]\n#&gt; 4                                 zeroGrob[NULL]\n#&gt; 5                                 zeroGrob[NULL]\n#&gt; 6                       gTree[panel-1.gTree.610]\n#&gt; 7            absoluteGrob[GRID.absoluteGrob.614]\n#&gt; 8                                 zeroGrob[NULL]\n#&gt; 9                                 zeroGrob[NULL]\n#&gt; 10                                zeroGrob[NULL]\n#&gt; 11                                zeroGrob[NULL]\n#&gt; 12 titleGrob[axis.title.x.bottom..titleGrob.621]\n#&gt; 13   titleGrob[axis.title.y.left..titleGrob.624]\n#&gt; 14                                zeroGrob[NULL]\n#&gt; 15                                zeroGrob[NULL]\n#&gt; 16                                zeroGrob[NULL]\n#&gt; 17                                zeroGrob[NULL]\n#&gt; 18                                zeroGrob[NULL]\n#&gt; 19                                zeroGrob[NULL]\n#&gt; 20         zeroGrob[plot.subtitle..zeroGrob.626]\n#&gt; 21            zeroGrob[plot.title..zeroGrob.625]\n#&gt; 22          zeroGrob[plot.caption..zeroGrob.627]\n\nEl resultado ilustra cómo está estructurado el diseño de ggplot2. La gráfica se compone de 18 grobs distintos que están organizados en un TableGrob que especifica una cuadrícula de 12 x 9, que a su vez proporciona una colección de ventanas gráficas dentro de las cuales se pueden dibujar grobs individuales. Este TableGrob es en sí mismo un grobtree y se puede representar con grid llamando grid.draw():\n\ngrid.newpage()\ngrid.draw(grob_table)\n\n\n\n\n\n\n\nPara ilustrar cómo funciona TableGrob, crearemos una versión simplificada de este resultado sin usar ggplot2. Nuestro primer paso es definir los grobs constituyentes que componen nuestra gráfica:\n\nxtick &lt;- 0:8\nytick &lt;- seq(0, 50, 10)\n\npoints &lt;- pointsGrob(\n  x = mpg$displ / xtick[length(xtick)],\n  y = mpg$hwy / ytick[length(ytick)],\n  default.units = 'npc',\n  size = unit(6, 'pt')\n)\n\nxaxis &lt;- xaxisGrob(\n  at = seq(0, 1, length.out = length(xtick)), \n  label = xtick\n)\n\nyaxis &lt;- yaxisGrob(\n  at = seq(0, 1, length.out = length(ytick)), \n  label = ytick\n)\n\nEl grob points contiene los datos que se van a trazar, mientras que xaxis y yaxis son grobs que dibujan ejes etiquetados. Cuando dibujamos el grob de points, obtenemos el núcleo de un diagrama de dispersión:\n\ngrid.newpage()\ngrid.draw(points)\n\n\n\n\n\n\n\nSin embargo, si queremos agregar ejes a este gráfico, necesitamos un conjunto de ventanas gráficas dispuestas en formato tabular para que podamos colocar el xaxis inmediatamente debajo de los points y el yaxis a la izquierda de los points. En ggplot2, esto lo maneja el motor de diseño gtable. Primero, usamos gtable() para definir la estructura:\n\nlibrary(gtable)\n\nplot_layout &lt;- gtable(\n  widths = unit(c(1.5, 0, 1, 0.5), c('cm', 'cm', 'null', 'cm')),\n  heights = unit(c(0.5, 1, 0, 1.5), c('cm', 'null', 'cm', 'cm'))\n)\n\nEl objeto plot_layout es un TableGrob de 4 x 4 que define ventanas gráficas con tamaños que coinciden con las alturas de filas y los anchos de columna que pasamos a gtable(). La función gtable_show_layout() proporciona una manera conveniente de visualizar este diseño:\n\ngtable_show_layout(plot_layout)\n\n\n\n\n\n\n\nObserve que este diseño tiene una fila con altura cero y una columna con ancho cero. Colocaremos los grobs xaxis y yaxis en estas filas y les permitiremos “desbordarse” en las filas y columnas adyacentes que especifican los márgenes del gráfico.\nPara colocar los grobs en la mesa, usamos la función gtable_add_grob(). Un diseño TableGrob permite que un grob individual abarque varias celdas usando los argumentos t, l, b y r para especificar índices de celda para las celdas que están más arriba, más a la izquierda, más al fondo y más a la derecha abarcadas por el grob. Sin embargo, el valor predeterminado es asumir que cada grob pertenece exactamente a una celda, en cuyo caso solo es necesario especificar los argumentos t y l:\n\nplot_layout &lt;- gtable_add_grob(\n  plot_layout,\n  grobs = list(points, xaxis, yaxis),\n  t = c(2, 3, 2), # la fila que define la extensión superior de cada grob\n  l = c(3, 3, 2), # la columna que define la extensión izquierda de cada grob\n  clip = 'off'\n)\n\nSi inspeccionamos nuestro objeto plot_layout, vemos algo que tiene la misma estructura que el TableGrob producido por el código ggplot2 anterior:\n\nplot_layout\n#&gt; TableGrob (4 x 4) \"layout\": 3 grobs\n#&gt;   z     cells   name                    grob\n#&gt; 1 1 (2-2,3-3) layout points[GRID.points.630]\n#&gt; 2 2 (3-3,3-3) layout   xaxis[GRID.xaxis.631]\n#&gt; 3 3 (2-2,2-2) layout   yaxis[GRID.yaxis.632]\n\nAhora podemos dibujar nuestra gráfica usando grid.draw():\n\ngrid.newpage()\ngrid.draw(plot_layout)\n\n\n\n\n\n\n\nClaramente, todavía nos faltan muchos detalles importantes que serían necesarios en una gráfica real, pero esperamos que ahora esté claro cómo ggplot2 organiza una colección de grobs dentro de un diseño de gráfica estructurado.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Un caso de estudio</span>"
    ]
  },
  {
    "objectID": "ext-springs.html#sec-spring4",
    "href": "ext-springs.html#sec-spring4",
    "title": "21  Un caso de estudio",
    "section": "\n21.6 Parte 4: Un grid grob",
    "text": "21.6 Parte 4: Un grid grob\nVolvamos al problema que nos ocupa. Armados con nuestro nuevo conocimiento del sistema de rejilla, podemos construir un resorte que especifique el diámetro en unidades absolutas.\n\n21.6.1 springGrob\nComencemos definiendo la función springGrob(). Nuestra idea clave es que podemos escribir el código grob de una manera que impulse la acción de extracción del resorte hasta el nivel de la función makeContent(). Al hacer esto, podemos asegurarnos de que el diámetro se calcule en el momento del dibujo utilizando unidades absolutas en lugar de definir el diámetro en relación con las coordenadas del trazado.\nComenzaremos creando nuestra función constructora. Los argumentos de esta función se basan en segmentsGrob() ya que, en esencia, estamos dibujando segmentos modificados:\n\nspringGrob &lt;- function(x0 = unit(0, \"npc\"), \n                       y0 = unit(0, \"npc\"), \n                       x1 = unit(1, \"npc\"), \n                       y1 = unit(1, \"npc\"), \n                       diameter = unit(0.1, \"npc\"), \n                       tension = 0.75,\n                       n = 50, \n                       default.units = \"npc\", \n                       name = NULL, \n                       gp = gpar(), \n                       vp = NULL) {\n  \n  # Utilice la unidad predeterminada si el usuario no especifica una\n  if (!is.unit(x0)) x0 &lt;- unit(x0, default.units)\n  if (!is.unit(x1)) x1 &lt;- unit(x1, default.units)\n  if (!is.unit(y0)) y0 &lt;- unit(y0, default.units)\n  if (!is.unit(y1)) y1 &lt;- unit(y1, default.units)\n  if (!is.unit(diameter)) diameter &lt;- unit(diameter, default.units)\n  \n  # Devuelve un gTree de clase \"spring\"\n  gTree(\n    x0 = x0, \n    y0 = y0, \n    x1 = x1, \n    y1 = y1, \n    diameter = diameter, \n    tension = tension, \n    n = n, \n    name = name, \n    gp = gp, \n    vp = vp, \n    cl = \"spring\"\n  )\n}\n\nVemos que una vez más nuestro constructor es una envoltura muy delgada alrededor de gTree(). No introduce ningún concepto nuevo: todo lo que hace es garantizar que los argumentos se conviertan a unidades si es necesario y luego devuelve un grob compuesto con clase “spring”. El trabajo de dibujar nuestro resorte ocurre en el método makeContent():\n\nmakeContent.spring &lt;- function(x) {\n  \n  # Convertir valores de posición y diámetro en unidades absolutas\n  x0 &lt;- convertX(x$x0, \"mm\", valueOnly = TRUE)\n  x1 &lt;- convertX(x$x1, \"mm\", valueOnly = TRUE)\n  y0 &lt;- convertY(x$y0, \"mm\", valueOnly = TRUE)\n  y1 &lt;- convertY(x$y1, \"mm\", valueOnly = TRUE)\n  diameter &lt;- convertWidth(x$diameter, \"mm\", valueOnly = TRUE)\n  \n  # Deja la tensión y n intacta.\n  tension &lt;- x$tension\n  n &lt;- x$n\n  \n  # Transforme los datos de entrada en un marco de datos que contenga rutas de primavera\n  springs &lt;- lapply(seq_along(x0), function(i) {\n    cbind(\n      create_spring(\n        x = x0[i], \n        y = y0[i], \n        xend = x1[i], \n        yend = y1[i], \n        diameter = diameter[i], \n        tension = tension[i], \n        n = n\n      ),\n      id = i\n    )\n  })\n  springs &lt;- do.call(rbind, springs)\n  \n  # Construir el grob\n  spring_paths &lt;- polylineGrob(\n    x = springs$x, \n    y = springs$y, \n    id = springs$id, \n    default.units = \"mm\", \n    gp = x$gp\n  )\n  setChildren(x, gList(spring_paths))\n}\n\nNuevamente hay un par de nuevas funciones de cuadrícula aquí, pero esperamos que no sea demasiado difícil descubrir qué hacen. La verdad es que aquí no pasa nada especial. Cada vez que se cambia el tamaño del gráfico, tomamos las coordenadas y la configuración del diámetro del resorte y los convertimos todos a milímetros. Sólo después de convertir las cantidades importantes a unidades absolutas construimos las rutas de resorte usando la función create_spring() que escribimos al principio: al llevar la llamada a create_spring() a este nivel, podemos asegurarnos de que la ruta sea definido usando unidades absolutas y luego devuelve el resultado como un grob de polilínea.\nAhora tenemos un spring grob adecuado para usar en ggplot2. En la siguiente sección construiremos una geom a su alrededor, pero antes de hacerlo, verifiquemos que nuestro código se comporte como se esperaba:\n\nsprings &lt;- springGrob(\n  x0 = c(0, 0),\n  y0 = c(0, 0.5),\n  x1 = c(1, 1),\n  y1 = c(1, 0.5),\n  diameter = unit(c(1, 3), \"cm\"),\n  tension = c(0.2, 0.7)\n)\ngrid.newpage()\ngrid.draw(springs)\n\n\n\n\n\n\n\nEsto se ve bien, por lo que ahora podemos diseñar nuestra nueva (y final) geom.\n\n21.6.2 El último GeomSpring\nAhora que tenemos un grob personalizado que dibuja resortes, podemos crear un objeto ggproto GeomSpring que lo use. Aquí está el código completo para esa geom:\n\nGeomSpring &lt;- ggproto(\"GeomSpring\", Geom,\n  \n  # Compruebe que el usuario haya especificado parámetros sensibles                    \n  setup_params = function(data, params) {\n    if (is.null(params$n)) {\n      params$n &lt;- 50\n    } else if (params$n &lt;= 0) {\n      rlang::abort(\"Springs must be defined with `n` greater than 0\")\n    }\n    params\n  },\n  \n  # Verifique los datos de entrada y devuelva grobs\n  draw_panel = function(data, \n                        panel_params, \n                        coord, \n                        n = 50, \n                        lineend = \"butt\", \n                        na.rm = FALSE) {\n    \n    # Elimine los datos faltantes y regrese temprano si faltan todos\n    data &lt;- remove_missing(\n      df = data, \n      na.rm = na.rm,\n      vars = c(\"x\", \"y\", \"xend\", \"yend\", \"linetype\", \"linewidth\"),\n      name = \"geom_spring\"\n    )\n    if (is.null(data) || nrow(data) == 0) return(zeroGrob())\n    \n    # Proporcionar el sistema de coordenadas para la gráfica.\n    if (!coord$is_linear()) {\n      rlang::warn(\n        \"spring geom only works correctly on linear coordinate systems\"\n      )\n    }\n    coord &lt;- coord$transform(data, panel_params)\n    \n    # Construir el grob\n    springGrob(\n      coord$x, \n      coord$y, \n      coord$xend, \n      coord$yend,\n      default.units = \"native\", \n      diameter = unit(coord$diameter, \"cm\"),\n      tension = coord$tension, \n      n = n,\n      gp = gpar(\n        col = alpha(coord$colour, coord$alpha),\n        lwd = coord$linewidth * .pt,\n        lty = coord$linetype,\n        lineend = lineend\n      )\n    )\n  },\n  \n  # Especificar la estética predeterminada y requerida\n  required_aes = c(\"x\", \"y\", \"xend\", \"yend\"),\n  default_aes = aes(\n    colour = \"black\", \n    linewidth = 0.5, \n    linetype = 1L, \n    alpha = NA, \n    diameter = 0.35, \n    tension = 0.75\n  )\n)\n\nHay algunas cosas a tener en cuenta aquí. Como era de esperar, los principales cambios con respecto a la última versión se encuentran en el método draw_panel() (ver más abajo). Pero hay un par de cambios más.\n\nLas versiones anteriores de GeomSpring, y StatSpring anteriores, incluían un método setup_data() que modificaba la columna de grupo en los datos de entrada. Eso ya no existe: ya no necesitamos preocuparnos por esto porque esta nueva versión de geom no llama a create_spring() directamente. En lo que respecta a la geom, cada resorte está definido por una (y solo una) fila en los datos de entrada. Todo el trabajo de “expandir” esto a un camino similar a un resorte lo realiza grob.\nEsta versión de GeomSpring tiene un método setup_params(). Su única función es comprobar el número de puntos utilizados para definir el resorte.\nEl campo default_aes es ligeramente diferente. El cambio importante es que ahora podemos establecer un valor predeterminado significativo para diameter.\n\nAhora echemos un vistazo más de cerca al nuevo método draw_panel(). Debido a que ya no dependemos de GeomPath$draw_panel() para hacer el trabajo, tenemos algunas tareas nuevas de las que ocuparnos:\n\nComprueba si el sistema de coordenadas no es lineal (por ejemplo, coord_polar()) y, de ser así, emite una advertencia porque nuestro resorte no está diseñado para funcionar en ese contexto.\nUtiliza el sistema de coordenadas para reescalar la estética posicional llamando al método transform() para el objeto coord. Esto reasigna toda la estética posicional para que se encuentre entre 0 y 1, siendo 0 el valor más bajo visible en nuestra ventana gráfica (expansiones de escala incluidas) y 1 el más alto. Con esta reasignación las coordenadas están listas para pasar al grob.\nPasamos un conjunto de parámetros gráficos al grob usando la función grid gpar(). No todos los grobs se preocupan por todas las entradas en gpar() y dado que estamos construyendo una línea, solo nos preocupamos por los parámetros gráficos que polylineGrob() entiende, a saber: col (color de trazo), lwd (línea ancho), lty (tipo de línea), lineend (la forma del terminador de la línea).\n\nAhora que GeomSpring está definido, todo lo que queda es crear una función constructora que el usuario pueda llamar:\n\ngeom_spring &lt;- function(mapping = NULL, \n                        data = NULL, \n                        stat = \"identity\", \n                        position = \"identity\", \n                        ..., \n                        n = 50, \n                        lineend = \"butt\", \n                        na.rm = FALSE, \n                        show.legend = NA, \n                        inherit.aes = TRUE) {\n  layer(\n    data = data, \n    mapping = mapping, \n    stat = stat, \n    geom = GeomSpring, \n    position = position, \n    show.legend = show.legend, \n    inherit.aes = inherit.aes, \n    params = list(\n      n = n, \n      lineend = lineend, \n      na.rm = na.rm, \n      ...\n    )\n  )\n}\n\nPor fin podemos darle un buen uso a nuestra nueva función geom_spring():\n\nggplot(df) + \n  geom_spring(aes(\n    x = x * 100, \n    y = y, \n    xend = xend, \n    yend = yend, \n    diameter = diameter, \n    tension = tension\n  ))\n\n\n\n\n\n\n\nComo puede ver en el resultado anterior, ahora tenemos resortes que se comportan de manera sensata cuando cambia la relación de aspecto de la gráfica o cuando los ejes xey están en diferentes escalas. Cambiar el tamaño del gráfico activará un nuevo cálculo de la ruta correcta, por lo que seguirá luciendo como debería.\n\n21.6.3 Post mortem\nPor fin hemos llegado a la geom de primavera que nos propusimos realizar. La estética del diámetro de nuestro resorte tiene un comportamiento similar a la estética del ancho de línea, en el sentido de que permanece fija al cambiar el tamaño y/o cambiar la relación de aspecto del gráfico. Todavía hay mejoras que podríamos (y quizás deberíamos) hacer. Lo más notable es que nuestra función create_spring() permanece sin vectorizar y debe llamarse para cada resorte por separado. Vectorizar correctamente esta función permitirá una aceleración considerable al renderizar muchos resortes (si alguna vez fuera necesario). Dejaremos esto como ejercicio para el lector.\nAunque la geom ya está terminada, todavía nos queda un poco de trabajo por hacer. Necesitamos crear una escala de diámetro y proporcionar claves de leyenda que puedan comunicar correctamente el diámetro y la tensión. Este será el tema de la sección final.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Un caso de estudio</span>"
    ]
  },
  {
    "objectID": "ext-springs.html#sec-spring5",
    "href": "ext-springs.html#sec-spring5",
    "title": "21  Un caso de estudio",
    "section": "\n21.7 Parte 5: Escalas",
    "text": "21.7 Parte 5: Escalas\nEl último paso de nuestro proceso es definir nuevas escalas. Queremos hacer esto porque hemos definido dos nuevas estéticas (diámetro y tensión) y nos gustaría que los usuarios pudieran escalarlas. No hay nada de malo en definir una nueva estética sin proporcionar una escala, lo que significa que los valores mapeados se pasan sin cambios, pero si queremos que los usuarios tengan cierto control y la posibilidad de una leyenda, necesitaremos proporcionar escalas. por la estetica. Este es el objetivo de esta sección final.\n\n21.7.1 Escalada\nAfortunadamente, en comparación con el trabajo que hemos realizado hasta ahora, crear nuevas escalas no es una tarea enorme. Discutimos las ideas básicas en Sección 20.5 y podemos aplicar esos conceptos aquí sin demasiado dolor. Nuestra tarea principal es crear una función con el nombre apropiado que genere un objeto Scale. La mayoría de las funciones de escala son simples envoltorios alrededor de una de las tres funciones constructoras de escala fundamentales, continuous_scale(), discrete_scale() y binned_scale(). Así es como lo hacemos para la estética de la tensión:\n\nscale_tension_continuous &lt;- function(..., range = c(0.1, 1)) {\n  continuous_scale(\n    aesthetics = \"tension\", \n    scale_name = \"tension_c\", \n    palette = scales::rescale_pal(range), \n    ...\n  )\n}\n\nEsta función scale_tension_continuous() indica a qué aesthetics se aplica, proporciona un scale_name explícito y proporciona una función palette que transforma el dominio de entrada al rango de salida. Todos los demás argumentos que normalmente esperaría ver en una función de escala, como name, breaks, limits, se pasan a continuous_scale() con los puntos ....\nPara la estética de la tensión, esperamos que los usuarios la apliquen sólo a escalas continuas, por lo que es conveniente definir scale_tension() como un alias para scale_tension_continuous():\n\nscale_tension &lt;- scale_tension_continuous\n\nFinalmente, como no queremos que la gente intente mapear la estética de la tensión en datos discretos, también definiremos una función scale_tension_discrete() que siempre arroja un error:\n\nscale_tension_discrete &lt;- function(...) {\n  rlang::abort(\"Tension cannot be used with discrete data\")\n}\n\nLa razón por la que esto funciona es que ggplot2 asigna la escala predeterminada para la estética buscando una función llamada scale_&lt;aesthetic-name&gt;_&lt;data-type&gt;, por lo que cada vez que el usuario asigna la tensión estética a una variable discreta, ggplot2 encontrará la función scale_tension_discrete() y arroja el error. Esta es también la razón por la que es importante incluir scale_tension_continuous() incluso cuando esperamos que la mayoría de los usuarios utilicen el alias scale_tension().\nLas funciones de escala para la estética del diámetro son sólo un poco más complicadas:\n\nscale_diameter_continuous &lt;- function(..., \n                                      range = c(0.25, 0.7), \n                                      unit = \"cm\") {\n  range &lt;- grid::convertWidth(\n    unit(range, unit), \n    \"cm\", \n    valueOnly = TRUE\n  )\n  continuous_scale(\n    aesthetics = \"diameter\", \n    scale_name = \"diameter_c\", \n    palette = scales::rescale_pal(range), \n    ...\n  )\n}\nscale_diameter &lt;- scale_diameter_continuous\nscale_tension_discrete &lt;- function(...) {\n  rlang::abort(\"Diameter cannot be used with discrete data\")\n}\n\nEl único cambio que hicimos con respecto a las escalas de tension es que permitimos al usuario definir en qué unidad se debe medir el rango de diámetro. Dado que el geom espera centímetros, convertiremos el rango a eso antes de pasarlo al constructor de escalas. De esa manera, el usuario es libre de utilizar cualquier unidad absoluta que le parezca natural.\nCon nuestras escalas definidas, echemos un vistazo:\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    tension = tension, \n    diameter = diameter\n  )) + \n  scale_tension(range = c(0.1, 5)) \n#&gt; Warning: The `scale_name` argument of `continuous_scale()` is deprecated as of ggplot2\n#&gt; 3.5.0.\n\n\n\n\n\n\n\nEn este resultado podemos ver que las escalas predeterminadas funcionan (es decir, no agregamos una escala explícita para el diámetro pero el gráfico se representa correctamente), al igual que las escalas personalizadas (es decir, llamamos explícitamente scale_tension()).\nEl resultado también nos dice que nuestro trabajo no ha terminado porque la leyenda no es muy útil. La razón de esto es que nuestra geom está utilizando el constructor de claves de leyenda predeterminado, draw_key_point(). Esta función no entiende nuestra nueva estética, por lo que la ignora por completo. Podemos solucionar este problema definiendo una función clave de leyenda personalizada, draw_key_spring().\n\n21.7.2 draw_key_spring\nEchemos un vistazo a cómo se escribe un constructor de claves, inspeccionando el código fuente para draw_key_point(). Afortunadamente, estas son funciones bastante simples que toman un marco de datos de valores estéticos y devuelven un grob apropiado que proporciona las representaciones que se muestran en la clave de leyenda:\n\ndraw_key_point\n#&gt; function(data, params, size) {\n#&gt;   if (is.null(data$shape)) {\n#&gt;     data$shape &lt;- 19\n#&gt;   } else if (is.character(data$shape)) {\n#&gt;     data$shape &lt;- translate_shape_string(data$shape)\n#&gt;   }\n#&gt; \n#&gt;   # NULL means the default stroke size, and NA means no stroke.\n#&gt;   stroke_size &lt;- data$stroke %||% 0.5\n#&gt;   stroke_size[is.na(stroke_size)] &lt;- 0\n#&gt; \n#&gt;   pointsGrob(0.5, 0.5,\n#&gt;     pch = data$shape,\n#&gt;     gp = gpar(\n#&gt;       col = alpha(data$colour %||% \"black\", data$alpha),\n#&gt;       fill = fill_alpha(data$fill %||% \"black\", data$alpha),\n#&gt;       fontsize = (data$size %||% 1.5) * .pt + stroke_size * .stroke / 2,\n#&gt;       lwd = stroke_size * .stroke / 2\n#&gt;     )\n#&gt;   )\n#&gt; }\n#&gt; &lt;bytecode: 0x55ff603a7cd0&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\nEn este código, data es un marco de datos con una sola fila que proporciona los valores estéticos que se utilizarán para la clave, params son los parámetros geográficos de la capa y size es el tamaño del área clave en centímetros. El operador %||%, que se ve a menudo en el código fuente de tidyverse, se usa para proporcionar valores predeterminados siempre que una variable tiene un valor nulo:\n\n`%||%` &lt;- function(x, y) {\n  if (is.null(x)) y else x\n}\n\nPara definir nuestra función draw_key_spring(), necesitamos crear una función análoga que use springGrob() para dibujar la clave:\n\ndraw_key_spring &lt;- function(data, params, size) {\n  springGrob(\n    x0 = 0, \n    y0 = 0, \n    x1 = 1, \n    y1 = 1,\n    diameter = unit(data$diameter, \"cm\"), \n    tension = data$tension,\n    gp = gpar(\n      col = alpha(data$colour %||% \"black\", data$alpha),\n      lwd = (data$size %||% 0.5) * .pt,\n      lty = data$linetype %||% 1\n    ),\n    vp = viewport(clip = \"on\")\n  )\n} \n\nLa única parte de este código que puede resultar desconocida es la pequeña floritura (no estrictamente necesaria) que define una ventana gráfica de recorte para nuestro grob usando el argumento vp. La razón por la que agregamos esto es para garantizar que los resortes dibujados en las claves de leyenda estén estrictamente contenidos dentro de sus cajas y no se extiendan a las áreas clave vecinas.\nAhora que tenemos esta función, todo lo que tenemos que hacer es decirle a GeomSpring que la use al dibujar la clave de leyenda. Eso es bastante sencillo: todo lo que tenemos que hacer es cambiar el método draw_key() de nuestro Geom existente:\n\nGeomSpring$draw_key &lt;- draw_key_spring\n\nCon ese cambio final nuestra leyenda empieza a tener sentido:\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    tension = tension, \n    diameter = diameter\n  )) + \n  scale_tension(range = c(0.1, 5))\n\n\n\n\n\n\n\nEl tamaño de clave predeterminado es un poco estrecho para nuestra clave, pero eso es algo que el usuario deberá hacer: ggplot2 no conoce la estética del diameter y no puede escalar el tamaño de la clave tan inteligentemente como lo hace con la estético size.\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    tension = tension, \n    diameter = diameter\n  )) + \n  scale_tension(range = c(0.1, 5)) +\n  theme(legend.key.size = unit(1, \"cm\"))\n\n\n\n\n\n\n\nConvenientemente, nuestra nueva clave de leyenda se utilizará para todas las estéticas escaladas, no solo para diameter y tension, asegurando así que el estilo de la clave siempre coincidirá con el estilo de la capa:\n\nggplot(df) + \n  geom_spring(aes(\n    x = x, \n    y = y, \n    xend = xend, \n    yend = yend, \n    colour = class\n  )) + \n  theme(legend.key.size = unit(1, \"cm\"))\n\n\n\n\n\n\n\n\n21.7.3 Post mortem\nCon esto concluye nuestro estudio de caso detallado sobre la creación de una geom de resorte. Con suerte, ha quedado claro que hay muchas formas diferentes de lograr la misma extensión de geom y que el resultado final depende en gran medida de tus necesidades y de la cantidad de energía que quieras ponerle. El estudio de caso se centró en capas y (en menor medida) escalas, pero con suerte puedes usar los ejemplos más simples de Capítulo 20 como guía si deseas explorar otros tipos de extensiones de ggplot2. También puedes estudiar el código fuente de las clases faceta y coord en ggplot2 y las extensiones disponibles en ggforce y otros paquetes.\n\n\n\n\nMurrell, Paul. 2018. R Graphics. Third. Chapman & Hall/CRC. https://www.stat.auckland.ac.nz/~paul/RG3e/.",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Un caso de estudio</span>"
    ]
  },
  {
    "objectID": "ext-springs.html#footnotes",
    "href": "ext-springs.html#footnotes",
    "title": "21  Un caso de estudio",
    "section": "",
    "text": "Si tiene experiencia en estadística, reconocerá que esto es más o menos análogo a cómo se calcula una estadística z.↩︎\nSi tiene experiencia en el desarrollo de paquetes, es posible que se pregunte acerca de la opción de usar rlang::abort() en lugar de usar la función base stop(). Ciertamente podríamos haber elegido usar la función base R aquí, pero como ggplot2 usa el paquete rlang, en este caso hay muy poca diferencia.↩︎\nSi planeáramos agrupar este código como un paquete R, podríamos ampliarlo y escribir pruebas unitarias formales para create_spring() usando el paquete testthat.↩︎\nPor convención, las clases de ggproto siempre usan CamelCase para nombrar y la nueva clase siempre se guarda en una variable con el mismo nombre.↩︎\nComo mencionamos anteriormente, ggproto no hace una fuerte distinción entre métodos y campos. Los objetos Stat esperan que compute_group() sea una función, por lo que nos referimos a compute_group() como método porque esa es la terminología estándar en la programación orientada a objetos. Por el contrario, Stat espera que required_aes sea una variable, por eso lo llamamos campo.↩︎",
    "crumbs": [
      "Temas avanzados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Un caso de estudio</span>"
    ]
  }
]